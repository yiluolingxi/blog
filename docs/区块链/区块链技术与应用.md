- 有人说区块链是下一代的价值互联网，有人说区块链是世界上最慢的数据库？     
因为很多人他不是真正懂区块链，他只是在讨论比较务虚的商业模式，有些商业模式，它跟区块链的本质没有什么关系。  
如果把它当数据库用的话，它非常的慢，而且只实现了数据库中很小的一部分  。

下图显示比特币价值变化情况：   
![](Pasted%20image%2020240315113818.png)早期比特币发行的时候价格变化不是很明显，2017年1月的时候呈现了爆发式增长，也是各种加密货币爆发的一年，2018年就开始往下掉。   

上图是为了说明两点：    
1. 从区块链的整体发展来看，现在还是处于非常早期阶段  
2. 区块链并不等于比特币，比特币只是基于区块链技术的一种加密货币而已      

下图显示的是各种加密货币所占的市场份额：      
![](Pasted%20image%2020240315114916.png)

早期的时候基本上是比特币一家独大，底下有很少一点份额是莱特币。  
标志性事件：2015年的时候，出现了以太坊，一开始的时候还不是特别引人入目，但后来逐渐成为一种主流的加密货币。  

主要讲**比特币**和**以太坊**这两种加密货币：    
![](Pasted%20image%2020240315123549.png)

以太坊发展太快，资料跟不上发展速度，遵循以代码为准的原则，若遇到一些搞不清楚的地方，看源代码    

![](Pasted%20image%2020240315124025.png)
![](Pasted%20image%2020240315124102.png)

![](Pasted%20image%2020240315124255.png)     

BTC是比特币（Bitcoin）的缩写，是一种数字货币或加密货币。比特币由一位或多位匿名人士（使用化名“中本聪”）在2008年提出，并于2009年以开源软件的形式发布。比特币允许人们通过一个去中心化的网络进行交易，这个网络基于一种称为区块链的分布式账本技术。用户可以通过所谓的挖矿过程来创建新的比特币，同时网络也处理和记录所有的交易。比特币的目的是提供一种不依赖于中央机构的电子支付系统。  

## BTC-密码学原理
比特币被称为加密货币（Crypto-currency，/ˈkrɪptəˌkɜːrənsi/），当前是加密货币，是不加密的，区块链上所有的交易内容都是公开的（包括账户的金额、转账的地址都是公开的）。   

比特币中运用到了密码学中的两个功能：  
- 哈希 
- 签名

## 哈希功能

**密码学中用的哈希函数**被称为：cryptographic hash functions 加密哈希函数  

它有两个比较重要的性质：  

1. **Collision Resistance（/kəˈlɪʒən rɪˈzɪstəns/, 抗碰撞性）**：这意味着找到两个不同的输入值，它们产生相同的哈希输出是极其困难的。这保证了哈希函数的唯一性，从而确保数据的完整性。
2. **hiding**：意思是哈希函数的计算过程是单向的，是不可逆的。

**Collision指哈希碰撞**：X≠Y, H(X)=H(Y)  

说明：比如说有两个输入X和Y，X≠Y，但是，比如说我们的哈希函数叫H，算出来的 H(X)=H(Y)  ，那么这就叫做哈希碰撞 ，两个不同的输入算出来的哈希值是相等的。  

哈希碰撞是很常见的，像我们使用哈希表的过程中，就会遇到哈希碰撞，不同的输入可能会被映射到哈希表当中的同一个位置，一般来说呢，哈希碰撞是不可避免的，因为输入空间是远远大于输出空间。比如说我们有一个256位的哈希值。    

那输出空间有多大？  
所有哈希值的取值可能就是2的250次方。输出空间就只有这么大。   

但是输入空间可以是无限大的，所以它是有任意多种数的可能性。按照鸽笼原理（Pigeonhole Principle，/ˈpɪdʒənˌhoʊl ˈprɪnsəpl/）的话，必然会出现有两个输入被映射到同一个输出的情况。  

所以我们这里说的collision resistance,并不是说不会出现哈希碰撞。实际上碰撞时客观存在的，他这个意思是说没有什么高效的方法，人为的去制造哈希碰撞。    

就给定一个X，没有什么好办法，你能找到另外一个Y，使得X和Y的哈希值恰好相等，就你没有什么高效的方法去找。  

你硬要找的话，可以用蛮力求解的方法，比如说这个X和这个Y，你就遍历所有输入的可能性，然后看看哪一个算出来它是要相等，尤其这种叫做Brute- force，遍历输的所有可能取值，最后找了一个哈希值差不多类型，  
但是如果这个输入空间比较大，比如说是对于一个哈希值是256位的话，实际上你要用这种方法去找的话，在实际中是不可行的，他工作量实在是太大了。

### **Collision Resistance** 性质的作用：
它可以用来对一个`message`求`digest` ，比如说我们有个`message`叫`m`,我们取他的哈希值`H(m)`,这个哈希值可以认为是这个`message`的`digest`,用来检测对这个`message`的篡改,比如说如果有人改这个`message`内容，它的哈希值就会发生变化，那么collision resistance性质就是说你找不到另外一个`m'`，使得这个`m'`取哈希之后`H(m')`跟原来的哈希值恰好相等。  
是没有办法能够篡改内容而又不被检测出来。  

比如说你有一个很大的文件，你想把它存放到某个云存储服务上，将来你用到的时候再把它下载回来，那么你怎么知道你下载的版本跟你当初上传的版本是一样的？这就可以用到这个哈希函数的** Collision Resistance 性质**，这个在你上传这个文件之前呢，先算一个哈希值出来，这个哈希值呢，存在本地，将来你下载之后呢，再算一个哈希值，因为原来你存的哈希值比较一下，如果是一样的话，那么说明上传的这个文件没有被篡，下载的还是原来那个当初的版本，这就是**Collision Resistance**一个用处。

#### 结论：没有哪个哈希函数,能够在数学上证明是**Collision Resistance**，也就是说我们刚才讲这么重要的一个性质，从理论上是证不出来的，这个只能靠实践中的经验。有些哈希函数经过长期的实践检验，世界上有那么多密码学的专家，谁也没有能够找到人为制造哈希碰撞的方法，所以呢，我们就认为这些哈希函数是肯定**Collision Resistance**，比如实践经验。也有一些哈希函数，以前我们认为是**Collision Resistance**，但是后来大家找到了制造哈希碰撞的方法。

- MD5:曾经是很流行的哈希函数，大家原来以为它很安全，但是现在已经不行了，我们已经知道怎么去人为的制造哈希碰撞。

### hiding
说明：给定一个输入X，可以算出它的哈希值H(X),但是,从那个哈希值H(X)没有办法反推出原来的输入X。就换句话说呢，这个哈希值没有泄露有关这个输入的任何信息。  

如果你想知道这个输入的话，也是有办法。怎么办？还是用那种蛮力的方法，我把这个输入所有可能的取值遍历一遍，看看哪个哈希值跟这个相等，这我就能猜出来原来的数是什么，所以蛮力求解是一种办法。  

**hiding**这个性质成立的前提是，这个输入空间要足够的大，使得这种蛮力求解的方法是不可行的。  
而且呢，这个输入的分布要比较均匀，各种取值的可能性都是差不多的，  
如果这个输入空间虽然是很大，但是呢，绝大多数情况下，取值都是集中在少数几个值，那么也是比较容易被破解的。  

 ### hiding性质的作用：  
 它可以和 **Collision Resistance** 的性质结合在一起，用来实现**digital commitment**（Digital equivalent of a sealed envelope）。  

先说一下现实生活中**sealed envelope**（数字安全领域的加密技术）的作用，比如说有一个人说他能够预测股市，可以预测第二天哪些股票会涨停。那怎么证明这个人预测的是不是准确呢？一种办法是，这人提前一天在电视台上公布预测结果，我预测明天某某股票会涨停。第二天收盘之后呢，看一下这个股票是不是真的涨停，就知道预测准不准。这样做有什么问题吗？这好像是一种检验预测准的方法，有什么问题？如果你预测结果提前公布了，可能会影响股市，就比如说这个人很有名气，大家觉得这是个股神，本来这支股票不会涨停，他这么一公开预测，大家拼命去买，结果它变成了涨停。当然，反方向的情况也可能发生，这支股票也许本来确实是要涨停的，有人想踢场子，你不是预测它涨停吗？我就不让他涨停，拼命的砸盘，这都有可能发生。这说明一个什么道理？预测结果不能够提前公开。但是如果预测结果不提前公开，你等第二天收盘了之后再公开，那你怎么知道这个预测结果有没有被篡改，你最后公开的结果是不是你提前一天做出来的，这个就要用到我们说的**sealed envelope**，叫你把你的一结我写在一张纸上，放到一个信封里给封好了，这个信封要交给第三方的公证机构保管，等第二天收盘之后再把它打开，验证一下这个结果准不准。

那在电子世界里，我要有一个Digital（"Digital"指的是数字资产或数字化的资产） ，**sealed envelope**怎么实现？  
把这个预测结果作为输入X，算出一个哈希值，然后把这个哈希值可以公布出去，因为我们有这个**hiding** 的性质，所以你从这个哈希值不知道预测结果是什么，然后第二天收盘之后呢，我再把预测结果公布出去，因为有这个**Collision Resistance** 的性质，所以我这个预测结果是不可能篡改的，你要是改的话，就跟当初公布的这个哈希值是对不上。这就起到一个**sealed envelope**的功能。

 **hiding** 性质的前提是：   
输入空间要足够大，然后分布呢，要比较均匀，如果这个输入不满足这个性质，像我举的这个例子当中，预测第二天哪只股票会涨停，这股票一共就那么几千只，这个输入空间不是足够大。那么常用的方法是把这个输入，后面拼接一个随机数，然后再一起取哈希**H(X || nonce)**，然后这个时候是X后面拼一个随机的叫**nonce**，然后整个取哈希。  
**nonce**是我们选取的一个随机数，保证这样拼接之后整个输入是足够随机的，然后分布也是足够均匀，这实际中操作要注意的一些细节。   

### puzzle friendly
除了密码学中要求的这2个性质之外，比特币中用到的哈希函数还要求第3个性质，叫**puzzle friendly**  :  
它的意思是说，哈希值的计算事先是不可预测的，你光是看这个输入，你很难猜出来他最后的哈希值是什么。所以如果你想要你算出的哈希值是落在某个范围之内的，那没有什么好办法，你就只能是一个一个输入去试，看哪个输算出来恰好是落在要求那个范围。  
比如说你想得到一个哈希值，前面K位都是0，前面是一串0，后面可以是任意的，整个是256位。  
必须以K个0开始，那什么样的输入会算出这样的哈希值呢？不知道  
这个**puzzle friendly**是说你事先是不知道的，哪个输入更有可能算出这个哈希值，那你要得到这个哈希值，就一个一个去试，没有什么捷径。   
![](Pasted%20image%2020240315213853.png)


这个性质为什么叫**puzzle friendly**？   
挖矿实际上就是找一个`nonce`，找这么一个随机数。这个`nonce`呢，跟区块的块头里的其他信息合在一起作为输入，取出一个哈希来，那个哈希值要小于等于某个指定的目标阈值。  
![](Pasted%20image%2020240315215632.png)
比特币是区块链对吧？区块链就是一个一个区块组成的链表，每个区块有一个块头`block header`，`block header`里面有很多的阈，其中有一个阈是我们可以设置的随机数`nonce`。      
那么挖矿的过程就是不停的去使各种随机数，使得整个`block header`取哈希之后，落在指定的范围之内，小于等于一个`target space`。    

![](Pasted%20image%2020240315221853.png)
比如说这个是整个的输出空间`output space`，我们要求这个算出的哈希值只有落在前面这一点才是合法的，这个是`target space`。  
这个**puzzle friendly**的性质是说，这个挖矿的过程没有捷径，只能靠不停的去试大量的`nonce`，才能找到符合要求的值，所以这个过程才可以用来作为`Proof of work`工作量证明。  
你挖到矿了，找到符合要求的，那一定是因为你做过大量的工作，没有捷径。   
但是一旦有人找到了这样一个`nonce`，发布出去之后，其他人要验证这个`nonce`是不是符合要求是很容易的，只要算一次哈希值就行了，就这个`nonce`作为`header`的一部分，算一次哈希值，看它是不是小于等于这个目标阈值。  挖矿很难，验证很容易。这个性质叫做: `diffcult to solve,but easy to verify`
我们设计这种`Money puzzle`的时候,，要注意这个性质。    


**比特币用的哈希函数**叫做`SHA-256`  
`SHA`意思是Secure Hash Algorithm(安全哈希算法)  

`SHA`拥有3个特质：   
- Collision Resistance
- hiding
- puzzle friendly

---
备注：
### 哈希碰撞的原理

- **鸽巢原理**（或 鸽笼原理）: 假设你有n+1个鸽子和n个鸽巢，如果每个鸽子都要进入一个鸽巢中，那么至少有一个鸽巢里会有两个或以上的鸽子。应用到哈希函数上，由于输入的可能性是无限的，而输出的长度是固定的，因此必然存在至少两个不同的输入被映射到同一个输出。
- **概率和复杂性**: 对于一个理想的哈希函数，任意两个不同的输入碰撞的概率应当非常低。然而，由于上述的鸽巢原理，碰撞是不可避免的。好的哈希函数设计旨在使得找到这样的碰撞变得计算上不可行。（意味着即使使用最强大的现有计算资源，也极其困难（或需要不切实际的长时间）来找到两个不同的输入值，它们通过同一个哈希函数处理后产生相同的输出。）
### 碰撞的影响

在某些应用中，如密码学的散列函数，碰撞可能会带来安全性问题。如果攻击者能够找到两个不同的输入，它们产生相同的哈希值，他们可能会利用这一点来破坏系统的完整性或者伪造数据。

为了减少碰撞的可能性，哈希函数需要满足一定的设计准则和安全性要求。

---
## 签名功能

要想讲签名的话，我们得先讲一下比特币系统中的账户管理。  
日常生活中，如果你想开个账户的话，你怎么办？你带上证件去银行办理开户手续，对不对？这就是中心化系统的账户管理方式。  
那比特币呢，是去中心化，他没有这种银行事业机构，那怎么开账户呢？每个用户自己决定开户，不需要任何人批准，开户的过程很简单，就是创立一个公钥和私钥的对(`public key,private key`)，这个在比特币中就代表一个账户。  

公私钥这个概念呢，是来源于**非对称的加密体系**，叫做：`asymetric encryption algorithm`（非对称加密算法）  

最早的加密体系是对称的，`symmetric encryption`（对称加密算法）。    
比如说两个人之间要进行通讯。我要把哪个信息发给你，但是这个通讯的网络是有可能被窃听的，那怎么办呢？咱们俩事先商量好一个密钥`encryption key`。我把这个信息加密之后发给你，你收到之后再用这个密钥解密。因为这个加密和解密用的是同一个密钥，所以这个叫做对称的加密体系。  
他这个前提是假设有某种安全的渠道能够把这个密钥分发给通讯的双方，因为你显然不能够说把这个秘钥以明文的形式在网络上传输。我们假设网络本身就是不安全的，有可能被窃。这个其实是对称加密体系的一个弱点就是密钥的分发不是很方便。  

为了解决这个问题呢？非对称加密体系就提出来，我们不是用一个密钥，而是用一对密钥，就有一个公钥和一个私钥。  
加密用的是公钥，解密用的是私钥，就比如说我要把一个信息传给你，我用你的公钥给这个信息加密，你收到之后呢，再用你的私钥解密，得到原来的信息，就大家注意这个加密和解密用的是同一个人的公钥和私钥，都是这个接收方的公钥和私钥。  

这有什么好处呢？  
这个公钥是不用保密的，加密用的公钥是不用保密的，你可以告诉所有人，私钥是要保密的，因为他的解密是用私钥解密，但是私钥只要保存在本地就行了，不用传给对方，就给你通讯的那个人不需要知道你的私钥，他是用你的公钥加密的，你要回复他的话，你再用他的公钥加密，都不需要知道对方的私钥。这就解决了对称加密体系当中密钥分发不方便的问题。    

比特币系统中呢，你要创建一个账户，就在本地产生一个公钥和私钥，一个公钥私钥，这个公钥就相当于你的银行账号，别人要给你转账，只要知道你的公钥就行。这个私钥相当于你的账户密码，知道这个私钥，就可以把这个账户上钱转走。那么有一个问题啊，我们前面说比特币系统是不加密的，它叫加密货币，它其实是不假，信息都是公开的，那我要这个公钥和私钥干嘛？实际上就是用来做签名，就我们讲第二个功能，签名。  

比如说我要转10个比特币给你，10个比特币有很多钱，我很慷慨转给，然后我把这个交易发布到区块链上，别人怎么知道这个交易确实是我发起的，会不会有人冒名顶替，想偷偷的把我的账上的钱转走，这个需要我在发布这个交易的时候，要用我自己的私钥对这个交易签名。那其他收到这个交易之后呢，再用我的公钥去验证这个签名的正确性。  
签名用的是私钥，验证签名用的是这个人的公钥，仍然都是同一个人。  

疑问？  
既然每个人是独立的产生账户，本地独立的生成公司要对不需要任何人批准，那么万一，两个人生成的公司要就恰好相同怎么办？  
就比如说有人想偷取比特币，一种方法是就不停的产生大量的公私钥，然后对比一下我产生的这个公钥跟区块链上某个已有的公钥是不是相同，如果是一样的话呢，就可以用对应的私钥把这个账上的钱给偷走。  
这种攻击方法呢，从理论上说好像是可以的，但是实际当中是不可行的，如果你是256位的哈希值的话，产生相同的公私钥对的可能性是微乎其微的，就即使你有一台超级计算机，别的事情都不干，每天就不停的产生大量的公私钥对，出现两个人的公私钥对相同的概率也是可以忽略不计的，这个概率呢，比地球爆炸的概率还要小，那到目前为止，还没有发现哪个人用这种方法能够攻击成功的先例。  

这里要强调一点：   
就是我们这里假设产生公私钥的时候是有一个好的随机缘，叫做`A good source of randomness`  

生成公私钥的过程显然是随机的，如果不是随机的话，那等于大家都生成同样的公私钥。  
如果你选取的这个随机缘不好的话，那么前面的分析就不成立了。  
比如说就有可能出现两个人的公私钥对生成的是一样。比特币中用的这个签名算法，不光是生成公私钥的时候要有好的随机缘，之后每一次签名的时候也要有好的随机，只要有一次签名的时候用的随机员不好的化，就有可能泄露私钥，然后就全完了。


## 比特币的数据结构

区块链 和 Merkle tree都是用哈希指针构成
    
genesis block    

most recent block    

tamper-evident log     

多米诺牌效应    

Merkle tree  哈希指针代替普通指针   

data blocks  

hash pointers  

root hash 根哈希值  

只要记住，就能检测前面哪个部分的修改（这是Merkle tree的特点）  

tx(交易)  
区块分为两部分：块头和块身  （block header哈希, block body内容）全节点都有

Merkle proof  （轻节点要用到）  

串改数据提供自由度 ，不可行，这是人为制造哈希碰撞（因为collision resistance）    

proof of membership  
proof of incusion 
o(log(n))  
proof of non-membership     

每个叶节点取哈希  

tx先算哈希

Sorted Merkle tree

---
phind 部分
## 比特币数据结构概览

### 常见标准
- **Hashe（哈希）**：用于交易验证和地址生成。
- **Merkle Trees（默克尔树）**：通过允许高效且安全地验证大型数据结构内容的完整性来确保数据完整性。
- **Signatures（签名）**：用于交易验证和确保交易的真实性。
- **Transaction Verification（交易验证）**：确保交易有效且未被篡改的过程。
- **Addresses（地址）**：比特币钱包的唯一标识符。

### 常见结构
- **Message Structure（消息结构）**：定义比特币网络中节点交换的消息格式。
- **Variable Length Integer（可变长度整数）**：以空间高效的方式编码整数。
- **Variable Length String（可变长度字符串）**：以空间高效的方式编码字符串。
- **Network Address（网络地址）**：表示网络中节点的位置。
- **Inventory Vectors（库存向量）**：用于广告节点可用的对象。
- **Block Headers（区块头）**：包含关于区块的元数据，如前一个区块的哈希、时间戳和随机数。
- **Differential Encoding（差分编码）**：一种更空间高效的数据编码方法。
- **PrefilledTransaction**：在紧凑区块中继中用于减少发送的数据量的结构。
- **HeaderAndShortIDs**：在紧凑区块中继中用于进一步减少发送的数据量的结构。
- **BlockTransactionsRequest**：用于请求区块中的交易的消息类型。
- **BlockTransactions**：用于从区块中提供交易的消息类型。
- **短交易ID**：交易ID的紧凑表示。

### 消息类型
- **version（版本）**：用于在节点之间协商协议版本。
- **verack**：确认版本消息。
- **addr**：提供网络中已知节点的信息。
- **inv**：用于广告节点可用的对象。
- **getdata**：请求节点的数据。
- **notfound**：指示请求的对象不可用。
- **getblocks**：请求节点的区块。
- **getheaders**：请求节点的区块头。
- **tx**：用于向网络广播交易。
- **block**：用于向网络广播区块。
- **headers**：用于向网络广播区块头。
- **getaddr**：请求网络中已知节点的信息。
- **mempool**：请求节点的交易内存池信息。
- **checkorder**：请求有关订单的信息。
- **submitorder**：将订单提交到网络。
- **reply**：用于回复消息。
- **ping**：用于检查节点的连通性。
- **pong**：用于响应ping消息。
- **reject**：用于拒绝消息。
- **filterload, filteradd, filterclear, merkleblock**：用于SPV（简化支付验证）节点接收与其钱包相关的交易。
- **alert**：用于向网络广播警报。
- **sendheaders**：请求节点的区块头。
- **feefilter**：用于信号节点的最低可接受交易费用。
- **sendcmpct**：请求节点发送紧凑区块消息。
- **cmpctblock**：用于提供紧凑区块消息。
- **getblocktxn**：请求区块中的交易。
- **blocktxn**：提供区块中的交易。

### 脚本
- **Script（脚本）**：用于交易验证的基于堆栈的脚本语言。
---
ChatGPT4  



[Block Chain — Bitcoin](https://developer.bitcoin.org/devguide/block_chain.html)
[Transactions — Bitcoin](https://developer.bitcoin.org/reference/transactions.html)



 





请把上面内容中的下面文本内容的中文前面加上相对应的英文，再把整部分的完整内容输出，示例：- Version number（版本号）：
文本如下：
- 每个区块包含一个区块头和交易数据。
- 区块头包括：
- 版本号 
- 前一个区块的哈希
- 默克尔树根哈希
- 时间戳
- 难度目标
- 随机数 
- 交易数据包括： 
- 交易版本 
- 输入和输出 
- 锁定时间

# Bitcoin Data Structure Overview

## Introduction

Bitcoin's network architecture is a peer-to-peer system that operates without central authority, maintaining a decentralized ledger known as the blockchain. This ledger records all transactions and is secured through cryptographic means.

## Key Components

### The Blockchain Ledger

- A distributed public ledger recording all bitcoin transactions.
- Transactions are grouped into blocks, added sequentially, creating a chain of blocks or blockchain&#8203;``【oaicite:18】``&#8203;.

### Nodes and Network

- Nodes are computers running Bitcoin software, hosting and distributing copies of the blockchain&#8203;``【oaicite:17】``&#8203;.
- Types of nodes include light nodes (download recent blockchain data) and full nodes (maintain a complete blockchain copy)&#8203;``【oaicite:16】``&#8203;.
- Miners, a special type of node, validate transactions and secure the blockchain&#8203;``【oaicite:15】``&#8203;.

### Proof-of-Work Mining

- Miners solve computational puzzles to add new blocks to the blockchain, receiving bitcoin as a reward&#8203;``【oaicite:14】``&#8203;.
- This process ensures security and consensus without a central authority&#8203;``【oaicite:13】``&#8203;.

### Anatomy of a Block

- Each block contains a block header and transaction data&#8203;``【oaicite:12】``&#8203;.
- The block header includes:
  - Version number
  - Previous block hash
  - Merkle tree root hash
  - Timestamp
  - Difficulty target
  - Nonce&#8203;``【oaicite:11】``&#8203;.

- Transaction data includes:
  - Transaction version
  - Inputs and outputs
  - Lock time&#8203;``【oaicite:10】``&#8203;.

### Bitcoin Halving and Forks

- The block reward halves every 210,000 blocks, reducing the rate of new bitcoin creation&#8203;``【oaicite:9】``&#8203;.
- Forks occur when the blockchain diverges into two paths; these can be soft or hard forks&#8203;``【oaicite:8】``&#8203;.

## Advanced Concepts

### Difficulty Adjustment

- The difficulty of the proof-of-work puzzle adjusts every 2,016 blocks to maintain a consistent block generation time&#8203;``【oaicite:7】``&#8203;.

### Transaction Data and Format

- Transactions include inputs and outputs, each with scripts that dictate spending conditions&#8203;``【oaicite:6】``&#8203;.
- Addresses are encoded from hashes of public keys or scripts, using a base58 encoding scheme&#8203;``【oaicite:5】``&#8203;.

### Raw Transaction Format

- Transactions are serialized in a specific byte format, facilitating network broadcast and verification&#8203;``【oaicite:4】``&#8203;.

### Consensus Rule Changes

- Changes to consensus rules can lead to forks, requiring nodes to update to maintain compatibility&#8203;``【oaicite:3】``&#8203;.

## Conclusion

Bitcoin's innovative data structure and consensus mechanism enable a secure, decentralized currency free from central authority control. Its design incorporates cryptographic principles to ensure transaction integrity and network security.
