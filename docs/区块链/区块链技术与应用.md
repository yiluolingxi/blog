- 有人说区块链是下一代的价值互联网，有人说区块链是世界上最慢的数据库？     
因为很多人他不是真正懂区块链，他只是在讨论比较务虚的商业模式，有些商业模式，它跟区块链的本质没有什么关系。  
如果把它当数据库用的话，它非常的慢，而且只实现了数据库中很小的一部分  。

下图显示比特币价值变化情况：   
![](Pasted%20image%2020240315113818.png)早期比特币发行的时候价格变化不是很明显，2017年1月的时候呈现了爆发式增长，也是各种加密货币爆发的一年，2018年就开始往下掉。   

上图是为了说明两点：    
1. 从区块链的整体发展来看，现在还是处于非常早期阶段  
2. 区块链并不等于比特币，比特币只是基于区块链技术的一种加密货币而已      

下图显示的是各种加密货币所占的市场份额：      
![](Pasted%20image%2020240315114916.png)

早期的时候基本上是比特币一家独大，底下有很少一点份额是莱特币。  
标志性事件：2015年的时候，出现了以太坊，一开始的时候还不是特别引人入目，但后来逐渐成为一种主流的加密货币。  

主要讲**比特币**和**以太坊**这两种加密货币：    
![](Pasted%20image%2020240315123549.png)

以太坊发展太快，资料跟不上发展速度，遵循以代码为准的原则，若遇到一些搞不清楚的地方，看源代码    

![](Pasted%20image%2020240315124025.png)
![](Pasted%20image%2020240315124102.png)

![](Pasted%20image%2020240315124255.png)     

BTC是比特币（Bitcoin）的缩写，是一种数字货币或加密货币。比特币由一位或多位匿名人士（使用化名“中本聪”）在2008年提出，并于2009年以开源软件的形式发布。比特币允许人们通过一个去中心化的网络进行交易，这个网络基于一种称为区块链的分布式账本技术。用户可以通过所谓的挖矿过程来创建新的比特币，同时网络也处理和记录所有的交易。比特币的目的是提供一种不依赖于中央机构的电子支付系统。  

## BTC-密码学原理
比特币被称为加密货币（Crypto-currency，/ˈkrɪptəˌkɜːrənsi/），当前是加密货币，是不加密的，区块链上所有的交易内容都是公开的（包括账户的金额、转账的地址都是公开的）。   

比特币中运用到了密码学中的两个功能：  
- 哈希 
- 签名

密码学中用的哈希函数被称为：cryptographic hash functions 加密哈希函数  

它有两个比较重要的性质：  

1. **Collision Resistance（/kəˈlɪʒən rɪˈzɪstəns/, 抗碰撞性）**：这意味着找到两个不同的输入值，它们产生相同的哈希输出是极其困难的。这保证了哈希函数的唯一性，从而确保数据的完整性。
2. **hiding**：意思是哈希函数的计算过程是单向的，是不可逆的。
    
2. **Pre-image Resistance（/ˈpriːˌɪmɪdʒ rɪˈzɪstəns/, 隐匿性）**：给定一个哈希值，要找到一个特定的输入值（或称为“原像”），使其通过哈希函数产生该哈希值是不可行的。这个特性保护了数据的原始内容，防止了原始数据的还原。

**Collision指哈希碰撞**：X≠Y, H(X)=H(Y)  

说明：比如说有两个输入X和Y，X≠Y，但是，比如说我们的哈希函数叫H，算出来的 H(X)=H(Y)  ，那么这就叫做哈希碰撞 ，两个不同的输入算出来的哈希值是相等的。  

哈希碰撞是很常见的，像我们使用哈希表的过程中，就会遇到哈希碰撞，不同的输入可能会被映射到哈希表当中的同一个位置，一般来说呢，哈希碰撞是不可避免的，因为输入空间是远远大于输出空间。比如说我们有一个256位的哈希值。    

那输出空间有多大？  
所有哈希值的取值可能就是2的250次方。输出空间就只有这么大。   

但是输入空间可以是无限大的，所以它是有任意多种数的可能性。按照鸽笼原理（Pigeonhole Principle，/ˈpɪdʒənˌhoʊl ˈprɪnsəpl/）的话，必然会出现有两个输入被映射到同一个输出的情况。  

所以我们这里说的collision resistance,并不是说不会出现哈希碰撞。实际上碰撞时客观存在的，他这个意思是说没有什么高效的方法，人为的去制造哈希碰撞。    

就给定一个X，没有什么好办法，你能找到另外一个Y，使得X和Y的哈希值恰好相等，就你没有什么高效的方法去找。  

你硬要找的话，可以用蛮力求解的方法，比如说这个X和这个Y，你就遍历所有输入的可能性，然后看看哪一个算出来它是要相等，尤其这种叫做Brute- force，遍历输的所有可能取值，最后找了一个哈希值差不多类型，  
但是如果这个输入空间比较大，比如说是对于一个哈希值是256位的话，实际上你要用这种方法去找的话，在实际中是不可行的，他工作量实在是太大了。

### **Collision Resistance** 性质的作用：
它可以用来对一个`message`求`digest` ，比如说我们有个`message`叫`m`,我们取他的哈希值`H(m)`,这个哈希值可以认为是这个`message`的`digest`,用来检测对这个`message`的篡改,比如说如果有人改这个`message`内容，它的哈希值就会发生变化，那么collision resistance性质就是说你找不到另外一个`m'`，使得这个`m'`取哈希之后`H(m')`跟原来的哈希值恰好相等。  
是没有办法能够篡改内容而又不被检测出来。  

比如说你有一个很大的文件，你想把它存放到某个云存储服务上，将来你用到的时候再把它下载回来，那么你怎么知道你下载的版本跟你当初上传的版本是一样的？这就可以用到这个哈希函数的** Collision Resistance 性质**，这个在你上传这个文件之前呢，先算一个哈希值出来，这个哈希值呢，存在本地，将来你下载之后呢，再算一个哈希值，因为原来你存的哈希值比较一下，如果是一样的话，那么说明上传的这个文件没有被篡，下载的还是原来那个当初的版本，这就是**Collision Resistance**一个用处。

#### 结论：没有哪个哈希函数,能够在数学上证明是**Collision Resistance**，也就是说我们刚才讲这么重要的一个性质，从理论上是证不出来的，这个只能靠实践中的经验。有些哈希函数经过长期的实践检验，世界上有那么多密码学的专家，谁也没有能够找到人为制造哈希碰撞的方法，所以呢，我们就认为这些哈希函数是肯定**Collision Resistance**，比如实践经验。也有一些哈希函数，以前我们认为是**Collision Resistance**，但是后来大家找到了制造哈希碰撞的方法。

- MD5:曾经是很流行的哈希函数，大家原来以为它很安全，但是现在已经不行了，我们已经知道怎么去人为的制造哈希碰撞。



 **hiding**：  
 
说明：给定一个输入X，可以算出它的哈希值H(X),但是,从那个哈希值H(X)没有办法反推出原来的输入X。就换句话说呢，这个哈希值没有泄露有关这个输入的任何信息。  

如果你想知道这个输入的话，也是有办法。怎么办？还是用那种蛮力的方法，我把这个输入所有可能的取值遍历一遍，看看哪个哈希值跟这个相等，这我就能猜出来原来的数是什么，所以蛮力求解是一种办法。  

**hiding**这个性质成立的前提是，这个输入空间要足够的大，使得这种蛮力求解的方法是不可行的。  
而且呢，这个输入的分布要比较均匀，各种取值的可能性都是差不多的，  
如果这个输入空间虽然是很大，但是呢，绝大多数情况下，取值都是集中在少数几个值，那么也是比较容易被破解的。  

 ### **hiding** 性质的作用：  
 它可以和 **Collision Resistance** 的性质结合在一起，用来实现**digital commitment**（Digital equivalent of a sealed envelope）。  

先说一下现实生活中**sealed envelope**（数字安全领域的加密技术）的作用，比如说有一个人说他能够预测股市，可以预测第二天哪些股票会涨停。那怎么证明这个人预测的是不是准确呢？一种办法是，这人提前一天在电视台上公布预测结果，我预测明天某某股票会涨停。第二天收盘之后呢，看一下这个股票是不是真的涨停，就知道预测准不准。这样做有什么问题吗？这好像是一种检验预测准的方法，有什么问题？如果你预测结果提前公布了，可能会影响股市，就比如说这个人很有名气，大家觉得这是个股神，本来这支股票不会涨停，他这么一公开预测，大家拼命去买，结果它变成了涨停。当然，反方向的情况也可能发生，这支股票也许本来确实是要涨停的，有人想踢场子，你不是预测它涨停吗？我就不让他涨停，拼命的砸盘，这都有可能发生。这说明一个什么道理？预测结果不能够提前公开。但是如果预测结果不提前公开，你等第二天收盘了之后再公开，那你怎么知道这个预测结果有没有被篡改，你最后公开的结果是不是你提前一天做出来的，这个就要用到我们说的**sealed envelope**，叫你把你的一结我写在一张纸上，放到一个信封里给封好了，这个信封要交给第三方的公证机构保管，等第二天收盘之后再把它打开，验证一下这个结果准不准。




### 哈希碰撞的原理

- **鸽巢原理**（或 鸽笼原理）: 假设你有n+1个鸽子和n个鸽巢，如果每个鸽子都要进入一个鸽巢中，那么至少有一个鸽巢里会有两个或以上的鸽子。应用到哈希函数上，由于输入的可能性是无限的，而输出的长度是固定的，因此必然存在至少两个不同的输入被映射到同一个输出。
- **概率和复杂性**: 对于一个理想的哈希函数，任意两个不同的输入碰撞的概率应当非常低。然而，由于上述的鸽巢原理，碰撞是不可避免的。好的哈希函数设计旨在使得找到这样的碰撞变得计算上不可行。（意味着即使使用最强大的现有计算资源，也极其困难（或需要不切实际的长时间）来找到两个不同的输入值，它们通过同一个哈希函数处理后产生相同的输出。）
### 碰撞的影响

在某些应用中，如密码学的散列函数，碰撞可能会带来安全性问题。如果攻击者能够找到两个不同的输入，它们产生相同的哈希值，他们可能会利用这一点来破坏系统的完整性或者伪造数据。

为了减少碰撞的可能性，哈希函数需要满足一定的设计准则和安全性要求。

数字承诺是一种密码学概念，允许发送者提交一条消息，而不泄露消息本身。这类似于将消息封装在一个信封中，信封代表了承诺。这种概念在各种密码学应用中都非常重要，包括数字签名、零知识证明和安全多方计算。

一个承诺方案通常涉及两个主要操作：

- **提交**：发送者提交一条消息，生成一个不泄露消息内容的承诺。
- **验证**：发送者稍后揭示原始消息，验证者可以检查承诺是否对应于消息。

承诺方案必须满足两个关键属性：

- **隐藏**：承诺不泄露任何关于提交消息的信息。这确保了观察者无法仅通过承诺本身推断出消息。
- **绑定**：一旦提交了承诺，发送者就绑定到提交的消息上。如果能够找到一个不同的消息而不被检测到，那么就应该是计算上不可行的。

构建承诺方案的一种常见方式是使用碰撞防御的哈希函数。承诺是通过将消息与一个随机值一起哈希来生成的。这种方法确保了隐藏，因为哈希函数的输出是随机的，不泄露消息。它还提供了绑定，因为如果找到哈希函数的碰撞（即两个不同的消息哈希到相同的值），就会破坏其碰撞防御性，使得计算上不可行的提交到一个不同的消息而不被检测。

例如，使用碰撞防御的哈希函数 `H()` 的一个简单承诺方案可能如下：

- **提交**：生成一个随机值 `r` 并计算承诺 `c = H(r | message)`。
- **验证**：为了验证，验证者检查 `H(r | message) == c`。

这种方案是隐藏的，因为哈希函数的输出是随机的，不泄露消息。它是绑定的，因为如果一个对手能够找到 `H` 的碰撞，他们就能提交一个不同的消息而不被检测，这将破坏哈希函数的碰撞防御性。

总结来说，数字承诺方案是密码学工具，允许发送者提交消息而不泄露消息本身，确保了隐藏和绑定属性。这些方案在各种密码学协议和应用中是基础，提供了一种提交数据而不泄露它的方式，并确保一旦提交了承诺，就不能在不被检测的情况下改变它 [2](https://crypto.stackexchange.com/questions/1173/what-are-preimage-resistance-and-collision-resistance-and-how-can-the-lack-ther)[4](https://blog.daisie.com/collision-resistance-in-hashing-key-principles/)[5](https://link.springer.com/referenceworkentry/10.1007/978-1-4419-5906-5_565)。