# 区块链

**区块链** ：就是一个一个区块组成的链表，每个区块有一个块头`block header`，`block header`里面有很多的阈，其中有一个阈是我们可以设置的随机数`nonce`。  

**挖矿** ：挖矿过程就是在给定的目标空间（target space）和参数（args）信息下，不停的去试各种`nonce`，使得整个`block header`取哈希之后，落在指定的范围之内，小于等于一个`target space`。  
![](Pasted%20image%2020240315215632.png)
![](Pasted%20image%2020240315221853.png)
这个是整个的`output space`（输出空间），我们要求这个算出的哈希值只有落在前面`target space`才是合法的。  

# 比特币 

**BTC 比特币（Bitcoin）**： `Crypto-currency`（加密货币，/ˈkrɪptəʊˌ'kʌrənsi/），BTC 系统目的是提供一种不依赖于中央机构的电子支付系统， 它允许人们通过一个去中心化的网络进行交易，该网络基于一种称为区块链的分布式账本技术，用来处理和记录所有的 `transactions`（交易）。  
用户通过 挖矿 过程来创建新的 BTC 。      

当前的加密货币，是不加密的，区块链上所有的交易内容都是公开的（包括账户的金额、转账的地址都是公开的）。？后面会解答     

**比特币用的哈希函数**叫做`SHA-256`  （Secure Hash Algorithm 256-bit）
`SHA`：Secure Hash Algorithm(安全哈希算法)    

SHA-256算法（一种加密哈希函数）生成的哈希值是固定长度的，为256位（32字节）。

`SHA`拥有3个特质：   
- Collision Resistance
- hiding
- puzzle friendly

比特币中运用到了密码学中的两个功能：   
**Hash（哈希）**  
**Signatures （签名）** /ˈsɪɡnətʃə(r)z/

## Hash
**Hash function  哈希函数**（又称散列函数）：  
是一种 将任意大小的数据（输入） 转换成（映射到）固定长度的输出的函数。    
输出的值被称为散列值（哈希值）。  
     
**密码学中用的哈希函数**被称为：`cryptographic hash functions` 加密哈希函数。/ˌkrɪptəˈɡræfɪk/  
    
### 它用到密码学中两个比较重要的性质：

#### Collision Resistance（/kəˈlɪʒən rɪˈzɪstəns/, 抗碰撞性）：    
这保证了不同的输入会产生不同的哈希值、哈希函数的唯一性。
- **Strong Collision Resistance  （强抗碰撞性）**：很难找到任意两个不同的输入，它们产生相同的输出。 X≠Y, H(X)=H(Y) 
- **Weak Collision Resistance （弱抗碰撞性）**：给定一个固定的输入，很难找到另一个不同的输入，使得两者产生相同的输出。
#### hiding（单向藏匿性）：    
**H(X || nonce)** 加密哈希函数的计算过程是 单向的，不可逆的。  
意味着对于给定的哈希输出，无法确定任何有关输入的信息。确保信息不被恢复或推断。  
X ->H(X)，不能反推

###  除了密码学中的这2个性质之外，比特币中用到的哈希函数还要求有第3个性质`puzzle friendly`(只是日常用于描述特性，不是专业术语）：
#### puzzle friendly （谜题友好性）：  
哈希值的计算事先是不可预测的。你光是看这个输入，你很难猜出来他最后的哈希值是什么。  

### **Collision Resistance** 性质的作用：  

- 在数据传输和存储过程中，**Strong Collision Resistance**性质可以帮助验证数据的完整性。通过比较发送方和接收方计算的哈希值，可以确定数据是否在传输过程中被篡改。

- 在数字签名技术中，**Strong Collision Resistance**性质确保了签名的唯一性和不可篡改性。只有原始消息的发送者才能生成与之对应的唯一签名，而任何对消息的修改都会导致签名的改变。 

- 密码学中，在密码存储中，密码通常不以明文形式存储，而是存储其散列值。**Strong Collision Resistance** 确保即使两个用户选择了相同的密码，它们的散列值也有很大可能性不同，从而增加了系统的安全性。
  例如，密码的哈希值可以用于存储，而不是直接存储密码本身。当用户输入密码时，系统会对输入的密码进行哈希，并与存储的哈希值进行比较，以此验证密码是否正确。

例子：  
它可以用来对一个`message`求`digest` ，比如说我们有个`message`叫`m`,我们取他的哈希值`H(m)`,这个哈希值可以认为是这个`message`的`digest`, 用来检测对这个`message`的篡改,比如说如果有人改这个`message`内容，它的哈希值就会发生变化。  

collision resistance性质就是说你找不到另外一个`m'`，使得这个`m'`取哈希之后`H(m')`跟原来的哈希值恰好相等。也就是说，没有办法能够篡改内容而又不被检测出来。  

### hiding 性质的作用
可以和 **Collision Resistance** 的性质结合在一起，用来实现**digital commitment** 数字承诺（Digital equivalent of a sealed envelope 密封信封的数字等价物）。  

**Collision Resistance** 保证了不同的输入会产生不同的哈希值，而 **hiding** 则保证了即使知道哈希值，也无法反推出原始信息。   

类比预言术：若直接预言明天股票涨停或者跌停且广而告之，可能触发**羊群效应**（herd effect），被玩家做多或者做空。若不将消息透露，则消息不可信，无人见证，触发**薛定谔的玄学力量**。倘若将预言信息 `hash(msg)` 传播出去，等到开盘当天，将msg透露，则用户可以轻松鉴定预言是否正确。

例子：  
先说一下现实生活中**sealed envelope**（数字安全领域的加密技术）的作用，比如说有一个人说他能够预测股市，可以预测第二天哪些股票会涨停。那怎么证明这个人预测的是不是准确呢？一种办法是，这人提前一天在电视台上公布预测结果，我预测明天某某股票会涨停。第二天收盘之后呢，看一下这个股票是不是真的涨停，就知道预测准不准。这样做有什么问题吗？这好像是一种检验预测准的方法，有什么问题？如果你预测结果提前公布了，可能会影响股市，就比如说这个人很有名气，大家觉得这是个股神，本来这支股票不会涨停，他这么一公开预测，大家拼命去买，结果它变成了涨停。当然，反方向的情况也可能发生，这支股票也许本来确实是要涨停的，有人想踢场子，你不是预测它涨停吗？我就不让他涨停，拼命的砸盘，这都有可能发生。这说明一个什么道理？预测结果不能够提前公开。但是如果预测结果不提前公开，你等第二天收盘了之后再公开，那你怎么知道这个预测结果有没有被篡改，你最后公开的结果是不是你提前一天做出来的，这个就要用到我们说的**sealed envelope**，叫你把你的一结果写在一张纸上，放到一个信封里给封好了，这个信封要交给第三方的公证机构保管，等第二天收盘之后再把它打开，验证一下这个结果准不准。

那在电子世界里，我要有一个Digital（"Digital"指的是数字资产或数字化的资产） ，**sealed envelope**怎么实现？  
把这个预测结果作为输入X，算出一个哈希值，然后把这个哈希值可以公布出去，因为我们有这个**hiding** 的性质，所以你从这个哈希值不知道预测结果是什么，然后第二天收盘之后呢，我再把预测结果公布出去，因为有这个**Collision Resistance** 的性质，所以我这个预测结果是不可能篡改的，你要是改的话，就跟当初公布的这个哈希值是对不上。这就起到一个**sealed envelope**的功能。

### puzzle friendly 性质的作用：  
对于 `H(block header) <= target space` 其中BTC的 `block header == args + nonce` 给定target space和 args信息，求nonce

在BTC上的应用就是挖矿，上述求nonce的过程称为挖矿。如果给出一个随机源良好的 message 和一堆目标值 target-space，谜底是找出所有使得 `H(message||nonce)` 满足target-space要求的nonce。找到nonce的过程称为 `Proof of Work` 工作量证明(PoW) 。  

例子：
这种 **puzzle friendly** 的特性使得挖矿过程具有高度的安全性和难度，因为即使知道了目标空间和参数，也很难在短时间内找到正确的nonce。
**puzzle friendly**的性质是说，这个挖矿的过程没有捷径，只能靠不停的去试大量的`nonce`，才能找到符合要求的值，所以这个过程才可以用来作为`Proof of work`工作量证明。  
你挖到矿了，找到符合要求的，那一定是因为你做过大量的工作，没有捷径。   
但是一旦有人找到了这样一个`nonce`，发布出去之后，其他人要验证这个`nonce`是不是符合要求是很容易的，只要算一次哈希值就行了，就这个`nonce`作为`header`的一部分，算一次哈希值，看它是不是小于等于这个目标阈值。  挖矿很难，验证很容易。这个性质叫做: `diffcult to solve,but easy to verify`。一个问题的解决方案可能非常复杂，需要大量的计算资源和时间来找到，但一旦找到了一个解决方案，验证这个解决方案是否正确则相对容易。
![](Pasted%20image%2020240315213853.png)
![](Pasted%20image%2020240315215632.png)

### collision resistance,hiding,puzzle friendly这三个性质成立的前提：
**Collision Resistance**：哈希函数设计得足够复杂  ，输出空间足够大。
哈希函数设计得足够复杂，使得找到这样一对碰撞值在计算上是不可行的。  
此外，输出空间（哈希值的可能取值范围）足够大，以减少碰撞的概率。  

**Hiding**：哈希函数必须是单向的 ，输入空间要足够大且分布均匀， 输出要随机
哈希函数必须是单向的，也就是说，其运算过程不能轻易逆向推导出来。  
此外，哈希函数的输出看起来必须是随机分布的，以确保即使部分输入是已知的，也无法推断出其他部分的信息。    

**Puzzle Friendly**：输出必须均匀且不可预测分布
哈希函数的输出必须均匀且不可预测分布，使得唯一的方法找到满足特定输出条件的输入是通过尝试大量的随机输入直到找到一个匹配。
## Signatures
**BTC** 系统中，每个用户都有一个或多个比特币地址，这些地址是从用户的公钥通过一系列加密算法生成的。  
Bitcoin Address ：可以被视为用户在比特币网络中的身份标识，人们可以使用这个地址来发送或接收比特币。   
，而是使用 `public key,private key` (公钥和私钥)进行管理。  
在**BTC**网络中，“账户”实际上是由一个或多个`public key address`（Bitcoin地址）和相应的`private key`组成。

**Public Key Address (Bitcoin Address)**：从 `Private Key` 派生的，可以是压缩或未压缩的数字字符串（由数字和字母组成的字符串），用于接收 BTC。这个派生过程涉及将私钥与椭圆曲线的基点（G点）相乘。任何人都可以向这个地址发送 BTC，但只有拥有相应私钥的人才能花费这个地址上的 BTC。  

**Private Key**：在 BTC 中 通常是256位的随机数。它是绝对保密的，并用于签名交易以证明资产所有权。私钥需要严格保密，任何人得到了你的私钥就能控制相应地址上的 BTC。

`Private Key` -> `Public Key` 是可逆的， `Public Key` -> `Private Key`  是不可逆的。

1. **进行交易**：当用户想要发送比特币时，他们必须对交易信息进行数字签名，这个过程涉及到用户的私钥。数字签名是用来证明交易发起人拥有发送比特币的权限，而不需要暴露用户的私钥。网络上的其他用户或节点可以使用发起人的公钥来验证签名的有效性。
    
2. **确保安全**：公私钥体系是一种非对称加密技术，私钥用于签名和加密信息，而公钥用于验证签名和解密信息。由于私钥不在网络上传输，它的安全性得以保障。只要用户的私钥没有被泄露，就没有人可以冒充该用户发送比特币。
    
3. **身份验证**：公私钥体系还用于验证交易参与者的身份。通过验证数字签名，可以确保交易的真实性和完整性，防止了重复花费和交易篡改。
    

总结来说，公私钥在比特币系统中起着核心作用，它不仅用于生成比特币地址，还涉及到交易的签名、验证和安全保护。这一体系确保了比特币网络的去中心化特性，同时保障了用户资产的安全。
### 公私钥来源
公私钥用的是`asymetric encryption algorithm` （非对称加密算法），来源于**非对称的加密体系**。    
发送消息时：加密和解密用的是接收方的公钥和私钥。  

交易时：签名用的是私钥，验证签名用的是这个人的公钥，仍然都是同一个人。   

而`symmetric encryption`（对称加密算法），是最早的加密体系。   
 

例子：  
比如说两个人之间要进行通讯。我要把哪个信息发给你，但是这个通讯的网络是有可能被窃听的，那怎么办呢？咱们俩事先商量好一个密钥`encryption key`。我把这个信息加密之后发给你，你收到之后再用这个密钥解密。因为这个加密和解密用的是同一个密钥，所以这个叫做对称的加密体系。  
他这个前提是假设有某种安全的渠道能够把这个密钥分发给通讯的双方，因为你显然不能够说把这个密钥以 **明文（Plaintext）** 的形式在网络上传输。我们假设网络本身就是不安全的，有可能被窃。这个其实是对称加密体系的一个弱点：就是密钥的分发不是很方便。  

而非对称加密，加密用的是公钥，解密用的是私钥，就比如说我要把一个信息传给你，我用你的公钥给这个信息加密，你收到之后呢，再用你的私钥解密，得到原来的信息，注意这个加密和解密用的是同一个人的公钥和私钥，都是这个接收方的公钥和私钥。      

这有什么好处呢？    
这个公钥是不用保密的，加密用的公钥是不用保密的，你可以告诉所有人，私钥是要保密的，因为他的解密是用私钥解密，但是私钥只要保存在本地就行了，不用传给对方，就给你通讯的那个人不需要知道你的私钥，他是用你的公钥加密的，你要回复他的话，你再用他的公钥加密，都不需要知道对方的私钥。这就解决了对称加密体系当中密钥分发不方便的问题。  

我们前面说比特币系统是不加密的，它叫加密货币，它其实是不假，信息都是公开的，那我要这个公钥和私钥干嘛？实际上就是用来做签名。     

比如说我要转10个比特币给你，10个比特币有很多钱，我很慷慨转给你，然后我把这个交易发布到区块链上，别人怎么知道这个交易确实是我发起的，会不会有人冒名顶替，想偷偷的把我的账上的钱转走，这个需要我在发布这个交易的时候，要用我自己的私钥对这个交易签名。那其他收到这个交易之后呢，再用我的公钥去验证这个签名的正确性。  
签名用的是私钥，验证签名用的是这个人的公钥，仍然都是同一个人。  

疑问？  
既然每个人是独立的产生账户，本地独立的生成公司要对不需要任何人批准，那么万一，两个人生成的公司要就恰好相同怎么办？  
就比如说有人想偷取比特币，一种方法是就不停的产生大量的公私钥，然后对比一下我产生的这个公钥跟区块链上某个已有的公钥是不是相同，如果是一样的话呢，就可以用对应的私钥把这个账上的钱给偷走。  
这种攻击方法呢，从理论上说好像是可以的，但是实际当中是不可行的，如果你是256位的哈希值的话，产生相同的公私钥对的可能性是微乎其微的，就即使你有一台超级计算机，别的事情都不干，每天就不停的产生大量的公私钥对，出现两个人的公私钥对相同的概率也是可以忽略不计的，这个概率呢，比地球爆炸的概率还要小，那到目前为止，还没有发现哪个人用这种方法能够攻击成功的先例。    

注意：  
这里假设产生公私钥的时候是有一个好的随机缘，叫做`A good source of randomness`  

生成公私钥的过程显然是随机的，如果不是随机的话，那等于大家都生成同样的公私钥。  
如果你选取的这个随机缘不好的话，那么前面的分析就不成立了。   

比如说就有可能出现两个人的公私钥对生成的是一样。比特币中用的这个签名算法，不光是生成公私钥的时候要有好的随机缘，之后每一次签名的时候也要有好的随机，只要有一次签名的时候用的随机员不好的化，就有可能泄露私钥，然后就全完了。

### FAQs
**什么是哈希函数**？  
散列函数在计算机科学领域通常被称为哈希函数（Hash Function）。哈希函数可以将任意大小的数据（称为“输入”）映射到固定大小的位串（称为“哈希值”或“哈希码”）。哈希函数在数据处理、信息安全、数据检索等多个领域有广泛的应用，例如：

- 在数据结构中，哈希表（Hash Table）使用哈希函数来快速定位一个数据的索引，以便快速检索、插入或删除数据。
- 在加密和信息安全领域，哈希函数用于确保数据的完整性，生成数字签名，以及在不存储明文密码的情况下验证用户密码。
- 在分布式系统中，一致性哈希（Consistent Hashing）使用哈希函数来分配和管理资源，例如在负载均衡和数据分区中。

哈希函数的设计要求其具有几个重要的性质，包括高效的计算、确定性、碰撞阻力、隐匿性和雪崩效应 `snowball effect`（即输入的微小变化会导致输出的显著不同）。  

**哈希碰撞及特点**？  
像我们使用哈希表的过程中，就会遇到哈希碰撞，不同的输入可能会被映射到哈希表当中的同一个位置。
一般来说呢，哈希碰撞是不可避免的，因为输入空间是远远大于输出空间。  

**输出空间有多大**？   
比特币中哈希值的取值可能就是2的256次方，输出空间就只有这么大。  

**输入空间有多大**？  
可以是无限大的，所以它是有任意多种数的可能性。  
按照鸽笼原理（Pigeonhole Principle，/ˈpɪdʒənˌhoʊl ˈprɪnsəpl/）的话，必然会出现有两个输入被映射到同一个输出的情况。

**collision resistance**？  
这里指没有什么高效的方法，人为的去制造哈希碰撞。实际上碰撞是客观存在的。      
硬要找的话，可以用暴力破解`Brute-force`的方法，比如说X和Y，你就遍历所有输入的可能性，然后看看哪一个算出来它是相等的。 但是如果这个输出空间比较大，比如说是对于一个哈希值是256位的话，用这种方法去找，在实际中是不可行的，他工作量实在是太大了。

没有哪个哈希函数,能够在数学上证明是**Collision Resistance**，也就是说从理论上是证不出来的，这个只能靠实践中的经验。有些哈希函数经过长期的实践检验，世界上有那么多密码学的专家，谁也没有能够找到人为制造哈希碰撞的方法，所以呢，我们就认为这些哈希函数是肯定**Collision Resistance**，比如实践经验。也有一些哈希函数，以前我们认为是**Collision Resistance**，但是后来大家找到了制造哈希碰撞的方法

- MD5:曾经是很流行的哈希函数，大家原来以为它很安全，但是现在已经不行了，我们已经知道怎么去人为的制造哈希碰撞。

**哈希值的取值范围**？  
取决于哈希函数的设计和应用场景。一般来说，哈希函数的输出可以是任意大小的数字或字符串，但是在实际应用中，哈希值通常是固定长度的。例如，MD5哈希函数生成的哈希值是128位（16字节）长。    
- **MD5**: 生成128位（16字节）的哈希值。
- **SHA-1**: 生成160位（20字节）的哈希值。
- **SHA-256**: 生成256位（32字节）的哈希值。
- **SHA-512**: 生成512位（64字节）的哈希值。
哈希函数的设计目的：是将任意长度的输入数据映射到固定长度的哈希值上，以便于数据的快速查找和比较。 长度直接影响了哈希函数的安全性和冲突概率。 较长的哈希值通常意味着更高的安全性，因为它更难以通过碰撞攻击找到两个不同的输入数据产生相同的哈希值。

**鸽巢原理** ?  
假设你有n+1个鸽子和n个鸽巢，如果每个鸽子都要进入一个鸽巢中，那么至少有一个鸽巢里会有两个或以上的鸽子。应用到哈希函数上，由于输入的可能性是无限的，而输出的长度是固定的，因此必然存在至少两个不同的输入被映射到同一个输出。  

**薛定谔的玄学力量**？  
可以被理解为量子力学中的一种现象，即系统的状态在被观察之前是不确定的，直到被观察时才确定。  
这种现象在量子力学中被称为“观察者效应”，因为观察者的行为（如测量）会影响系统的状态。  
它结合了著名的量子力学思想实验“薛定谔的猫”和对预言、玄学的讽刺。在这个语境下，如果预言不被公开透露，那么它就像是薛定谔的猫那样，处于一种既不可信也不可否定的状态，没有人能够验证它的真实性。这种状态被戏称为“薛定谔的玄学力量”，意味着预言的真假如同量子态一样，处于一种不确定的、既存在又不存在的状态，直到有人去验证它。

**block header == args + nonce**？
在区块链技术中，用于描述区块头（block header）是由参数（args）和随机数（nonce）组合而成的。  
`args` 通常指的是区块头中的其他数据，如前一个区块的哈希值、时间戳、难度目标等，而 `nonce` 是一个随机数，用于挖矿过程中生成一个满足网络难度要求的哈希值。 `nonce` 是一个32位的随机数，有四十亿种可能的组合。   

**BTC中有没有用到弱抗碰撞性**？
比特币（BTC）的底层技术使用了哈希函数，特别是SHA-256哈希算法。
哈希函数是一种将输入数据（无论大小）转换成固定大小输出的函数，通常用于加密、数据完整性验证等多种场景。在比特币的区块链技术中，SHA-256用于生成交易的哈希值、计算区块的哈希值等。

在哈希函数的上下文中，"碰撞"是指两个不同的输入产生相同的输出。根据抗碰撞性的定义，我们区分为两种类型：

- **弱抗碰撞性**：对于一个给定的输入和它的哈希值，很难找到另一个不同的输入有相同的哈希值。
- **强抗碰撞性**：很难找到任何两个不同的输入，使它们产生相同的哈希值。

比特币在其核心功能中确实依赖于SHA-256哈希函数的强抗碰撞性。这是为了确保区块链的安全性和不可篡改性。弱抗碰撞性在比特币的应用中隐含地被使用，因为强抗碰撞性包含了弱抗碰撞性的特性，因为它不仅适用于给定的消息，而且适用于所有可能的消息对。换言之，如果一个哈希函数像SHA-256那样具有强抗碰撞性，那么它自然也满足弱抗碰撞性的要求。

弱抗碰撞性保护比特币网络不受某些特定类型的攻击，例如尝试创建一个具有相同哈希值的伪造交易。通过确保即使是微小的输入差异也会导致哈希输出的巨大变化，比特币的哈希函数帮助保持了整个系统的安全和完整性。

**BTC 中 `Private Key` 和  `Public Key` 的生成过程及特点** ？
从私钥到公钥的过程是可逆的，因为公钥是通过将私钥与椭圆曲线上的一个基点（G点）相乘得到的。这意味着，如果你知道私钥和椭圆曲线的参数，你可以计算出对应的公钥。然而，从公钥反推出私钥是不可逆的，这是因为这个过程涉及到解决椭圆曲线上的离散对数问题，这是一个困难的数学问题。目前，没有已知的有效算法可以在多项式时间内解决这个问题，这使得从公钥反推出私钥变得非常困难，甚至是不可能的，除非找到了一个新的算法来破解这个问题. 。    

椭圆曲线密码学（Elliptic Curve Cryptography, ECC）是比特币使用的一种密码学方法，它利用椭圆曲线上的点的特性来实现加密和签名。在比特币中，使用的是secp256k1椭圆曲线。私钥是一个随机生成的数字，通过与椭圆曲线上的基点（G点）相乘，可以得到公钥。这个过程是可逆的，因为你可以通过知道私钥和椭圆曲线的参数来计算出公钥。然而，从公钥反推出私钥是不可逆的，因为这涉及到解决椭圆曲线上的离散对数问题，这是一个困难的数学问题。目前，没有已知的有效算法可以在多项式时间内解决这个问题。

**BTC 中生成私钥的随机数 与 nonce 的区别**？
- 生成私钥的随机数通常是 由256位的数字随机生成的数。这个私钥用于对交易进行签名，从而证明比特币的所有权。    
- "nonce"是指在区块链中用于调整区块头的字段，以便产生满足特定条件的哈希值。Nonce值是矿工在工作量证明（Proof of Work）算法中调整的值，以便使得区块头的哈希值满足网络设定的难度目标。
总结：然两者都是随机数，但私钥用于加密和签名，而Nonce值用于调整区块头的哈希值。  

**A good source of randomness**？  
一个好的随机性来源对于确保网络的安全性和去中心化至关重要。随机性主要用于以下几个方面：

1. **挖矿竞争**：比特币网络通过一种名为工作量证明（Proof of Work, PoW）的机制来达成共识。在这个过程中，矿工尝试解决一个难题，这个难题的解决需要大量的计算工作，并且解决方案是不可预测的，因此具有很高的随机性。谁先解决这个难题，谁就可以添加下一个区块到区块链上，并获得相应的比特币奖励。这种随机性确保了没有任何个人或组织可以预先知道下一个矿工会是谁，从而增加了网络的安全性。
    
2. **地址生成**：比特币钱包地址是通过加密算法从用户的私钥生成的。私钥是随机生成的，这保证了每个钱包地址都是独一无二的，并且很难被破解。良好的随机性来源对于私钥的安全性至关重要，因为它确保了没有可预测性，从而提高了资金的安全性。
    
3. **交易的不可预测性**：比特币交易需要在区块链上被确认。交易被打包进区块的顺序和速度部分取决于矿工的挖矿过程，该过程本质上是随机的。这意味着用户无法确切知道他们的交易会在何时被确认，增加了网络的公平性和去中心化程度。
    

为了获得好的随机性来源，比特币系统依赖于加密安全的伪随机数生成器（CSPRNG）。这些生成器设计用于产生看似随机的数据序列，其不能被外部攻击者预测或重现。在实际应用中，开发者和用户应确保使用高质量、经过良好审计的加密库来生成这些密钥和随机数，以维护系统的安全性和完整性。  


## BTC 中的数据结构

### 区块链结构

区块链是由一个个的区块组成的链表  

区块链的指针为 `hash pointer`   区块链的数据被修改，则其后的所有数据都会被影响。  
普通链表指针为 `address pointer`  普通链表节点**数据块**的修改不会影响其他节点。 

`tamper-evident log` **防篡改证明记录**  
解释：区块的节点会记录previous节点的hash值，若previous节点的数据变化，则对该前节点的哈希 `H(previous block)` hash将改变，触发多米诺骨牌效应，后续节点信息都将被改变，所以这种篡改操作是不被允许的。  

完整的节点包含 `block header + block body` 只有 `block header` 的节点称为**轻节点 light node** 。   
包含 `block header + block body` 的称为**全节点 full node**。  

header 中存在主要信息 `node root hash` 该节点的根hash值，而body中存在主要信息**交易记录** 交易记录用 `merkle tree` **默克尔树**存储。**SPV(简化支付验证，Simplified Payment Verification)** 是基于轻节点的钱包设计(称轻钱包) 。   

轻钱包并不保存完整的区块链，而是只保存每一个区块的区块头。区块体保存了完整的交易信息，而交易信息需要的存储量大部分都是交易头的跨数量级倍数以上。所以，如果只保存交易头，就可以极大的减少本地客户端存储的区块链信息。  
### merkle tree  
`merkle tree` 其类似于 `binary tree` 底部叶子节点的 `tx` 属交易记录的 `data blocks`，非叶子节点的value是根据它下面所有的叶子节点值Hash而出，属于 `hash pointers` 需要注意的是顶层的 `merkle root` 不是该区块链节点的 `root hash` 而只是该区块头里的一个字段 `mrkl_root`。  

使用 `merkle tree` 作为交易记录的统计结构，其作用在于提供 `merkle proof / proof of membership / proof of inclusion` **交易记录存在性证明** 通过Merkle路径找到跟该交易相关的区块，并验证对应区块中是否存在目标交易。  

如何通过Merkle找到对应交易的呢？  
缺图
如上图黄色标记tx为待验证的交易记录，我们的SPV需要验证该交易是否合法，过程为:

- Step1：获取黄色标记tx的哈希值，H(父级绿)=Hash(黄色交易tx)
- Step2：通过H(父级绿)和相邻交易H(父级红)的哈希值，得到祖父节点的哈希值：H(祖父绿)=H(H(父级绿)+H(父级红))
- Step3：同上，通过H(祖父绿)和H(祖父红)的哈希值，得到曾祖父级哈希值：H(曾祖父绿)=H(H(祖父绿)+H(祖父红))
- Step4：根节点的哈希值：Merkle Root=Hash(H(曾祖父绿)+H(曾祖父红))
- Step5：然后将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在黄色交易tx，否则说明不存在。

## BTC 的共识协议  
BTC 需要解决的两大难题是:货币发行量+验证交易有效性或称防 `双重支付攻击 double speding attack`  

**纸币和数字货币的区别**：  
对于一个中心化的系统而言，纸币由央行直接发布(无法相信央行?)，**使用时即用即无**，若发行一个基于中心化的数字货币，可能会面临巨大的挑战，比如某用户可能复制多分数字货币进行交易，使用前复刻多分，央行若要处理这个问题，只能维护一个中心化的数据库，控制货币的流入和流出。该中心化的解决方案是目前使用的场景。

去中心化的系统面临的挑战可能主要来源于如何防范双花攻击。  

### 双重支付攻击
![](Pasted%20image%2020240316131959.png)
![](Pasted%20image%2020240316132134.png)
铸币权归矿工持有，通过挖矿产生的交易称为铸币交易。上图链上有两种哈希指针，其中一个用来连接区块组成区块链，一个用来指向每个账户的收入来源。每一笔交易需要发起者签名，表示该交易是被交易发起者同意过的(如图中的 **Sign by A**)。每一笔交易都会进行一次回溯，来验证收入来源是否正确，若发现交易不合法，区块将拒绝接受(**这就是防双花攻击的策略**)。  

在一次 A => B 的交易过程中，A需要知道B的公钥(公钥的哈希进行某些转换后得到账户地址)才能进行转账。B需要知道A什么信息呢？B也需要知道A的公钥信息，其一是B需要用A的公钥验证A的签名**Sign by A**，证明交易来源，其二不单B需要知道A的公钥，所有节点也需要知道A的公钥，用来**共同记账**。  

如何才能知道付款人的公钥信息？  
**付款人的公钥信息由自己给出，每次交易包含输入和输出，其中输入包含币的来源和付款人的公钥，输出包含收款人的公钥哈希**。  

## BTC 共识机制及其他共识机制

比特币网络的共识主要是通过工作量证明（Proof of Work，PoW）机制实现的。PoW要求矿工解决复杂的数学问题来验证交易和创建新的区块，这个过程被称为挖矿。这种机制确保了比特币网络的安全性和去中心化特性，防止了双花攻击，并且确保了所有交易都可以被公开透明地记录在区块链上。

此外，比特币网络还采用了隐性共识机制。当网络中的节点接收到新的区块时，如果收到的新块可能导致链“分叉”（即有两个或更多的链头），节点会选择跟随“最长链”原则。这意味着，节点会选择那个链，其长度最长，因为这个链包含了最多的工作量证明，即最多的算力投入。这种机制确保了网络的稳定性和一致性，避免了分叉导致的网络分裂。

总的来说，比特币网络的共识机制主要依赖于工作量证明（PoW）和隐性共识。

双花攻击是怎么攻击的？  
攻击者可以在网络中广播两个不同的交易，这两个交易都声称花费同一笔数字货币。由于网络中的节点在接收到交易后需要一定的时间来验证交易并将其添加到区块链中，攻击者可以在第一个交易被确认之前广播第二个交易。如果第二个交易先被网络中的大多数节点接受并添加到区块链中，那么第一个交易就会被视为无效，因为它试图花费已经被花费的数字货币。这种攻击方式可以使攻击者在不花费实际资金的情况下获得数字货币，从而破坏区块链的安全性和完整性。
![](Pasted%20image%2020240324151550.png)

![](Pasted%20image%2020240324151150.png)
  
CAP Theorem 是分布式系统的重要定义，他们分别是：`Consistency` 一致性`Availability` 可用性 `Partition tolerance` 分区容错性，这三个指标不可能同时做到。  

**Partition tolerance**(分区容错)：大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。

**Consistency**(一致性)：写操作之后的读操作，必须返回该值

**Availability**(可用性)：只要收到用户的请求，服务器就必须给出回应

BTC是一个分布式的应用，要解决共识问题，当某些节点存在恶意(拜占庭将军问题)时，BTC采用何种机制处理。比特币系统中采用投票的方式超过半数的方式达成共识，而拥有投票权资格的，不是普通的账户，而是拥有记账权的用户，普通账户产生的成本低，此方案会存在**女巫攻击** `Sybil attack` ，采用基于记账权(计算力)的投票，且遵循**最长有效链** `longest valid chain` 的原则，缺省默认按照区块接收时间进行合法认证，但在某个过程中，同时产生了两个区块，指向同一个前驱节点，此时按照最长链原则，将短链抛弃。如果出现了竞争分支，长链胜出，6个确认后交易才被承认。  

缺 `longest valid chain`图  
基于这种分叉的攻击叫做 `forking attack` 叉分攻击，2节点叫做 `orphan block` 孤儿节点。  

![](Pasted%20image%2020240324151432.png)
![](Pasted%20image%2020240324151705.png)
![](Pasted%20image%2020240324151838.png)
![](Pasted%20image%2020240324151912.png)
![](Pasted%20image%2020240324152043.png)
![](Pasted%20image%2020240324152128.png)

### 货币发行  
货币的发行基于争夺记账权产生的铸币交易。找到合法Nonce的节点会获得记账权，同时会获得铸币权的奖励。  

## BTC 系统的实现
比特币系统采用基于交易的账本模式，其全节点会维护一个**UTXO(Unspent Transaction Output)** UTXO是未花费的交易输出，它是比特币交易生成及验证的一个核心概念。交易构成了一组链式结构，所有合法的比特币交易都可以追溯到前向一个或多个交易的输出，这些链条的源头都是挖矿奖励，末尾则是当前未花费的交易输出。

与此区别的是，以太坊ETH采用基于账户的账本模式(account-based ledger)，核心由关系数据库支撑。  

### 挖矿过程的概率分析
挖矿过程中每次尝试nonce的过程都是一次 **Bernoulli trial** 伯努利试验 (a random experiment with binary outcome ，一个具有二元结果的随机实验)，尝试Bernoulli trial的集合构成 **Bernoulli Process** 伯努利过程(a sequence of independent Bernoulli trial ，一个独立的伯努利试验序列) Bernoulli Process 的性质是无记忆性(memoryless) 做大量的试验，前面的实验结果对后面的实验结果没有影响。

实验的次数很多，每次尝试nonce成功的概率很小，其概率可用 **Poisson process** 近似。我们只关心出块时间，**出块时间服从指数分布** (exponential distribution) 整个系统的平均出块时间是10分钟，由于前后试验nonce是无关的，10分钟到达后，依然没有找到nonce，则接下来找到nonce的概率依然是10分钟。这种性质叫**progress free** 如果不按照这种方式，则算力强的矿工会有不成比例的优势。  
## BTC 网络
比特币网络是个去中心化的数字货币系统，依靠全球电脑网络（节点）共同维护。它的交易记录储存在区块链上，这是个公开的账本，让每笔交易都透明且难以篡改。通过一种叫“挖矿”的过程，使用复杂的数学计算来验证交易，同时保护网络安全，并为此劳动奖励比特币。这个系统用密码学确保交易安全，而且交易的隐私通过匿名地址保护。比特币的总量是固定的，最多只有2100万个，这样设计旨在模仿稀缺资源的价值。

限制发行量至2100万个的原因：**防止通货膨胀**，**模仿黄金**，**激励机制**，
保持或增加其长期价值，防止因无限增发而导致的通货膨胀。  
稀缺资源，吸引那些寻找价值存储手段的人  
![](Pasted%20image%2020240324150241.png)
比特币网络是一个基于工作量证明（Proof of Work，PoW）机制的去中心化支付系统。这种机制通过解决复杂的数学问题来验证交易和创建新的区块，这个过程被称为挖矿。这种机制防止了双花攻击，确保了所有交易都可以被公开透明地记录在区块链上。挖矿的人如果成功验证了一组交易，他们就会得到一些比特币作为报酬，这也是新的比特币产生的方式。 

PoW机制的核心是通过算力竞争来确定谁有权创建下一个区块，  
挖矿过程中，矿工需要解决一个难题，这个难题的难度会根据网络的算力动态调整  

因为要篡改区块链的信息或控制整个系统，攻击者必须投入超过整个网络一半的计算能力，这在实际中是非常困难的。  

PoW机制也有其局限性，包括高能耗、确认速度慢、吞吐量低等问题。随着比特币网络算力的增长，比特币挖矿行业的能源消耗已经成为一个全球关注的问题。  

由于PoW机制所设置的问题难度较高，比特币出块时间约在10分钟左右，这意味着一笔交易需要长达1个小时（约6个区块后），才能在区块链网络上真正确认。


比特币的设计原则是简单鲁棒而不是高效(simple，robust，but not efficient)，比特币协议工作在应用层，底层网络层运行P2P Overlay Network，基于此，比特币网络的所有节点都是对等的，无super/master node。若想加入网络，需要在 P2P 节点之间建立随机网络，就是在一个新加入节点和 P2P 网络中的某个节点间随机建立连接通道，从而形成一个随机拓扑结构。新节点与邻居节点建立连接后，还需要进行全网广播，让整个网络知道该节点的存在。全网广播的方式就是，每个节点维护一个邻居节点的集合，该节点首先向邻居节点广播，邻居节点收到广播消息后，再继续向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播方法也称为**泛洪机制flooding**。  
![](Pasted%20image%2020240324145650.png)

## BTC 的挖矿难度调整
![](Pasted%20image%2020240316165906.png)
![](Pasted%20image%2020240316170034.png)
挖矿过程符合 `H(block header) <= target` target越大，挖矿越容易。调整挖矿难度实际为调整目标空间在输出空间实际所占的比例。比特币用的哈希算法为SHA-256，故输出空间实际有2^256的取值。挖矿难度与目标阈值成反比：`difficulty=difficulty_1_target/target` 挖矿难度最小为1，target越大，难度越小。挖矿难度需要不断调整，否则随着算力的增加，出块的速度会一直加快，导致分叉(攻击)的可能性也越大。  
![](Pasted%20image%2020240324152259.png)
## 调整挖矿难度
2个星期调整一次    
![](Pasted%20image%2020240316170819.png)
具体怎么调整     
![](Pasted%20image%2020240316170842.png)
![](Pasted%20image%2020240316170925.png)
BTC系统每产生2016个区块就需要调整一次难度 `(2016*10)/(60*24) = 14 Day`。难度调整公式符合 `target = target * (actual time/expected time)` **actual time** 是挖2016个区块实际用时，**expected time** 是理想状况下产生2016个区块用时(2016 * 10)  

![](Pasted%20image%2020240316171756.png)
这里算的是目标阈值  
## 分叉
由于同时出块，对当前区块链的状态产生分歧，导致的分叉，叫做`state fork` （状态分叉）。  
由于分叉攻击导致的分叉`forking attack` （分叉攻击） 也是`state fork`，这种人为的分叉叫做`deliberate fork`（人为分叉）。  
由于比特币协议发生变化，而比特币是一个分布式去中心化的系统，不能同时都升级软件而导致的分叉叫做`protocol fork`（协议分叉）。   
根据协议修改内容的不同，可以分成`hard fork`和`soft fork`。    

`hard fork` 由于对比特币协议添加一些新特性，扩展新功能而导致的分叉，就是硬分叉。旧节点不认新节点，新节点认旧节点。  

`soft fork` 对区块链协议进行一些限制，导致原本合法的区块变得不合法。新节点发布，旧节点认，旧节点发布新节点不认，导致旧节点称为孤儿节点。

# ETC

## 概括

memory hard 、 mining puzzle、ASIC resistance、POW和POS它们之间的联系是什么？  
  
这些术语都与区块链和加密货币的共识机制相关，每个都扮演着重要的角色。让我们分别来看看它们以及它们之间的联系：

1. **工作量证明（Proof of Work, POW）**：POW是一种共识机制，用于在没有中央权威的情况下，通过网络中的节点达成共识。它要求参与者解决一个计算上复杂的问题（挖矿难题），以验证交易并创建新的区块。成功解决问题的参与者（矿工）会获得新创建的加密货币作为奖励。比特币就是采用POW机制的一个著名例子。
    
2. **权益证明（Proof of Stake, POS）**：与POW不同，POS不依赖于解决复杂计算问题来达成共识。在POS中，区块的创建者是根据他们持有的货币数量和持有时间来选出的。这意味着，持有更多货币的人有更大的机会创建下一个区块并获得奖励。POS被认为比POW更为环保，因为它消耗的能量要少得多。
    
3. **内存困难（Memory Hard）**：这是一种设计特点，指的是解决某些加密挑战（比如POW挖矿难题）需要大量的内存资源。内存困难的挖矿算法旨在使ASIC（专用集成电路）挖矿不那么经济高效，因为这些算法需要大量的内存带宽，而不仅仅是处理能力。
    
4. **挖矿难题（Mining Puzzle）**：在POW系统中，挖矿难题是一种计算难题，矿工必须解决它才能将新区块加入到区块链中。这个难题的设计旨在控制新区块生成的速度，并确保网络的安全性。
    
5. **ASIC抗性（ASIC Resistance）**：ASIC抗性是指一种加密货币的挖矿算法设计成对专用硬件（如ASIC矿机）不那么敏感，使得使用标准计算设备（如家用电脑）的矿工也能竞争性地参与挖矿。这种设计旨在保持网络的去中心化特性，防止挖矿过度集中在少数拥有高效专用硬件的矿工手中。
    

**它们之间的联系**：

- **POW和挖矿难题**紧密相关，因为POW依赖于解决挖矿难题来验证交易和生成新区块。
- **内存困难**和**ASIC抗性**通常在设计POW挖矿算法时考虑，以鼓励更广泛的参与并防止挖矿集中化。
- **POS**作为一种不同于POW的共识机制，旨在解决POW中的能源消耗和潜在的集中化问题。

每种机制和特性都旨在提高区块链网络的安全性、去中心化程度和/或能效。   

smart contract 
![](Pasted%20image%2020240331113300.png)
![](Pasted%20image%2020240331113322.png)

![](Pasted%20image%2020240331113420.png)

![](Pasted%20image%2020240331113626.png)

![](Pasted%20image%2020240331114006.png)
![](Pasted%20image%2020240331114202.png)

![](Pasted%20image%2020240331114044.png)
![](Pasted%20image%2020240331114140.png)
可以防御double spending attack

BTC每笔交易都会说明来源，
那ETH,account-based ledger （ 基于账户模，指的是以太坊区块链上的账户账本系统）这个模型的缺点？
![](Pasted%20image%2020240331114356.png)

![](Pasted%20image%2020240331114655.png)
![](Pasted%20image%2020240331114716.png)
![](Pasted%20image%2020240331114727.png)
![](Pasted%20image%2020240331114745.png)
![](Pasted%20image%2020240331114755.png)

![](Pasted%20image%2020240331114815.png)
状态树  ：![](Pasted%20image%2020240331114840.png)

![](Pasted%20image%2020240331114906.png)
![](Pasted%20image%2020240331114917.png)
![](Pasted%20image%2020240331114937.png)
![](Pasted%20image%2020240331114945.png)
![](Pasted%20image%2020240331114959.png)

![](Pasted%20image%2020240331115019.png)
![](Pasted%20image%2020240331115031.png)
replay attack
![](Pasted%20image%2020240331115126.png)
意思是：A->B (10ETH) , A广播一次, B再广播一次，又扣了A一次钱  

![](Pasted%20image%2020240331115252.png)
![](Pasted%20image%2020240331115436.png)
![](Pasted%20image%2020240331115501.png)
![](Pasted%20image%2020240331115513.png)
![](Pasted%20image%2020240331115639.png)
不可能，因为有资金来源，太明显了，给你转账，你重放一遍，很明显就能看出double spending，就不会成功  

ETH 加一个计数器：nonce
![](Pasted%20image%2020240331120728.png)
转账的时候  
![](Pasted%20image%2020240331120830.png)
收到签名的保护
![](Pasted%20image%2020240331121015.png)
nonce别人改不了

![](Pasted%20image%2020240331121106.png)
![](Pasted%20image%2020240331121118.png)
还要维护nonce的值  

nonce一开始是0，在新账户新创立的时候  
![](Pasted%20image%2020240331122809.png)
nonce值加1  

比如：![](Pasted%20image%2020240331122905.png)
nonce=20
节点发现![](Pasted%20image%2020240331123002.png)，合法的  
![](Pasted%20image%2020240331123026.png)
同时要更新一下：  
nonce=21  
以后如果有人重放这个交易  
![](Pasted%20image%2020240331123154.png)
当前的nonce已经是21了  
![](Pasted%20image%2020240331123224.png)
就不会再执行一遍了     

总结：  
以太坊的账户账本系统是基于状态转换的，这意味着每个交易都会改变账户的状态，例如转移以太币或代币，或者执行智能合约。这些状态转换被记录在区块链上，形成了一个不可篡改的公共账本。

以太坊的账户账本系统支持多种类型的账户，包括外部拥有的账户（Externally Owned Accounts, EOAs）和合约账户（Smart Contract Accounts）。外部拥有的账户由私钥控制，而合约账户由其代码和存储状态控制。合约账户可以执行复杂的逻辑，包括智能合约，这使得以太坊能够支持去中心化应用（DApps）。  

![](Pasted%20image%2020240331123356.png)

一个合约可以调动另一个合约 ，通过nonce值记录调用次数  
![](Pasted%20image%2020240331125445.png)
以太坊规定：
![](Pasted%20image%2020240331125511.png)
![](Pasted%20image%2020240331125545.png)
![](Pasted%20image%2020240331125554.png)
![](Pasted%20image%2020240331125603.png)
![](Pasted%20image%2020240331125621.png)
这可以，但是不能自己发起一个交易  

合约账户有代码code，以及相关的状态storage ，包括每个变量取值  
![](Pasted%20image%2020240331125811.png)

合约怎么调用？  
![](Pasted%20image%2020240331125855.png)
![](Pasted%20image%2020240331125903.png)
![](Pasted%20image%2020240331125911.png)
![](Pasted%20image%2020240331125926.png)
![](Pasted%20image%2020240331125939.png)
![](Pasted%20image%2020240331125951.png)
![](Pasted%20image%2020240331130002.png)

![](Pasted%20image%2020240331130025.png)
![](Pasted%20image%2020240331130044.png)

以太坊创始人![](Pasted%20image%2020240331130111.png)
19岁  


BTC![](Pasted%20image%2020240331130227.png)
![](Pasted%20image%2020240331130237.png)
![](Pasted%20image%2020240331130245.png)

![](Pasted%20image%2020240331130308.png)
![](Pasted%20image%2020240331130318.png)

![](Pasted%20image%2020240331130332.png)
![](Pasted%20image%2020240331130340.png)
跟日常生活中的签合同类似，你跟它签合同，你得找到这个人 ，不然会给合同执行带来困难  ，出现纠纷的时候也可以知道合同是跟谁签的  

![](Pasted%20image%2020240331130607.png)
![](Pasted%20image%2020240331130641.png)


## 以太坊的数据结构-状态树

![](Pasted%20image%2020240331131047.png)
![](Pasted%20image%2020240331131112.png)account-based ledger  

![](Pasted%20image%2020240331131251.png)
![](Pasted%20image%2020240331131259.png)
![](Pasted%20image%2020240331131319.png)

![](Pasted%20image%2020240331131326.png)
![](Pasted%20image%2020240331131402.png)
![](Pasted%20image%2020240331131411.png)
![](Pasted%20image%2020240331131424.png)
![](Pasted%20image%2020240331131500.png)

![](Pasted%20image%2020240331131526.png)
![](Pasted%20image%2020240331131533.png)
前者包括余额balance，交易次数nonce
后者代码code，存储storage  

![](Pasted%20image%2020240331131748.png)![](Pasted%20image%2020240331131814.png)
![](Pasted%20image%2020240331131826.png)
![](Pasted%20image%2020240331131837.png)
![](Pasted%20image%2020240331131857.png)
![](Pasted%20image%2020240331131912.png)
有新的账户就插入到哈希表里面  
你要查询账户的余额，就直接在哈希表中查询  
如果不考虑哈希碰撞的话
![](Pasted%20image%2020240331132051.png)
![](Pasted%20image%2020240331132059.png)
但是，这种设计  

![](Pasted%20image%2020240331132245.png)
![](Pasted%20image%2020240331132253.png)
怎么提供？

![](Pasted%20image%2020240331132332.png)
![](Pasted%20image%2020240331132342.png)
![](Pasted%20image%2020240331132359.png)
![](Pasted%20image%2020240331132410.png)
![](Pasted%20image%2020240331132448.png)
Merkle tree，![](Pasted%20image%2020240331132548.png)，![](Pasted%20image%2020240331132559.png)
公布出去 ，跟比特币一样  
![](Pasted%20image%2020240331132639.png)
![](Pasted%20image%2020240331132645.png)
![](Pasted%20image%2020240331132654.png)
那如果
![](Pasted%20image%2020240331132824.png)
新区块有新的交易，我们要执行这个交易
![](Pasted%20image%2020240331132901.png)
![](Pasted%20image%2020240331132910.png)
![](Pasted%20image%2020240331132931.png)
merkle tree吗？这个代价太大了  
![](Pasted%20image%2020240331133017.png)
![](Pasted%20image%2020240331133029.png)
![](Pasted%20image%2020240331133049.png)
代价太大  

![](Pasted%20image%2020240331133116.png)你也要构造一个merkle tree吗？那么为什么每这个问题？
BTC是把区块中的交易组成一个merkle tree，区块中的交易
![](Pasted%20image%2020240331133314.png)
![](Pasted%20image%2020240331133322.png)
所以BTC中的merkle tree是
![](Pasted%20image%2020240331133359.png)
![](Pasted%20image%2020240331133406.png)
对应一颗merkle tree，然后这个merkle tree构建完之后不会更改 ，下次再发布一个新的区块，再构建一个新的merkle tree。   

![](Pasted%20image%2020240331133607.png) ？
![](Pasted%20image%2020240331133645.png)
![](Pasted%20image%2020240331133631.png)
![](Pasted%20image%2020240331133707.png)
![](Pasted%20image%2020240331133743.png)
![](Pasted%20image%2020240331133751.png)
4000已经是上限了  

如果以太坊采用这种方法会出现什么情况？  
![](Pasted%20image%2020240331134003.png)
merkle tree  
![](Pasted%20image%2020240331134027.png)
![](Pasted%20image%2020240331134035.png)
![](Pasted%20image%2020240331134043.png)
![](Pasted%20image%2020240331134052.png)
构建出一个merkle tree ，  
![](Pasted%20image%2020240331134115.png)
![](Pasted%20image%2020240331134128.png)遍历一遍
除了提供merkle proof![](Pasted%20image%2020240331134210.png)

merkle tree
![](Pasted%20image%2020240331134245.png)
![](Pasted%20image%2020240331134325.png)
![](Pasted%20image%2020240331134338.png)
每个节点就是再内部本地维护一个数据结构  
![](Pasted%20image%2020240331134716.png)
![](Pasted%20image%2020240331134726.png)
![](Pasted%20image%2020240331134737.png)
![](Pasted%20image%2020240331134831.png)块头的一个原因
对于当前这个区块包含哪些交易，所有的全节点要有一个共识  
![](Pasted%20image%2020240331135009.png)
然后构建merkle tree时，根哈希值放在区块头里，这个方法是不行的  
![](Pasted%20image%2020240331135711.png)
![](Pasted%20image%2020240331135727.png)
效率都很好
但是每次去构建merkle tree代价太大   


![](Pasted%20image%2020240331135937.png)
不要哈希表了  
直接就用一颗merkle tree  
![](Pasted%20image%2020240331140016.png)
![](Pasted%20image%2020240331140033.png)merkle tree  里改  
![](Pasted%20image%2020240331140105.png)
![](Pasted%20image%2020240331140127.png)merkle tree里的一小部分  
这个方法行吗？  
![](Pasted%20image%2020240331140227.png)
merkle tree
![](Pasted%20image%2020240331140239.png)

BTC中的merkle tree是怎么构建的？
最低下一层是 transactions，然后哈希值放到上面的节点里，两两结合，然后再取个哈希往上传，



想想ETH的数据结构是怎么设计出来的？  


