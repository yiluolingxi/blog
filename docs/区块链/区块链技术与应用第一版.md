# 区块链

**区块链** ：就是一个一个区块组成的链表，每个区块有一个块头`block header`，`block header`里面有很多的阈，其中有一个阈是我们可以设置的随机数`nonce`。  

**挖矿** ：挖矿过程就是在给定的目标空间（target space）和参数（args）信息下，不停的去试各种`nonce`，使得整个`block header`取哈希之后，落在指定的范围之内，小于等于一个`target space`。  
![](Pasted%20image%2020240315215632.png)
![](Pasted%20image%2020240315221853.png)
这个是整个的`output space`（输出空间），我们要求这个算出的哈希值只有落在前面`target space`才是合法的。  

# 比特币 

**BTC 比特币（Bitcoin）**： `Crypto-currency`（加密货币，/ˈkrɪptəʊˌ'kʌrənsi/），BTC 系统目的是提供一种不依赖于中央机构的电子支付系统， 它允许人们通过一个去中心化的网络进行交易，该网络基于一种称为区块链的分布式账本技术，用来处理和记录所有的 `transactions`（交易）。  
用户通过 挖矿 过程来创建新的 BTC 。      

当前的加密货币，是不加密的，区块链上所有的交易内容都是公开的（包括账户的金额、转账的地址都是公开的）。？后面会解答     

**比特币用的哈希函数**叫做`SHA-256`  （Secure Hash Algorithm 256-bit）
`SHA`：Secure Hash Algorithm(安全哈希算法)    

SHA-256算法（一种加密哈希函数）生成的哈希值是固定长度的，为256位（32字节）。

`SHA`拥有3个特质：   
- Collision Resistance
- hiding
- puzzle friendly

比特币中运用到了密码学中的两个功能：   
**Hash（哈希）**  
**Signatures （签名）** /ˈsɪɡnətʃə(r)z/

## Hash
**Hash function  哈希函数**（又称散列函数）：  
是一种 将任意大小的数据（输入） 转换成（映射到）固定长度的输出的函数。    
输出的值被称为散列值（哈希值）。  
     
**密码学中用的哈希函数**被称为：`cryptographic hash functions` 加密哈希函数。/ˌkrɪptəˈɡræfɪk/  
    
### 它用到密码学中两个比较重要的性质：

#### Collision Resistance（/kəˈlɪʒən rɪˈzɪstəns/, 抗碰撞性）：    
这保证了不同的输入会产生不同的哈希值、哈希函数的唯一性。
- **Strong Collision Resistance  （强抗碰撞性）**：很难找到任意两个不同的输入，它们产生相同的输出。 X≠Y, H(X)=H(Y) 
- **Weak Collision Resistance （弱抗碰撞性）**：给定一个固定的输入，很难找到另一个不同的输入，使得两者产生相同的输出。
#### hiding（单向藏匿性）：    
**H(X || nonce)** 加密哈希函数的计算过程是 单向的，不可逆的。  
意味着对于给定的哈希输出，无法确定任何有关输入的信息。确保信息不被恢复或推断。  
X ->H(X)，不能反推

###  除了密码学中的这2个性质之外，比特币中用到的哈希函数还要求有第3个性质`puzzle friendly`(只是日常用于描述特性，不是专业术语）：
#### puzzle friendly （谜题友好性）：  
哈希值的计算事先是不可预测的。你光是看这个输入，你很难猜出来他最后的哈希值是什么。  

### **Collision Resistance** 性质的作用：  

- 在数据传输和存储过程中，**Strong Collision Resistance**性质可以帮助验证数据的完整性。通过比较发送方和接收方计算的哈希值，可以确定数据是否在传输过程中被篡改。

- 在数字签名技术中，**Strong Collision Resistance**性质确保了签名的唯一性和不可篡改性。只有原始消息的发送者才能生成与之对应的唯一签名，而任何对消息的修改都会导致签名的改变。 

- 密码学中，在密码存储中，密码通常不以明文形式存储，而是存储其散列值。**Strong Collision Resistance** 确保即使两个用户选择了相同的密码，它们的散列值也有很大可能性不同，从而增加了系统的安全性。
  例如，密码的哈希值可以用于存储，而不是直接存储密码本身。当用户输入密码时，系统会对输入的密码进行哈希，并与存储的哈希值进行比较，以此验证密码是否正确。

例子：  
它可以用来对一个`message`求`digest` ，比如说我们有个`message`叫`m`,我们取他的哈希值`H(m)`,这个哈希值可以认为是这个`message`的`digest`, 用来检测对这个`message`的篡改,比如说如果有人改这个`message`内容，它的哈希值就会发生变化。  

collision resistance性质就是说你找不到另外一个`m'`，使得这个`m'`取哈希之后`H(m')`跟原来的哈希值恰好相等。也就是说，没有办法能够篡改内容而又不被检测出来。  

### hiding 性质的作用
可以和 **Collision Resistance** 的性质结合在一起，用来实现**digital commitment** 数字承诺（Digital equivalent of a sealed envelope 密封信封的数字等价物）。  

**Collision Resistance** 保证了不同的输入会产生不同的哈希值，而 **hiding** 则保证了即使知道哈希值，也无法反推出原始信息。   

类比预言术：若直接预言明天股票涨停或者跌停且广而告之，可能触发**羊群效应**（herd effect），被玩家做多或者做空。若不将消息透露，则消息不可信，无人见证，触发**薛定谔的玄学力量**。倘若将预言信息 `hash(msg)` 传播出去，等到开盘当天，将msg透露，则用户可以轻松鉴定预言是否正确。

例子：  
先说一下现实生活中**sealed envelope**（数字安全领域的加密技术）的作用，比如说有一个人说他能够预测股市，可以预测第二天哪些股票会涨停。那怎么证明这个人预测的是不是准确呢？一种办法是，这人提前一天在电视台上公布预测结果，我预测明天某某股票会涨停。第二天收盘之后呢，看一下这个股票是不是真的涨停，就知道预测准不准。这样做有什么问题吗？这好像是一种检验预测准的方法，有什么问题？如果你预测结果提前公布了，可能会影响股市，就比如说这个人很有名气，大家觉得这是个股神，本来这支股票不会涨停，他这么一公开预测，大家拼命去买，结果它变成了涨停。当然，反方向的情况也可能发生，这支股票也许本来确实是要涨停的，有人想踢场子，你不是预测它涨停吗？我就不让他涨停，拼命的砸盘，这都有可能发生。这说明一个什么道理？预测结果不能够提前公开。但是如果预测结果不提前公开，你等第二天收盘了之后再公开，那你怎么知道这个预测结果有没有被篡改，你最后公开的结果是不是你提前一天做出来的，这个就要用到我们说的**sealed envelope**，叫你把你的一结果写在一张纸上，放到一个信封里给封好了，这个信封要交给第三方的公证机构保管，等第二天收盘之后再把它打开，验证一下这个结果准不准。

那在电子世界里，我要有一个Digital（"Digital"指的是数字资产或数字化的资产） ，**sealed envelope**怎么实现？  
把这个预测结果作为输入X，算出一个哈希值，然后把这个哈希值可以公布出去，因为我们有这个**hiding** 的性质，所以你从这个哈希值不知道预测结果是什么，然后第二天收盘之后呢，我再把预测结果公布出去，因为有这个**Collision Resistance** 的性质，所以我这个预测结果是不可能篡改的，你要是改的话，就跟当初公布的这个哈希值是对不上。这就起到一个**sealed envelope**的功能。

### puzzle friendly 性质的作用：  
对于 `H(block header) <= target space` 其中BTC的 `block header == args + nonce` 给定target space和 args信息，求nonce

在BTC上的应用就是挖矿，上述求nonce的过程称为挖矿。如果给出一个随机源良好的 message 和一堆目标值 target-space，谜底是找出所有使得 `H(message||nonce)` 满足target-space要求的nonce。找到nonce的过程称为 `Proof of Work` 工作量证明(PoW) 。  

例子：
这种 **puzzle friendly** 的特性使得挖矿过程具有高度的安全性和难度，因为即使知道了目标空间和参数，也很难在短时间内找到正确的nonce。
**puzzle friendly**的性质是说，这个挖矿的过程没有捷径，只能靠不停的去试大量的`nonce`，才能找到符合要求的值，所以这个过程才可以用来作为`Proof of work`工作量证明。  
你挖到矿了，找到符合要求的，那一定是因为你做过大量的工作，没有捷径。   
但是一旦有人找到了这样一个`nonce`，发布出去之后，其他人要验证这个`nonce`是不是符合要求是很容易的，只要算一次哈希值就行了，就这个`nonce`作为`header`的一部分，算一次哈希值，看它是不是小于等于这个目标阈值。  挖矿很难，验证很容易。这个性质叫做: `diffcult to solve,but easy to verify`。一个问题的解决方案可能非常复杂，需要大量的计算资源和时间来找到，但一旦找到了一个解决方案，验证这个解决方案是否正确则相对容易。
![](Pasted%20image%2020240315213853.png)
![](Pasted%20image%2020240315215632.png)

### collision resistance,hiding,puzzle friendly这三个性质成立的前提：
**Collision Resistance**：哈希函数设计得足够复杂  ，输出空间足够大。
哈希函数设计得足够复杂，使得找到这样一对碰撞值在计算上是不可行的。  
此外，输出空间（哈希值的可能取值范围）足够大，以减少碰撞的概率。  

**Hiding**：哈希函数必须是单向的 ，输入空间要足够大且分布均匀， 输出要随机
哈希函数必须是单向的，也就是说，其运算过程不能轻易逆向推导出来。  
此外，哈希函数的输出看起来必须是随机分布的，以确保即使部分输入是已知的，也无法推断出其他部分的信息。    

**Puzzle Friendly**：输出必须均匀且不可预测分布
哈希函数的输出必须均匀且不可预测分布，使得唯一的方法找到满足特定输出条件的输入是通过尝试大量的随机输入直到找到一个匹配。
## Signatures
**BTC** 系统中，每个用户都有一个或多个比特币地址，这些地址是从用户的公钥通过一系列加密算法生成的。  
Bitcoin Address ：可以被视为用户在比特币网络中的身份标识，人们可以使用这个地址来发送或接收比特币。   
，而是使用 `public key,private key` (公钥和私钥)进行管理。  
在**BTC**网络中，“账户”实际上是由一个或多个`public key address`（Bitcoin地址）和相应的`private key`组成。

**Public Key Address (Bitcoin Address)**：从 `Private Key` 派生的，可以是压缩或未压缩的数字字符串（由数字和字母组成的字符串），用于接收 BTC。这个派生过程涉及将私钥与椭圆曲线的基点（G点）相乘。任何人都可以向这个地址发送 BTC，但只有拥有相应私钥的人才能花费这个地址上的 BTC。  

**Private Key**：在 BTC 中 通常是256位的随机数。它是绝对保密的，并用于签名交易以证明资产所有权。私钥需要严格保密，任何人得到了你的私钥就能控制相应地址上的 BTC。

`Private Key` -> `Public Key` 是可逆的， `Public Key` -> `Private Key`  是不可逆的。

1. **进行交易**：当用户想要发送比特币时，他们必须对交易信息进行数字签名，这个过程涉及到用户的私钥。数字签名是用来证明交易发起人拥有发送比特币的权限，而不需要暴露用户的私钥。网络上的其他用户或节点可以使用发起人的公钥来验证签名的有效性。
    
2. **确保安全**：公私钥体系是一种非对称加密技术，私钥用于签名和加密信息，而公钥用于验证签名和解密信息。由于私钥不在网络上传输，它的安全性得以保障。只要用户的私钥没有被泄露，就没有人可以冒充该用户发送比特币。
    
3. **身份验证**：公私钥体系还用于验证交易参与者的身份。通过验证数字签名，可以确保交易的真实性和完整性，防止了重复花费和交易篡改。
    

总结来说，公私钥在比特币系统中起着核心作用，它不仅用于生成比特币地址，还涉及到交易的签名、验证和安全保护。这一体系确保了比特币网络的去中心化特性，同时保障了用户资产的安全。
### 公私钥来源
公私钥用的是`asymetric encryption algorithm` （非对称加密算法），来源于**非对称的加密体系**。    
发送消息时：加密和解密用的是接收方的公钥和私钥。  

交易时：签名用的是私钥，验证签名用的是这个人的公钥，仍然都是同一个人。   

而`symmetric encryption`（对称加密算法），是最早的加密体系。   
 

例子：  
比如说两个人之间要进行通讯。我要把哪个信息发给你，但是这个通讯的网络是有可能被窃听的，那怎么办呢？咱们俩事先商量好一个密钥`encryption key`。我把这个信息加密之后发给你，你收到之后再用这个密钥解密。因为这个加密和解密用的是同一个密钥，所以这个叫做对称的加密体系。  
他这个前提是假设有某种安全的渠道能够把这个密钥分发给通讯的双方，因为你显然不能够说把这个密钥以 **明文（Plaintext）** 的形式在网络上传输。我们假设网络本身就是不安全的，有可能被窃。这个其实是对称加密体系的一个弱点：就是密钥的分发不是很方便。  

而非对称加密，加密用的是公钥，解密用的是私钥，就比如说我要把一个信息传给你，我用你的公钥给这个信息加密，你收到之后呢，再用你的私钥解密，得到原来的信息，注意这个加密和解密用的是同一个人的公钥和私钥，都是这个接收方的公钥和私钥。      

这有什么好处呢？    
这个公钥是不用保密的，加密用的公钥是不用保密的，你可以告诉所有人，私钥是要保密的，因为他的解密是用私钥解密，但是私钥只要保存在本地就行了，不用传给对方，就给你通讯的那个人不需要知道你的私钥，他是用你的公钥加密的，你要回复他的话，你再用他的公钥加密，都不需要知道对方的私钥。这就解决了对称加密体系当中密钥分发不方便的问题。  

我们前面说比特币系统是不加密的，它叫加密货币，它其实是不假，信息都是公开的，那我要这个公钥和私钥干嘛？实际上就是用来做签名。     

比如说我要转10个比特币给你，10个比特币有很多钱，我很慷慨转给你，然后我把这个交易发布到区块链上，别人怎么知道这个交易确实是我发起的，会不会有人冒名顶替，想偷偷的把我的账上的钱转走，这个需要我在发布这个交易的时候，要用我自己的私钥对这个交易签名。那其他收到这个交易之后呢，再用我的公钥去验证这个签名的正确性。  
签名用的是私钥，验证签名用的是这个人的公钥，仍然都是同一个人。  

疑问？  
既然每个人是独立的产生账户，本地独立的生成公司要对不需要任何人批准，那么万一，两个人生成的公司要就恰好相同怎么办？  
就比如说有人想偷取比特币，一种方法是就不停的产生大量的公私钥，然后对比一下我产生的这个公钥跟区块链上某个已有的公钥是不是相同，如果是一样的话呢，就可以用对应的私钥把这个账上的钱给偷走。  
这种攻击方法呢，从理论上说好像是可以的，但是实际当中是不可行的，如果你是256位的哈希值的话，产生相同的公私钥对的可能性是微乎其微的，就即使你有一台超级计算机，别的事情都不干，每天就不停的产生大量的公私钥对，出现两个人的公私钥对相同的概率也是可以忽略不计的，这个概率呢，比地球爆炸的概率还要小，那到目前为止，还没有发现哪个人用这种方法能够攻击成功的先例。    

注意：  
这里假设产生公私钥的时候是有一个好的随机缘，叫做`A good source of randomness`  

生成公私钥的过程显然是随机的，如果不是随机的话，那等于大家都生成同样的公私钥。  
如果你选取的这个随机缘不好的话，那么前面的分析就不成立了。   

比如说就有可能出现两个人的公私钥对生成的是一样。比特币中用的这个签名算法，不光是生成公私钥的时候要有好的随机缘，之后每一次签名的时候也要有好的随机，只要有一次签名的时候用的随机员不好的化，就有可能泄露私钥，然后就全完了。

### FAQs
**什么是哈希函数**？  
散列函数在计算机科学领域通常被称为哈希函数（Hash Function）。哈希函数可以将任意大小的数据（称为“输入”）映射到固定大小的位串（称为“哈希值”或“哈希码”）。哈希函数在数据处理、信息安全、数据检索等多个领域有广泛的应用，例如：

- 在数据结构中，哈希表（Hash Table）使用哈希函数来快速定位一个数据的索引，以便快速检索、插入或删除数据。
- 在加密和信息安全领域，哈希函数用于确保数据的完整性，生成数字签名，以及在不存储明文密码的情况下验证用户密码。
- 在分布式系统中，一致性哈希（Consistent Hashing）使用哈希函数来分配和管理资源，例如在负载均衡和数据分区中。

哈希函数的设计要求其具有几个重要的性质，包括高效的计算、确定性、碰撞阻力、隐匿性和雪崩效应 `snowball effect`（即输入的微小变化会导致输出的显著不同）。  

**哈希碰撞及特点**？  
像我们使用哈希表的过程中，就会遇到哈希碰撞，不同的输入可能会被映射到哈希表当中的同一个位置。
一般来说呢，哈希碰撞是不可避免的，因为输入空间是远远大于输出空间。  

**输出空间有多大**？   
比特币中哈希值的取值可能就是2的256次方，输出空间就只有这么大。  

**输入空间有多大**？  
可以是无限大的，所以它是有任意多种数的可能性。  
按照鸽笼原理（Pigeonhole Principle，/ˈpɪdʒənˌhoʊl ˈprɪnsəpl/）的话，必然会出现有两个输入被映射到同一个输出的情况。

**collision resistance**？  
这里指没有什么高效的方法，人为的去制造哈希碰撞。实际上碰撞是客观存在的。      
硬要找的话，可以用暴力破解`Brute-force`的方法，比如说X和Y，你就遍历所有输入的可能性，然后看看哪一个算出来它是相等的。 但是如果这个输出空间比较大，比如说是对于一个哈希值是256位的话，用这种方法去找，在实际中是不可行的，他工作量实在是太大了。

没有哪个哈希函数,能够在数学上证明是**Collision Resistance**，也就是说从理论上是证不出来的，这个只能靠实践中的经验。有些哈希函数经过长期的实践检验，世界上有那么多密码学的专家，谁也没有能够找到人为制造哈希碰撞的方法，所以呢，我们就认为这些哈希函数是肯定**Collision Resistance**，比如实践经验。也有一些哈希函数，以前我们认为是**Collision Resistance**，但是后来大家找到了制造哈希碰撞的方法

- MD5:曾经是很流行的哈希函数，大家原来以为它很安全，但是现在已经不行了，我们已经知道怎么去人为的制造哈希碰撞。

**哈希值的取值范围**？  
取决于哈希函数的设计和应用场景。一般来说，哈希函数的输出可以是任意大小的数字或字符串，但是在实际应用中，哈希值通常是固定长度的。例如，MD5哈希函数生成的哈希值是128位（16字节）长。    
- **MD5**: 生成128位（16字节）的哈希值。
- **SHA-1**: 生成160位（20字节）的哈希值。
- **SHA-256**: 生成256位（32字节）的哈希值。
- **SHA-512**: 生成512位（64字节）的哈希值。
哈希函数的设计目的：是将任意长度的输入数据映射到固定长度的哈希值上，以便于数据的快速查找和比较。 长度直接影响了哈希函数的安全性和冲突概率。 较长的哈希值通常意味着更高的安全性，因为它更难以通过碰撞攻击找到两个不同的输入数据产生相同的哈希值。

**鸽巢原理** ?  
假设你有n+1个鸽子和n个鸽巢，如果每个鸽子都要进入一个鸽巢中，那么至少有一个鸽巢里会有两个或以上的鸽子。应用到哈希函数上，由于输入的可能性是无限的，而输出的长度是固定的，因此必然存在至少两个不同的输入被映射到同一个输出。  

**薛定谔的玄学力量**？  
可以被理解为量子力学中的一种现象，即系统的状态在被观察之前是不确定的，直到被观察时才确定。  
这种现象在量子力学中被称为“观察者效应”，因为观察者的行为（如测量）会影响系统的状态。  
它结合了著名的量子力学思想实验“薛定谔的猫”和对预言、玄学的讽刺。在这个语境下，如果预言不被公开透露，那么它就像是薛定谔的猫那样，处于一种既不可信也不可否定的状态，没有人能够验证它的真实性。这种状态被戏称为“薛定谔的玄学力量”，意味着预言的真假如同量子态一样，处于一种不确定的、既存在又不存在的状态，直到有人去验证它。

**block header == args + nonce**？
在区块链技术中，用于描述区块头（block header）是由参数（args）和随机数（nonce）组合而成的。  
`args` 通常指的是区块头中的其他数据，如前一个区块的哈希值、时间戳、难度目标等，而 `nonce` 是一个随机数，用于挖矿过程中生成一个满足网络难度要求的哈希值。 `nonce` 是一个32位的随机数，有四十亿种可能的组合。   

**BTC中有没有用到弱抗碰撞性**？
比特币（BTC）的底层技术使用了哈希函数，特别是SHA-256哈希算法。
哈希函数是一种将输入数据（无论大小）转换成固定大小输出的函数，通常用于加密、数据完整性验证等多种场景。在比特币的区块链技术中，SHA-256用于生成交易的哈希值、计算区块的哈希值等。

在哈希函数的上下文中，"碰撞"是指两个不同的输入产生相同的输出。根据抗碰撞性的定义，我们区分为两种类型：

- **弱抗碰撞性**：对于一个给定的输入和它的哈希值，很难找到另一个不同的输入有相同的哈希值。
- **强抗碰撞性**：很难找到任何两个不同的输入，使它们产生相同的哈希值。

比特币在其核心功能中确实依赖于SHA-256哈希函数的强抗碰撞性。这是为了确保区块链的安全性和不可篡改性。弱抗碰撞性在比特币的应用中隐含地被使用，因为强抗碰撞性包含了弱抗碰撞性的特性，因为它不仅适用于给定的消息，而且适用于所有可能的消息对。换言之，如果一个哈希函数像SHA-256那样具有强抗碰撞性，那么它自然也满足弱抗碰撞性的要求。

弱抗碰撞性保护比特币网络不受某些特定类型的攻击，例如尝试创建一个具有相同哈希值的伪造交易。通过确保即使是微小的输入差异也会导致哈希输出的巨大变化，比特币的哈希函数帮助保持了整个系统的安全和完整性。

**BTC 中 `Private Key` 和  `Public Key` 的生成过程及特点** ？
从私钥到公钥的过程是可逆的，因为公钥是通过将私钥与椭圆曲线上的一个基点（G点）相乘得到的。这意味着，如果你知道私钥和椭圆曲线的参数，你可以计算出对应的公钥。然而，从公钥反推出私钥是不可逆的，这是因为这个过程涉及到解决椭圆曲线上的离散对数问题，这是一个困难的数学问题。目前，没有已知的有效算法可以在多项式时间内解决这个问题，这使得从公钥反推出私钥变得非常困难，甚至是不可能的，除非找到了一个新的算法来破解这个问题. 。    

椭圆曲线密码学（Elliptic Curve Cryptography, ECC）是比特币使用的一种密码学方法，它利用椭圆曲线上的点的特性来实现加密和签名。在比特币中，使用的是secp256k1椭圆曲线。私钥是一个随机生成的数字，通过与椭圆曲线上的基点（G点）相乘，可以得到公钥。这个过程是可逆的，因为你可以通过知道私钥和椭圆曲线的参数来计算出公钥。然而，从公钥反推出私钥是不可逆的，因为这涉及到解决椭圆曲线上的离散对数问题，这是一个困难的数学问题。目前，没有已知的有效算法可以在多项式时间内解决这个问题。

**BTC 中生成私钥的随机数 与 nonce 的区别**？
- 生成私钥的随机数通常是 由256位的数字随机生成的数。这个私钥用于对交易进行签名，从而证明比特币的所有权。    
- "nonce"是指在区块链中用于调整区块头的字段，以便产生满足特定条件的哈希值。Nonce值是矿工在工作量证明（Proof of Work）算法中调整的值，以便使得区块头的哈希值满足网络设定的难度目标。
总结：然两者都是随机数，但私钥用于加密和签名，而Nonce值用于调整区块头的哈希值。  

**A good source of randomness**？  
一个好的随机性来源对于确保网络的安全性和去中心化至关重要。随机性主要用于以下几个方面：

1. **挖矿竞争**：比特币网络通过一种名为工作量证明（Proof of Work, PoW）的机制来达成共识。在这个过程中，矿工尝试解决一个难题，这个难题的解决需要大量的计算工作，并且解决方案是不可预测的，因此具有很高的随机性。谁先解决这个难题，谁就可以添加下一个区块到区块链上，并获得相应的比特币奖励。这种随机性确保了没有任何个人或组织可以预先知道下一个矿工会是谁，从而增加了网络的安全性。
    
2. **地址生成**：比特币钱包地址是通过加密算法从用户的私钥生成的。私钥是随机生成的，这保证了每个钱包地址都是独一无二的，并且很难被破解。良好的随机性来源对于私钥的安全性至关重要，因为它确保了没有可预测性，从而提高了资金的安全性。
    
3. **交易的不可预测性**：比特币交易需要在区块链上被确认。交易被打包进区块的顺序和速度部分取决于矿工的挖矿过程，该过程本质上是随机的。这意味着用户无法确切知道他们的交易会在何时被确认，增加了网络的公平性和去中心化程度。
    

为了获得好的随机性来源，比特币系统依赖于加密安全的伪随机数生成器（CSPRNG）。这些生成器设计用于产生看似随机的数据序列，其不能被外部攻击者预测或重现。在实际应用中，开发者和用户应确保使用高质量、经过良好审计的加密库来生成这些密钥和随机数，以维护系统的安全性和完整性。  


## BTC 中的数据结构

### 区块链结构

区块链是由一个个的区块组成的链表  

区块链的指针为 `hash pointer`   区块链的数据被修改，则其后的所有数据都会被影响。  
普通链表指针为 `address pointer`  普通链表节点**数据块**的修改不会影响其他节点。 

`tamper-evident log` **防篡改证明记录**  
解释：区块的节点会记录previous节点的hash值，若previous节点的数据变化，则对该前节点的哈希 `H(previous block)` hash将改变，触发多米诺骨牌效应，后续节点信息都将被改变，所以这种篡改操作是不被允许的。  

完整的节点包含 `block header + block body` 只有 `block header` 的节点称为**轻节点 light node** 。   
包含 `block header + block body` 的称为**全节点 full node**。  

header 中存在主要信息 `node root hash` 该节点的根hash值，而body中存在主要信息**交易记录** 交易记录用 `merkle tree` **默克尔树**存储。**SPV(简化支付验证，Simplified Payment Verification)** 是基于轻节点的钱包设计(称轻钱包) 。   

轻钱包并不保存完整的区块链，而是只保存每一个区块的区块头。区块体保存了完整的交易信息，而交易信息需要的存储量大部分都是交易头的跨数量级倍数以上。所以，如果只保存交易头，就可以极大的减少本地客户端存储的区块链信息。  

  
比特币（BTC）的区块链结构中，每个区块的最前面的部分称为区块头（Block Header）。区块头包含了一些关键的信息，而不是全部的交易数据。这些信息包括：

1. **版本号**（Version）：用于跟踪区块链协议的更新和变化。
2. **前一个区块的哈希值**（Previous Block Hash）：这是前一个区块的唯一标识，用于连接每个区块，形成区块链的链式结构。
3. **Merkle树根哈希**（Merkle Root）：这是该区块中所有交易的Merkle树的根节点哈希值，用于快速和有效地验证区块中所有交易的完整性。
4. **时间戳**（Timestamp）：记录区块产生的大致时间。
5. **难度目标**（Bits）：当前网络难度的指标，用于保持比特币生成新区块的平均时间。
6. **随机数**（Nonce）：矿工通过调整这个值来解决区块的工作量证明（Proof of Work）算法，从而合法地添加新区块到区块链上。

区块头是区块链中非常关键的组成部分，它使得在不需要下载整个区块链的情况下验证数据的完整性成为可能。这种设计特别适用于轻客户端（Lightweight clients），它们只需保留区块头的信息就可以验证交易，而无需下载整个区块链的所有交易数据。
### merkle tree  
比特币（BTC）中的Merkle树是一种数据结构，用于高效且安全地总结和验证区块链网络中的大量交易数据。在一个比特币区块中，所有的交易被组织成一个Merkle树（也称为哈希树）来帮助确保数据的完整性。下面是Merkle树构建的基本过程：

1. **准备交易列表**：首先，取出区块中的所有交易。
    
2. **计算交易哈希**：对区块中的每一笔交易分别进行哈希运算。比特币采用SHA-256哈希算法，因此每个交易哈希是一个256位的数字。
    
3. **构建Merkle树**：
    
    - 如果交易的数量是奇数，复制最后一个交易的哈希，使得交易数量变为偶数。
    - 将这些交易哈希两两配对，然后对每对交易哈希值进行拼接（串联），再对拼接后的字符串进行一次SHA-256哈希运算。这样得到的新哈希值被称为父节点哈希。
    - 对所有生成的父节点哈希重复上述过程，每次迭代会把哈希数量减半，直至最顶层只剩下一个哈希值。这个顶层哈希值称为Merkle根（或根哈希）。
4. **Merkle根**：最终，整个Merkle树会被缩减为一个单一的哈希值，即Merkle根。这个Merkle根是区块头的一部分，用于代表区块中所有交易的完整性和唯一性。
    

Merkle树的优势在于它提供了一种高效的方式来验证区块链中的交易数据是否未被篡改。如果区块中的任何一笔交易被修改，那么通过Merkle树算法，最顶层的Merkle根哈希值也会改变，因此可以迅速检测到数据的任何篡改。此外，Merkle树还使得在不下载整个区块的情况下验证单个交易成为可能，这对于轻量级比特币客户端（如SPV客户端）尤其重要。

比特币交易是不可逆的。一旦比特币网络确认了一笔交易，这笔交易就被永久地记录在区块链上，无法被修改或撤销。这是因为区块链技术的设计初衷之一就是提供一个开放、透明、不可篡改的交易账本。

`merkle tree` 其类似于 `binary tree` 底部叶子节点的 `tx` 属交易记录的 `data blocks`，非叶子节点的value是根据它下面所有的叶子节点值Hash而出，属于 `hash pointers` 需要注意的是顶层的 `merkle root` 不是该区块链节点的 `root hash` 而只是该区块头里的一个字段 `mrkl_root`。  

使用 `merkle tree` 作为交易记录的统计结构，其作用在于提供 `merkle proof / proof of membership / proof of inclusion` **交易记录存在性证明** 通过Merkle路径找到跟该交易相关的区块，并验证对应区块中是否存在目标交易。  

如何通过Merkle找到对应交易的呢？  
缺图
如上图黄色标记tx为待验证的交易记录，我们的SPV需要验证该交易是否合法，过程为:

- Step1：获取黄色标记tx的哈希值，H(父级绿)=Hash(黄色交易tx)
- Step2：通过H(父级绿)和相邻交易H(父级红)的哈希值，得到祖父节点的哈希值：H(祖父绿)=H(H(父级绿)+H(父级红))
- Step3：同上，通过H(祖父绿)和H(祖父红)的哈希值，得到曾祖父级哈希值：H(曾祖父绿)=H(H(祖父绿)+H(祖父红))
- Step4：根节点的哈希值：Merkle Root=Hash(H(曾祖父绿)+H(曾祖父红))
- Step5：然后将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在黄色交易tx，否则说明不存在。

比特币中，节点是怎么运行的？  
比特币网络由一系列分布式节点组成，这些节点在全球范围内运行，共同支持比特币区块链的运作。节点主要分为几种类型，包括全节点、轻节点、矿工节点等，它们在网络中扮演不同的角色，确保交易的处理、验证和记录。下面是比特币中节点运行的一些关键方面：

### 全节点

- **数据验证**：全节点下载并保存区块链的完整副本，验证所有新的交易和区块，确保它们遵循比特币的规则。这包括验证交易签名、确认交易不是双重支付，以及确保区块大小和时间戳的正确性。
- **数据转发**：全节点接收到新的交易和区块后，会将这些信息转发给网络中的其他节点，帮助保持网络的同步和信息的快速传播。
- **隐私和安全**：运行全节点可以增强用户的隐私和安全。用户可以通过自己的节点验证交易，而不必信赖第三方服务。

### 轻节点

- **数据简化**：轻节点不下载区块链的完整副本，而是只下载区块头来验证交易的有效性。这使得轻节点需要较少的存储空间和带宽，适合运行在资源有限的设备上，如手机或小型服务器。
- **依赖全节点**：轻节点依赖全节点提供所需的区块链信息，包括相关的区块和交易数据，以验证交易。

### 矿工节点

- **交易打包**：矿工节点收集未确认的交易，将它们打包成一个新的区块。
- **工作量证明**：矿工通过解决一个复杂的数学难题（工作量证明算法）来竞争区块的创建权。成功的矿工可以将新区块添加到区块链中，并获得新比特币作为奖励。
- **网络安全**：矿工的工作量证明不仅用于发行新币，也是保护网络免受攻击的一种机制。攻击者需要控制超过网络总计算力的50%才能成功篡改区块链信息。

### 网络同步

- 所有类型的节点都会参与到网络的数据同步中，确保每个节点都持有最新的区块链信息。这是通过节点间不断的数据交换来实现的，包括新的交易和区块信息。

比特币的去中心化特性主要得益于其节点的分布式和自治运行方式。每个参与者都可以按照自己的需要选择运行何种类型的节点，共同维护比特币网络的健康和安全。

以下是比特币节点运行的基本概述：

1. **区块链的验证和维护**：每个节点都保存有比特币的完整交易历史记录，即区块链的一个完整副本。节点通过检查和验证交易及区块来维护网络的安全和一致性。当一个新的区块被挖出来时，它会被广播到网络中的其他节点。接收到新区块的节点会验证该区块的有效性，包括其中的所有交易。验证通过后，节点将新区块添加到其本地的区块链副本中。
    
2. **交易的广播和验证**：当用户发起一个比特币交易时，该交易首先被发送到网络中的节点。节点在将交易转发给网络中的其他节点之前，会对其进行初步的验证，包括检查交易签名的有效性和确保交易输入没有被双重支出。
    
3. **挖矿**：一些节点还参与到比特币的挖矿过程中，这是一种通过解决复杂计算问题来竞争创建新区块的过程。成功创建新区块的节点（矿工）会得到新比特币作为奖励，并且能够收集到该区块中所有交易的手续费。
    
4. **网络的去中心化和抗审查**：比特币的节点遍布全球，任何人都可以运行一个节点。这种去中心化的结构保证了比特币网络不受单一实体的控制，增加了网络的抗审查能力。
    
5. **轻节点和全节点**：不是所有的节点都保存有区块链的完整副本。所谓的“轻节点”只下载区块链的一部分数据（通常是区块头），以减少资源消耗。轻节点依赖于全节点来获取交易数据和验证交易。
    
6. **网络服务**：节点还为网络提供其他服务，例如提供交易历史数据给轻节点，或者帮助新节点同步区块链数据。
## BTC 的共识协议  
BTC 需要解决的两大难题是:货币发行量+验证交易有效性或称防 `双重支付攻击 double speding attack`  

**纸币和数字货币的区别**：  
对于一个中心化的系统而言，纸币由央行直接发布(无法相信央行?)，**使用时即用即无**，若发行一个基于中心化的数字货币，可能会面临巨大的挑战，比如某用户可能复制多分数字货币进行交易，使用前复刻多分，央行若要处理这个问题，只能维护一个中心化的数据库，控制货币的流入和流出。该中心化的解决方案是目前使用的场景。

去中心化的系统面临的挑战可能主要来源于如何防范双花攻击。  

### 双重支付攻击
![](Pasted%20image%2020240316131959.png)
![](Pasted%20image%2020240316132134.png)
铸币权归矿工持有，通过挖矿产生的交易称为铸币交易。上图链上有两种哈希指针，其中一个用来连接区块组成区块链，一个用来指向每个账户的收入来源。每一笔交易需要发起者签名，表示该交易是被交易发起者同意过的(如图中的 **Sign by A**)。每一笔交易都会进行一次回溯，来验证收入来源是否正确，若发现交易不合法，区块将拒绝接受(**这就是防双花攻击的策略**)。  

在一次 A => B 的交易过程中，A需要知道B的公钥(公钥的哈希进行某些转换后得到账户地址)才能进行转账。B需要知道A什么信息呢？B也需要知道A的公钥信息，其一是B需要用A的公钥验证A的签名**Sign by A**，证明交易来源，其二不单B需要知道A的公钥，所有节点也需要知道A的公钥，用来**共同记账**。  

如何才能知道付款人的公钥信息？  
**付款人的公钥信息由自己给出，每次交易包含输入和输出，其中输入包含币的来源和付款人的公钥，输出包含收款人的公钥哈希**。  

## BTC 共识机制及其他共识机制

比特币网络的共识主要是通过工作量证明（Proof of Work，PoW）机制实现的。PoW要求矿工解决复杂的数学问题来验证交易和创建新的区块，这个过程被称为挖矿。这种机制确保了比特币网络的安全性和去中心化特性，防止了双花攻击，并且确保了所有交易都可以被公开透明地记录在区块链上。

此外，比特币网络还采用了隐性共识机制。当网络中的节点接收到新的区块时，如果收到的新块可能导致链“分叉”（即有两个或更多的链头），节点会选择跟随“最长链”原则。这意味着，节点会选择那个链，其长度最长，因为这个链包含了最多的工作量证明，即最多的算力投入。这种机制确保了网络的稳定性和一致性，避免了分叉导致的网络分裂。

总的来说，比特币网络的共识机制主要依赖于工作量证明（PoW）和隐性共识。

双花攻击是怎么攻击的？  
攻击者可以在网络中广播两个不同的交易，这两个交易都声称花费同一笔数字货币。由于网络中的节点在接收到交易后需要一定的时间来验证交易并将其添加到区块链中，攻击者可以在第一个交易被确认之前广播第二个交易。如果第二个交易先被网络中的大多数节点接受并添加到区块链中，那么第一个交易就会被视为无效，因为它试图花费已经被花费的数字货币。这种攻击方式可以使攻击者在不花费实际资金的情况下获得数字货币，从而破坏区块链的安全性和完整性。
![](Pasted%20image%2020240324151550.png)

![](Pasted%20image%2020240324151150.png)
  
CAP Theorem 是分布式系统的重要定义，他们分别是：`Consistency` 一致性`Availability` 可用性 `Partition tolerance` 分区容错性，这三个指标不可能同时做到。  

**Partition tolerance**(分区容错)：大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。

**Consistency**(一致性)：写操作之后的读操作，必须返回该值

**Availability**(可用性)：只要收到用户的请求，服务器就必须给出回应

BTC是一个分布式的应用，要解决共识问题，当某些节点存在恶意(拜占庭将军问题)时，BTC采用何种机制处理。比特币系统中采用投票的方式超过半数的方式达成共识，而拥有投票权资格的，不是普通的账户，而是拥有记账权的用户，普通账户产生的成本低，此方案会存在**女巫攻击** `Sybil attack` ，采用基于记账权(计算力)的投票，且遵循**最长有效链** `longest valid chain` 的原则，缺省默认按照区块接收时间进行合法认证，但在某个过程中，同时产生了两个区块，指向同一个前驱节点，此时按照最长链原则，将短链抛弃。如果出现了竞争分支，长链胜出，6个确认后交易才被承认。  

缺 `longest valid chain`图  
基于这种分叉的攻击叫做 `forking attack` 叉分攻击，2节点叫做 `orphan block` 孤儿节点。  

![](Pasted%20image%2020240324151432.png)
![](Pasted%20image%2020240324151705.png)
![](Pasted%20image%2020240324151838.png)
![](Pasted%20image%2020240324151912.png)
![](Pasted%20image%2020240324152043.png)
![](Pasted%20image%2020240324152128.png)

### 货币发行  
货币的发行基于争夺记账权产生的铸币交易。找到合法Nonce的节点会获得记账权，同时会获得铸币权的奖励。  

## BTC 系统的实现
比特币系统采用基于交易的账本模式，其全节点会维护一个**UTXO(Unspent Transaction Output)** UTXO是未花费的交易输出，它是比特币交易生成及验证的一个核心概念。交易构成了一组链式结构，所有合法的比特币交易都可以追溯到前向一个或多个交易的输出，这些链条的源头都是挖矿奖励，末尾则是当前未花费的交易输出。

与此区别的是，以太坊ETH采用基于账户的账本模式(account-based ledger)，核心由关系数据库支撑。  

### 挖矿过程的概率分析
挖矿过程中每次尝试nonce的过程都是一次 **Bernoulli trial** 伯努利试验 (a random experiment with binary outcome ，一个具有二元结果的随机实验)，尝试Bernoulli trial的集合构成 **Bernoulli Process** 伯努利过程(a sequence of independent Bernoulli trial ，一个独立的伯努利试验序列) Bernoulli Process 的性质是无记忆性(memoryless) 做大量的试验，前面的实验结果对后面的实验结果没有影响。

实验的次数很多，每次尝试nonce成功的概率很小，其概率可用 **Poisson process** 近似。我们只关心出块时间，**出块时间服从指数分布** (exponential distribution) 整个系统的平均出块时间是10分钟，由于前后试验nonce是无关的，10分钟到达后，依然没有找到nonce，则接下来找到nonce的概率依然是10分钟。这种性质叫**progress free** 如果不按照这种方式，则算力强的矿工会有不成比例的优势。  
## BTC 网络
比特币网络是个去中心化的数字货币系统，依靠全球电脑网络（节点）共同维护。它的交易记录储存在区块链上，这是个公开的账本，让每笔交易都透明且难以篡改。通过一种叫“挖矿”的过程，使用复杂的数学计算来验证交易，同时保护网络安全，并为此劳动奖励比特币。这个系统用密码学确保交易安全，而且交易的隐私通过匿名地址保护。比特币的总量是固定的，最多只有2100万个，这样设计旨在模仿稀缺资源的价值。

限制发行量至2100万个的原因：**防止通货膨胀**，**模仿黄金**，**激励机制**，
保持或增加其长期价值，防止因无限增发而导致的通货膨胀。  
稀缺资源，吸引那些寻找价值存储手段的人  
![](Pasted%20image%2020240324150241.png)
比特币网络是一个基于工作量证明（Proof of Work，PoW）机制的去中心化支付系统。这种机制通过解决复杂的数学问题来验证交易和创建新的区块，这个过程被称为挖矿。这种机制防止了双花攻击，确保了所有交易都可以被公开透明地记录在区块链上。挖矿的人如果成功验证了一组交易，他们就会得到一些比特币作为报酬，这也是新的比特币产生的方式。 

PoW机制的核心是通过算力竞争来确定谁有权创建下一个区块，  
挖矿过程中，矿工需要解决一个难题，这个难题的难度会根据网络的算力动态调整  

因为要篡改区块链的信息或控制整个系统，攻击者必须投入超过整个网络一半的计算能力，这在实际中是非常困难的。  

PoW机制也有其局限性，包括高能耗、确认速度慢、吞吐量低等问题。随着比特币网络算力的增长，比特币挖矿行业的能源消耗已经成为一个全球关注的问题。  

由于PoW机制所设置的问题难度较高，比特币出块时间约在10分钟左右，这意味着一笔交易需要长达1个小时（约6个区块后），才能在区块链网络上真正确认。


比特币的设计原则是简单鲁棒而不是高效(simple，robust，but not efficient)，比特币协议工作在应用层，底层网络层运行P2P Overlay Network，基于此，比特币网络的所有节点都是对等的，无super/master node。若想加入网络，需要在 P2P 节点之间建立随机网络，就是在一个新加入节点和 P2P 网络中的某个节点间随机建立连接通道，从而形成一个随机拓扑结构。新节点与邻居节点建立连接后，还需要进行全网广播，让整个网络知道该节点的存在。全网广播的方式就是，每个节点维护一个邻居节点的集合，该节点首先向邻居节点广播，邻居节点收到广播消息后，再继续向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播方法也称为**泛洪机制flooding**。  
![](Pasted%20image%2020240324145650.png)

## BTC 的挖矿难度调整
![](Pasted%20image%2020240316165906.png)
![](Pasted%20image%2020240316170034.png)
挖矿过程符合 `H(block header) <= target` target越大，挖矿越容易。调整挖矿难度实际为调整目标空间在输出空间实际所占的比例。比特币用的哈希算法为SHA-256，故输出空间实际有2^256的取值。挖矿难度与目标阈值成反比：`difficulty=difficulty_1_target/target` 挖矿难度最小为1，target越大，难度越小。挖矿难度需要不断调整，否则随着算力的增加，出块的速度会一直加快，导致分叉(攻击)的可能性也越大。  
![](Pasted%20image%2020240324152259.png)
## 调整挖矿难度
2个星期调整一次    
![](Pasted%20image%2020240316170819.png)
具体怎么调整     
![](Pasted%20image%2020240316170842.png)
![](Pasted%20image%2020240316170925.png)
BTC系统每产生2016个区块就需要调整一次难度 `(2016*10)/(60*24) = 14 Day`。难度调整公式符合 `target = target * (actual time/expected time)` **actual time** 是挖2016个区块实际用时，**expected time** 是理想状况下产生2016个区块用时(2016 * 10)  

![](Pasted%20image%2020240316171756.png)
这里算的是目标阈值  
## 分叉
由于同时出块，对当前区块链的状态产生分歧，导致的分叉，叫做`state fork` （状态分叉）。  
由于分叉攻击导致的分叉`forking attack` （分叉攻击） 也是`state fork`，这种人为的分叉叫做`deliberate fork`（人为分叉）。  
由于比特币协议发生变化，而比特币是一个分布式去中心化的系统，不能同时都升级软件而导致的分叉叫做`protocol fork`（协议分叉）。   
根据协议修改内容的不同，可以分成`hard fork`和`soft fork`。    

`hard fork` 由于对比特币协议添加一些新特性，扩展新功能而导致的分叉，就是硬分叉。旧节点不认新节点，新节点认旧节点。  

`soft fork` 对区块链协议进行一些限制，导致原本合法的区块变得不合法。新节点发布，旧节点认，旧节点发布新节点不认，导致旧节点称为孤儿节点。
  
重放攻击和双花攻击是两种不同的安全威胁，它们在区块链和加密货币系统中尤为突出。虽然它们看起来可能有相似之处，但它们的目的、前提条件和影响是不同的。

### 重放攻击的前提

重放攻击的主要前提是攻击者能够成功捕获到有效的数据传输（如交易指令、认证信息等），并且能够在没有适当防御机制的情况下重新发送（重放）这些数据。对于区块链来说，这通常涉及到以下几点：

- **网络通信的可监听性**：攻击者需要能监听到网络中的交易或数据传输。
- **缺乏防重放保护**：如果系统不对每笔交易进行唯一标记（如通过时间戳、序列号等），或者不验证这些标记，则可能容易受到重放攻击。
- **跨链操作的脆弱性**：在涉及多条链的操作中，比如在不同区块链之间进行资产转移时，如果这些链之间的交互没有正确实现重放保护，重放攻击可能会发生。

重放攻击不一定仅限于同一条链上。在跨链交易和操作中，没有适当防御机制的系统也可能遭受重放攻击，其中一条链上的有效交易被重放到另一条链上。

### 双花攻击

双花攻击是一种特定于加密货币和区块链的攻击，其目的是让攻击者能够花费同一笔资金两次。这通常涉及到攻击者在网络中同时广播两笔交易，试图欺骗系统或者其他用户，使得同一笔资金被认为在两处同时有效。

  
双花攻击（Double Spending Attack）是指在数字货币或某些数字交易系统中，恶意攻击者尝试将同一笔资金（或资产）同时支付给两个或多个不同的接收者的行为。这种攻击利用了数字信息可被复制的特性，尝试欺骗系统或接收方，让他们认为同一笔资金已经被有效支付多次。

双花攻击的前提和可能性取决于被攻击系统的具体机制和安全措施。对于不同的系统，可能需要不同的条件才能成功执行双花攻击，但以下是一些常见的前提条件：

1. **确认时间和机制的利用**：在某些系统中，交易需要一定时间才能得到最终确认。攻击者可能会在这个窗口期内尝试将同一笔资金支付给多个接收者。
    
2. **网络控制和延迟**：如果攻击者能够控制足够多的网络资源（例如，在区块链网络中控制足够多的算力或有足够的网络影响力），他们可能能够延迟特定交易的传播或确认，从而增加双花攻击的成功率。
    
3. **交易可逆性**：在一些系统中，交易在一定条件下是可逆的。如果攻击者能够在交易被最终确认前利用这一点，他们就可能实施双花攻击。
    
4. **系统的安全漏洞**：如果数字货币系统或交易机制存在安全漏洞，攻击者可能会利用这些漏洞发起双花攻击。
    
5. **51%攻击**：特别是在基于区块链的系统中，如果攻击者能够控制超过50%的网络算力，他们就能够阻止其他节点的交易被确认，同时推进自己的交易，从而实施双花攻击。
    

防止双花攻击通常需要综合的安全措施，包括加强网络的去中心化程度、提高交易的确认速度和安全性、以及不断修补系统的安全漏洞等。

### 两者的区别

- **目的和方法**：重放攻击的目的是重新使用之前捕获的有效数据，而双花攻击专注于试图让同一笔资金被重复使用。重放攻击可以通过重新发送数据包来实现，双花攻击则涉及到制造冲突的交易。
- **防御机制**：防御重放攻击通常需要在系统中实现一种机制来唯一标识每次交易，而防止双花攻击需要的是一种共识机制，以确保网络中的所有参与者同意哪些交易是有效的。
- **应用范围**：重放攻击并不限于加密货币或区块链，它可以针对任何类型的数字交易或数据传输。双花攻击则是加密货币和区块链特有的安全威胁。

### 双花攻击在比特币中的防御

比特币网络使用一种叫做工作量证明（Proof of Work, PoW）的共识机制来防止双花攻击。当一个比特币用户发起一笔交易时，这笔交易首先被发送到网络中的节点，然后被打包进一个区块。矿工通过解决一个数学难题来竞争区块的创建权，成功的矿工将新区块添加到区块链上，并且网络中的其他节点验证这个区块的有效性。一旦一个区块被加入到区块链，包含在这个区块内的交易就被认为是已经确认的。

为了成功执行双花攻击，攻击者需要能够控制大部分的网络算力，以便能够在私下创建一个比公共链更长的分支链，在这个分支链上，他们可以重写交易历史。这被称为51%攻击。由于比特币网络的算力非常巨大，实施这样的攻击几乎是不可能的，成本高昂且难以实现。

### 重放攻击在比特币中的防御

在比特币本身的上下文中，重放攻击指的是将一笔交易从一个链重放到另一个链的情况。比特币协议通过使用每笔交易独一无二的UTXO（未花费交易输出）模型来防止在其自身网络内的重放攻击。每笔交易都引用之前未被花费的输出作为输入，一旦交易被确认，这些输出就被标记为已花费，不能再次使用。

然而，在比特币和其它链之间，如比特币和比特币现金（BCH）这样的分叉链之间，重放攻击是一个潜在问题。在这种情况下，一笔交易在一条链上有效，可能也会在另一条链上有效。为了防止这种类型的重放攻击，分叉链通常会实施一些机制，如引入新的交易格式或者要求交易中包含特定类型的信息，以确保这些交易只在一条链上有效。

### 总结

虽然理论上比特币网络不是绝对安全的，特别是在理论上存在51%攻击的可能性，但实际上比特币通过其共识机制和独特的交易验证系统成功地防止了双花攻击和自身网络内的重放攻击。对于跨链重放攻击，分叉后的链需要采取额外的措施来防御。

# ETC

## 概括

memory hard 、 mining puzzle、ASIC resistance、POW和POS它们之间的联系是什么？  
  
这些术语都与区块链和加密货币的共识机制相关，每个都扮演着重要的角色。让我们分别来看看它们以及它们之间的联系：

1. **工作量证明（Proof of Work, POW）**：POW是一种共识机制，用于在没有中央权威的情况下，通过网络中的节点达成共识。它要求参与者解决一个计算上复杂的问题（挖矿难题），以验证交易并创建新的区块。成功解决问题的参与者（矿工）会获得新创建的加密货币作为奖励。比特币就是采用POW机制的一个著名例子。
    
2. **权益证明（Proof of Stake, POS）**：与POW不同，POS不依赖于解决复杂计算问题来达成共识。在POS中，区块的创建者是根据他们持有的货币数量和持有时间来选出的。这意味着，持有更多货币的人有更大的机会创建下一个区块并获得奖励。POS被认为比POW更为环保，因为它消耗的能量要少得多。
    
3. **内存困难（Memory Hard）**：这是一种设计特点，指的是解决某些加密挑战（比如POW挖矿难题）需要大量的内存资源。内存困难的挖矿算法旨在使ASIC（专用集成电路）挖矿不那么经济高效，因为这些算法需要大量的内存带宽，而不仅仅是处理能力。
    
4. **挖矿难题（Mining Puzzle）**：在POW系统中，挖矿难题是一种计算难题，矿工必须解决它才能将新区块加入到区块链中。这个难题的设计旨在控制新区块生成的速度，并确保网络的安全性。
    
5. **ASIC抗性（ASIC Resistance）**：ASIC抗性是指一种加密货币的挖矿算法设计成对专用硬件（如ASIC矿机）不那么敏感，使得使用标准计算设备（如家用电脑）的矿工也能竞争性地参与挖矿。这种设计旨在保持网络的去中心化特性，防止挖矿过度集中在少数拥有高效专用硬件的矿工手中。
    

**它们之间的联系**：

- **POW和挖矿难题**紧密相关，因为POW依赖于解决挖矿难题来验证交易和生成新区块。
- **内存困难**和**ASIC抗性**通常在设计POW挖矿算法时考虑，以鼓励更广泛的参与并防止挖矿集中化。
- **POS**作为一种不同于POW的共识机制，旨在解决POW中的能源消耗和潜在的集中化问题。

每种机制和特性都旨在提高区块链网络的安全性、去中心化程度和/或能效。   

smart contract 
![](Pasted%20image%2020240331113300.png)
![](Pasted%20image%2020240331113322.png)

![](Pasted%20image%2020240331113420.png)

![](Pasted%20image%2020240331113626.png)

![](Pasted%20image%2020240331114006.png)
![](Pasted%20image%2020240331114202.png)

![](Pasted%20image%2020240331114044.png)
![](Pasted%20image%2020240331114140.png)
可以防御double spending attack

BTC每笔交易都会说明来源，
那ETH,account-based ledger （ 基于账户模，指的是以太坊区块链上的账户账本系统）这个模型的缺点？
![](Pasted%20image%2020240331114356.png)

![](Pasted%20image%2020240331114655.png)
![](Pasted%20image%2020240331114716.png)
![](Pasted%20image%2020240331114727.png)
![](Pasted%20image%2020240331114745.png)
![](Pasted%20image%2020240331114755.png)

![](Pasted%20image%2020240331114815.png)
状态树  ：![](Pasted%20image%2020240331114840.png)

![](Pasted%20image%2020240331114906.png)
![](Pasted%20image%2020240331114917.png)
![](Pasted%20image%2020240331114937.png)
![](Pasted%20image%2020240331114945.png)
![](Pasted%20image%2020240331114959.png)

![](Pasted%20image%2020240331115019.png)
![](Pasted%20image%2020240331115031.png)
replay attack
![](Pasted%20image%2020240331115126.png)
意思是：A->B (10ETH) , A广播一次, B再广播一次，又扣了A一次钱  

![](Pasted%20image%2020240331115252.png)
![](Pasted%20image%2020240331115436.png)
![](Pasted%20image%2020240331115501.png)
![](Pasted%20image%2020240331115513.png)
![](Pasted%20image%2020240331115639.png)
不可能，因为有资金来源，太明显了，给你转账，你重放一遍，很明显就能看出double spending，就不会成功  

ETH 加一个计数器：nonce
![](Pasted%20image%2020240331120728.png)
转账的时候  
![](Pasted%20image%2020240331120830.png)
收到签名的保护
![](Pasted%20image%2020240331121015.png)
nonce别人改不了

![](Pasted%20image%2020240331121106.png)
![](Pasted%20image%2020240331121118.png)
还要维护nonce的值  

nonce一开始是0，在新账户新创立的时候  
![](Pasted%20image%2020240331122809.png)
nonce值加1  

比如：![](Pasted%20image%2020240331122905.png)
nonce=20
节点发现![](Pasted%20image%2020240331123002.png)，合法的  
![](Pasted%20image%2020240331123026.png)
同时要更新一下：  
nonce=21  
以后如果有人重放这个交易  
![](Pasted%20image%2020240331123154.png)
当前的nonce已经是21了  
![](Pasted%20image%2020240331123224.png)
就不会再执行一遍了     

总结：  
以太坊的账户账本系统是基于状态转换的，这意味着每个交易都会改变账户的状态，例如转移以太币或代币，或者执行智能合约。这些状态转换被记录在区块链上，形成了一个不可篡改的公共账本。

以太坊的账户账本系统支持多种类型的账户，包括外部拥有的账户（Externally Owned Accounts, EOAs）和合约账户（Smart Contract Accounts）。外部拥有的账户由私钥控制，而合约账户由其代码和存储状态控制。合约账户可以执行复杂的逻辑，包括智能合约，这使得以太坊能够支持去中心化应用（DApps）。  

![](Pasted%20image%2020240331123356.png)

一个合约可以调动另一个合约 ，通过nonce值记录调用次数  
![](Pasted%20image%2020240331125445.png)
以太坊规定：
![](Pasted%20image%2020240331125511.png)
![](Pasted%20image%2020240331125545.png)
![](Pasted%20image%2020240331125554.png)
![](Pasted%20image%2020240331125603.png)
![](Pasted%20image%2020240331125621.png)
这可以，但是不能自己发起一个交易  

合约账户有代码code，以及相关的状态storage ，包括每个变量取值  
![](Pasted%20image%2020240331125811.png)

合约怎么调用？  
![](Pasted%20image%2020240331125855.png)
![](Pasted%20image%2020240331125903.png)
![](Pasted%20image%2020240331125911.png)
![](Pasted%20image%2020240331125926.png)
![](Pasted%20image%2020240331125939.png)
![](Pasted%20image%2020240331125951.png)
![](Pasted%20image%2020240331130002.png)

![](Pasted%20image%2020240331130025.png)
![](Pasted%20image%2020240331130044.png)

以太坊创始人![](Pasted%20image%2020240331130111.png)
19岁  


BTC![](Pasted%20image%2020240331130227.png)
![](Pasted%20image%2020240331130237.png)
![](Pasted%20image%2020240331130245.png)

![](Pasted%20image%2020240331130308.png)
![](Pasted%20image%2020240331130318.png)

![](Pasted%20image%2020240331130332.png)
![](Pasted%20image%2020240331130340.png)
跟日常生活中的签合同类似，你跟它签合同，你得找到这个人 ，不然会给合同执行带来困难  ，出现纠纷的时候也可以知道合同是跟谁签的  

![](Pasted%20image%2020240331130607.png)
![](Pasted%20image%2020240331130641.png)


## 以太坊的数据结构-状态树

![](Pasted%20image%2020240331131047.png)
![](Pasted%20image%2020240331131112.png)account-based ledger  

![](Pasted%20image%2020240331131251.png)
![](Pasted%20image%2020240331131259.png)
![](Pasted%20image%2020240331131319.png)

![](Pasted%20image%2020240331131326.png)
![](Pasted%20image%2020240331131402.png)
![](Pasted%20image%2020240331131411.png)
![](Pasted%20image%2020240331131424.png)
![](Pasted%20image%2020240331131500.png)

![](Pasted%20image%2020240331131526.png)
![](Pasted%20image%2020240331131533.png)
前者包括余额balance，交易次数nonce
后者代码code，存储storage  

![](Pasted%20image%2020240331131748.png)![](Pasted%20image%2020240331131814.png)
![](Pasted%20image%2020240331131826.png)
![](Pasted%20image%2020240331131837.png)
![](Pasted%20image%2020240331131857.png)
![](Pasted%20image%2020240331131912.png)
有新的账户就插入到哈希表里面  
你要查询账户的余额，就直接在哈希表中查询  
如果不考虑哈希碰撞的话
![](Pasted%20image%2020240331132051.png)
![](Pasted%20image%2020240331132059.png)
但是，这种设计  

![](Pasted%20image%2020240331132245.png)
![](Pasted%20image%2020240331132253.png)
怎么提供？

![](Pasted%20image%2020240331132332.png)
![](Pasted%20image%2020240331132342.png)
![](Pasted%20image%2020240331132359.png)
![](Pasted%20image%2020240331132410.png)
![](Pasted%20image%2020240331132448.png)
Merkle tree，![](Pasted%20image%2020240331132548.png)，![](Pasted%20image%2020240331132559.png)
公布出去 ，跟比特币一样  
![](Pasted%20image%2020240331132639.png)
![](Pasted%20image%2020240331132645.png)
![](Pasted%20image%2020240331132654.png)
那如果
![](Pasted%20image%2020240331132824.png)
新区块有新的交易，我们要执行这个交易
![](Pasted%20image%2020240331132901.png)
![](Pasted%20image%2020240331132910.png)
![](Pasted%20image%2020240331132931.png)
merkle tree吗？这个代价太大了  
![](Pasted%20image%2020240331133017.png)
![](Pasted%20image%2020240331133029.png)
![](Pasted%20image%2020240331133049.png)
代价太大  

![](Pasted%20image%2020240331133116.png)你也要构造一个merkle tree吗？那么为什么没这个问题？
BTC是把区块中的交易组成一个merkle tree，区块中的交易
![](Pasted%20image%2020240331133314.png)
![](Pasted%20image%2020240331133322.png)
所以BTC中的merkle tree是
![](Pasted%20image%2020240331133359.png)
![](Pasted%20image%2020240331133406.png)
对应一颗merkle tree，然后这个merkle tree构建完之后不会更改 ，下次再发布一个新的区块，再构建一个新的merkle tree。   

![](Pasted%20image%2020240331133607.png) ？
![](Pasted%20image%2020240331133645.png)
![](Pasted%20image%2020240331133631.png)
![](Pasted%20image%2020240331133707.png)
![](Pasted%20image%2020240331133743.png)
![](Pasted%20image%2020240331133751.png)
4000已经是上限了  

如果以太坊采用这种方法会出现什么情况？  
![](Pasted%20image%2020240331134003.png)
merkle tree  
![](Pasted%20image%2020240331134027.png)
![](Pasted%20image%2020240331134035.png)
![](Pasted%20image%2020240331134043.png)
![](Pasted%20image%2020240331134052.png)
构建出一个merkle tree ，  
![](Pasted%20image%2020240331134115.png)
![](Pasted%20image%2020240331134128.png)遍历一遍
除了提供merkle proof![](Pasted%20image%2020240331134210.png)

merkle tree
![](Pasted%20image%2020240331134245.png)
![](Pasted%20image%2020240331134325.png)
![](Pasted%20image%2020240331134338.png)
每个节点就是再内部本地维护一个数据结构  
![](Pasted%20image%2020240331134716.png)
![](Pasted%20image%2020240331134726.png)
![](Pasted%20image%2020240331134737.png)
![](Pasted%20image%2020240331134831.png)块头的一个原因
对于当前这个区块包含哪些交易，所有的全节点要有一个共识  
![](Pasted%20image%2020240331135009.png)
然后构建merkle tree时，根哈希值放在区块头里，这个方法是不行的  
![](Pasted%20image%2020240331135711.png)
![](Pasted%20image%2020240331135727.png)
效率都很好
但是每次去构建merkle tree代价太大   


![](Pasted%20image%2020240331135937.png)
不要哈希表了  
直接就用一颗merkle tree  
![](Pasted%20image%2020240331140016.png)
![](Pasted%20image%2020240331140033.png)merkle tree  里改  
![](Pasted%20image%2020240331140105.png)
![](Pasted%20image%2020240331140127.png)merkle tree里的一小部分  

这个方法行吗？  
![](Pasted%20image%2020240331140227.png)
merkle tree
![](Pasted%20image%2020240331140239.png)

BTC中的merkle tree是怎么构建的？
最低下一层是 transactions，然后哈希值放到上面的节点里，两两结合，然后再取个哈希往上传，

还有另一个问题
如果以太坊也是这样构建merkle tree，就是把所有账户放到一个大的merkle tree里，这个merkle tree要不要排序？
![](Pasted%20image%2020240331175149.png)
如果不排序会怎么样？
不排序的话![](Pasted%20image%2020240331175250.png)
不排序还有另外一个问题：
BTC 中你要证明一个交易包含在区块，是不用排序的 ；  
要证明一个交易不包含在区块，是要用排序的版本的。  
![](Pasted%20image%2020240331175825.png)
ETH中不排序还有另外一个问题？  
这些账户的信息组成merkle tree的叶节点，
![](Pasted%20image%2020240331202223.png)
那么这样构建出来的merkle tree不是唯一的，比如说系统中有很多全节点，每个全节点都安照自己的某个顺序，那么叶节点的顺序全是乱的，算出来的根哈希值也是不一样的。

![](Pasted%20image%2020240331202451.png)？
![](Pasted%20image%2020240331202515.png)
BTC中![](Pasted%20image%2020240331202549.png)
理论上这样构建出来的merkle tree的根哈希值也是不一样的
![](Pasted%20image%2020240331202647.png)
BTC 每个区块的顺序是定的，但每个节点的顺序是不一样的，没有一个统一的规则说这个节点一定要打包到哪个区块里，而是由获得记账权那个节点说了算。  
比特币中的节点是怎么运行的？  
每个节点在本地组装一个候选区块，这个节点自己决定哪些交易，以怎样的顺序被打包到这个区块，然后去挖矿，去竞争记账权，如果他没有抢到记账权，他做什么决定，别人是没必要知道的，只有他有记账权，他发布出去了，而且这个区块最终成为一个被大家接受的区块，那么这个时候顺序才由发布这个区块的节点决定。  
BTC中虽然没有排序的merkle tree，但他这个顺序是唯一的，是由发布区块的那个节点确定的。    
那为什么ETH中不能这么干？    
如果你以太坊也这么干，需要怎么样？需要把这个账户的状态发到区块里。就你也可以说是每个全节点自己决定怎么把账户组织成一个merkle tree，算出根哈希值来，挖出矿来，但是你怎么让别人知道这个事，你得把它发布到区块里，但你发布的是一个所有账户的状态，不是发布区块里包含的交易，差好几个数量级。
你发布的交易的话，是只需要几百个几千个交易，而且这个交易是必须得发布，这个代价你必须得付出，你不发布怎么办，别人怎么知道这个交易，所以这个交易是必须得发布的，账户状态是可以维护在本地的，而且大多数账户状态是不变的，你一个区块那些交易只能改很少的账户，大多数账户状态是不变的，当你重复发布，每隔十几秒发布一个新区块，你把所有状态都打包里面发布一遍，下次再过十几秒再发一遍，这是不可行的，这说明不排序的merkle tree是不行的。  
那么排序我用缩写的merkle tree是不是就没问题？  
你新增一个账户怎么办？你产生一个账户的账户地址是随机的，他叶节点中的位置可能是插在中间的，那后面这些数的结构都得变，你产生一个账户的时候，别人是没必要知道的，只有这个账户对外发生一些交互，比如说他往外转账，或者别人往里面转账，这系统才需要知道，第一点，假设这个账户做个交易，那么别人是需要知道的，
新产生一个账户，对外发生了交互，我需要把它加入到我的数据结构里，那么问题是加入这个代价有多大？如果直接用哈希表的话，那么代价是常数的，你用merkle tree的话，你可能大半棵树得重构，这个代价同样太大了。  所以用排序版本的 merkle tree也有问题，插入的代价太大，以太坊中没有显示删除账户的操作。  

想想ETH的数据结构是怎么设计出来的？    
[Merkling in 以太坊 |以太坊基金会博客 (ethereum.org)](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum)

Merkle Tree与区块链
Merkle Tree是区块链技术的基石。虽然理论上可以不用Merkle Tree建立区块链，直接在区块头部包含所有交易信息，但这样做会导致巨大的可扩展性问题。这种问题可能会使得长期来看，只有极其强大的计算机才能无需信任地使用区块链。但有了Merkle Tree，我们就能在各种设备上运行以太坊节点，无论是大型计算机、笔记本电脑、智能手机，还是物联网设备，比如Slock.it将要生产的那些设备。

Merkle Tree是如何工作的？
Merkle Tree通过将数据分成小块，然后将这些块分到不同的“桶”中，每个桶包含几个小块。接着，对每个桶中的数据进行哈希处理，然后继续这个过程，直到最后只剩下一个哈希值：根哈希Root Hash。这种方法最常见的是二进制Merkle Tree，每个桶总是包含两个相邻的数据块或哈希值。Merkle Tree不仅仅通过分块和哈希这些块的方式工作，它还通过创建一个从叶节点到根节点的哈希链来保证数据的完整性和不可篡改性。这是实现数据验证的关键。

Merkle Tree的好处是什么？
Merkle Tree的一个主要好处是它支持一种称为Merkle Proof的机制。通过Merkle Proof，可以验证某个数据块确实存在于树的特定位置。这种机制允许用户验证大型数据库中的小量数据，而无需验证整个数据库。例如，在比特币中，它用于验证交易是否包含在某个区块中，而以太坊则进一步利用Merkle Tree进行更复杂的验证，比如验证账户余额或智能合约的状态。

比特币与以太坊中的Merkle Proof
比特币使用Merkle Proof来存储每个区块中的交易，从而允许轻节点只下载区块头部数据而不是全部交易数据，简化了支付验证过程。而以太坊不仅用Merkle Tree验证交易，还用它来验证交易结果和账户状态等，使得轻客户端能够对各种查询进行验证。
Merkle Proof 允许节点证明交易数据的正确性而无需下载整个区块链，这对于轻客户端是非常重要的。 

Merkle Patricia Tree
以太坊实际上使用了一种更复杂的Merkle Tree，称为Merkle Patricia Tree，这种树结构使得以太坊能够高效地更新状态，即便是在面对恶意制作的交易时也能保持树的深度受限，保证了以太坊网络的安全和效率。

简而言之，Merkle Tree通过将大量数据分块并以树状结构组织这些块，提供了一种高效且安全验证大型数据集的方式。这使得即使是硬件条件有限的设备也能参与到区块链网络中，无需处理整个数据集就可以验证特定的数据块，从而为区块链的可扩展性和安全性提供了保障。

Merkle Tree和Merkle Patricia Tree的联系是什么？  

1. **Merkle Tree的基本应用**：首先，Merkle Tree被用来验证交易的正确性，这对于任何区块链技术都是基本要求。在以太坊中，这种数据结构不仅用于验证交易本身，还扩展到验证交易结果和账户状态等。这意味着Merkle Tree的应用不仅仅局限于交易数据的整合和验证，还包括了对区块链的当前状态的验证。这是非常重要的，因为以太坊不仅处理交易，还运行智能合约，这些智能合约的执行结果（即交易结果）和账户的最新状态（例如，余额、存储等）也需要被验证。
    
2. **Merkle Patricia Tree的高级应用**：接着，以太坊采用了一种更复杂的Merkle Tree，即Merkle Patricia Tree，这种数据结构特别适用于以太坊的需求。Merkle Patricia Tree不仅保留了Merkle Tree验证数据完整性和不可篡改性的特点，还增加了高效的数据存储和检索能力，尤其是对于频繁变化的数据（如账户状态）。这使得以太坊能够更高效地更新状态，同时在面对恶意制作的交易时也能保持树的深度受限，这对于保护网络免受特定攻击（如拒绝服务攻击）非常重要。
    

**关联性**：通过先进的数据结构（如Merkle Patricia Tree），以太坊不仅可以有效地验证交易和状态，还能保持网络的安全性和高效运行。这种从基本的Merkle Tree到更高级的Merkle Patricia Tree的演进，展示了以太坊如何通过技术创新来满足其特有的需求（如智能合约执行、状态更新），同时确保网络的可扩展性、安全性和效率。   

树的深度？  
树的深度指的是从树的根节点到最远叶子节点的最长路径上的节点数。在一个树状结构中，根节点位于顶部，而叶子节点则是没有子节点的节点，位于树的底部。深度是衡量树结构复杂性和查询效率的一个重要指标。

- **根节点**：树的起点，顶层节点，没有父节点。
- **叶子节点**：树的末端，没有子节点的节点。
- **路径**：从一个节点到另一个节点的节点序列。

例如，在一棵二叉树中，如果从根节点到某个最远的叶子节点需要经过4个节点，那么这棵树的深度就是4。深度的概念对于理解数据结构如何组织和如何高效执行操作（比如查找、插入和删除）非常重要。

在区块链的上下文中，限制梅克尔树（或梅克尔帕特里夏树）的深度有几个好处：

- **提高效率**：深度较小的树意味着查找或验证数据所需的步骤更少，这可以加快处理速度，提高整体效率。
- **增强安全性**：通过限制树的最大深度，可以避免恶意行为者通过创建极其深的树来试图攻击系统，这种攻击可能会消耗大量的计算资源。
- **保持可用性**：确保即使是性能较低的设备也能参与到网络中，执行验证等操作，使得系统更加去中心化和包容。

因此，在区块链技术中，合理地设计和限制树的深度对于确保系统的高效、安全和可用性至关重要。  

Merkle Patricia Tree，在以太坊中主要用于高效地存储和查找数据，通过特定的结构和算法设计来优化和限制树的深度。具体来说，梅克尔帕特里夏树采用以下几种机制来限制树的深度并提高效率：

 1. 前缀压缩（Prefix Compression）

梅克尔帕特里夏树通过前缀压缩减少不必要的节点，这意味着如果一个路径上的节点只有一个子节点，那么这些节点会被压缩成一个节点，并将路径上的标签（key的一部分）合并。这样做不仅减少了节点数量，也相应地减少了树的深度。

 2. 分支节点（Branch Nodes）

分支节点允许在每个节点处有多个子节点。通过使用分支节点，树能够在每个分支点处有效地分散数据，这样做减少了到达任何特定叶节点所需的平均步骤数，从而减少了树的深度。

 3. 叶节点和扩展节点（Leaf and Extension Nodes）

叶节点和扩展节点存储实际的数据和到其他节点的路径。扩展节点特别用于表示可以压缩的路径，进一步减少了树的深度。

 4. 基于键值的路径选择（Key-Based Path Selection）

每个节点的位置基于其键值的内容，这意味着数据的分布是根据其键值的哈希来决定的。这种方法保证了数据在树中被平均分布，避免了某些分支过于深入而其他分支过于浅显的情况，从而平衡了树的深度。

5. 适应性数据结构

梅克尔帕特里夏树的设计允许它根据存储的数据动态调整其结构。这意味着树会根据需要进行优化，以保持效率和深度的平衡。

通过这些机制，梅克尔帕特里夏树优化了数据的存储和查找过程，同时限制了树的深度，确保了即使在持续的数据更新和增长中也能保持高效和安全。这对于以太坊这样的大规模、高频交易的区块链系统来说是至关重要的。
### 为什么ETH使用Merkle Patricia Tree而非不排序的Merkle Tree？
在比特币（BTC）中，Merkle树可以不排序地构建，这是因为比特币的交易数据是按照时间顺序排列的，而且每个区块中的交易数量是固定的。这意味着，即使交易数据不是按照某种特定顺序排列的，Merkle树仍然可以正确地构建，并且可以通过Merkle根哈希来验证交易的完整性和不可篡改性。

然而，以太坊（ETH）中使用的Merkle Patricia树（MPT）与此有所不同。以太坊的状态（state）是一个键值映射，其中键是地址，值是账户声明，包括每个账户的余额、nonce、代码和存储（其中存储本身也是一个树）。与交易历史不同，状态需要频繁更新：账户的余额和nonce经常改变，而且新账户经常被插入，存储中的键经常被插入和删除。因此，所需的数据结构是能够在插入、更新或删除操作后快速计算新的树根，而无需重新计算整个树。这就是为什么以太坊使用Merkle Patricia树，而不是简单的Merkle树。

Merkle Patricia树是一种更复杂的数据结构，它结合了Merkle树的优点和Patricia树的优点。Merkle树的优点是它可以快速验证数据的完整性和不可篡改性，而Patricia树的优点是它可以高效地处理键值映射的插入、更新和删除操作。  

在比特币（BTC）和以太坊（ETH）中，Merkle Tree 的使用虽然都是为了确保数据的完整性和验证效率，但两者在实际实现上有所不同。比特币使用的是简单的二叉Merkle Tree来组织区块中的交易，确实不需要对交易进行排序。以太坊，特别是在其状态和交易的组织上，采用了一种更复杂的形式，称为Merkle Patricia Tree（MPT），这是出于不同的设计考虑和目标。

### 为什么BTC可以使用不排序的Merkle Tree：

1. **设计简单**：比特币的主要目的是作为一种数字货币系统，其交易模型相对简单。在比特币的Merkle Tree中，交易被组织成一个不需要排序的二叉树，主要是为了验证区块中包含的交易列表的完整性和正确性。
    
2. **不需维护状态**：比特币不需要像以太坊那样维护一个复杂的账户状态（如智能合约状态、账户余额等）。因此，它不需要一种能够高效处理和验证状态变化的复杂树结构。
    

### 为什么ETH使用Merkle Patricia Tree而非不排序的Merkle Tree：

1. **复杂的状态管理**：以太坊不仅处理交易，还维护一个复杂的状态系统，包括账户余额、智能合约代码和状态等。Merkle Patricia Tree（MPT）能够有效地处理这种类型的数据，支持快速的数据插入、查找和更新，同时保持数据的完整性验证。
    
2. **支持更多功能**：MPT支持的功能远远超过简单的数据完整性验证。它的设计允许以太坊实现如轻客户端协议等高级功能，这些功能需要对状态进行有效的证明和验证。
    
3. **防止重放攻击**：在以太坊中，交易的顺序很重要，因为交易可能相互依赖。使用排序的树结构（如在MPT中）有助于防止某些类型的攻击，例如重放攻击，因为这要求对交易的顺序进行验证。
    

总的来说，以太坊不能使用不排序的Merkle Tree的原因主要是因为它的设计目标和需求与比特币有所不同。以太坊需要一种更复杂的数据结构来高效地管理和验证其复杂的状态，而Merkle Patricia Tree提供了这种能力。这并不意味着以太坊不能技术上使用不排序的Merkle Tree，而是说出于其设计和功能需求，采用了MPT作为其数据结构的一部分。  



Merkle Patricia Trie（MPT）
ETH采用的是 MPT 的结构，

先了解一个简单的数据结构： trie  
字典树，用于快速查找单词或前缀，它也被称为前缀树（prefix tree），Trie的每个节点代表一个字符，从根节点开始，每个节点的子节点代表下一个字符。  

区块链的第一个区块叫什么？
Genesis Block 创世纪块  

下图是组织成一个trie的结果
![](Pasted%20image%2020240404205800.png)

 trie的特点： 
 1.  
![](Pasted%20image%2020240404211126.png)  ![](Pasted%20image%2020240404211411.png)
 ![](Pasted%20image%2020240404211425.png)
 表示到这个地方，这个单词是就结束了。  

![](Pasted%20image%2020240404211541.png)
![](Pasted%20image%2020240404211604.png)
![](Pasted%20image%2020240404211706.png)
branching factor  ,树形数据结构中的分支因子,指每个节点的子节点数量，也称为出度（outdegree）。
即 17，![](Pasted%20image%2020240404212123.png)
![](Pasted%20image%2020240404212136.png)
0-f，所以是17  

2. trie的 ![](Pasted%20image%2020240404212304.png)
![](Pasted%20image%2020240404212339.png)
![](Pasted%20image%2020240404212356.png)
![](Pasted%20image%2020240404212514.png)
但是我们应用当中，所有的键值都是一样长的，都是40，因为地址都是40位16进制数。  

![](Pasted%20image%2020240404212655.png)
![](Pasted%20image%2020240404212704.png)
但有一点是类似点：  
以太坊中的地址也是公钥经过转换得来的，其实就是公钥取了哈希，然后前面截一段不要了，只要后面这一段。  

3.  trie是不会出现碰撞的，只要两个地址不一样，最后肯定映射到树中的两个不同分支。  
4. 输入不变，无论是按照什么样的顺序插入到树中，构成的trie是同一颗树。这个对我们的应用来说是很有用的，就是不同的节点，无论你按照怎样的顺序插入到账户中，最后构造出来的树是一样的。  
5. 更新的局部性很好，每次发布一个区块，系统中绝大多数的账户的状态是不变的，只有个别受到影响的账户的状态才会变，所以更新的局部性很重要。比如说我要更新genesis这个key对应的value ，上图当中只画出了key， 没有画出Value，要更新genesis这个key对应的value，我只要访问下面的分支，其他分支是不用访问的，也不用遍历整棵树 。  

 trie的缺点：  
 1. 存储浪费 。  
 都只有一个子节点，![](Pasted%20image%2020240405151544.png)， 如果可以把节点合并，可以减少存储的开销，提高查找效率。 

所以引入了 Patricia Tree （也可以写成  Patricia Trie）   
![](Pasted%20image%2020240405154132.png)
![](Pasted%20image%2020240405154158.png)
下图是路径压缩的结果：  
![](Pasted%20image%2020240405154240.png)

压缩好处：
![](Pasted%20image%2020240405154341.png)
这样访问内存的次数就减少，效率就提高了  

注意：  
对于Patricia Tree来说，如果你新插入一个单词，原来压缩的路径可能需要扩展开来，比如说 geometry ，左边就不能如图压缩  

路径压缩在什么情况下比较好？  
这个树中插入的这些键值的分布，如果是比较稀疏的情况下，你做不做路径压缩，效果差距比较大。比如说我们这个例子当中是用英文单词，如果你这个英文单词，每个单词都很长，但是一共没有几个单词，那么插入普通的trie中，如下图：
![](Pasted%20image%2020240405161059.png)
![](Pasted%20image%2020240405161319.png)
![](Pasted%20image%2020240405161339.png)
如果用 Patricia Tree 呢 ，
下图是用 Patricia Tree 的结果：  
![](Pasted%20image%2020240405161436.png)
这个树的高度明显改善多了
所以键值分布比较稀疏的时候，路径压缩效果比较好  

那么我们的应用当中键值分布是不是比较稀疏的？  
我们的应用当中，键值是地址

地址是160位，所以整个地址空间有多大？就是2的160次方  
![](Pasted%20image%2020240405162028.png)
这是一个非常大的数，如果我们要设计一个键值程序的算法，它的运算次数是2的160次方，那么有生之年有可能都算不出来。 以太坊的账户数目加起来都远远没有这么大，  所以它是非常稀疏的。

为什么要搞得这么稀疏？  
地址容易碰撞（ETH 的普通账户 和 BTC 创建方法都是一样的，没有一个中央的节点，每个用户自己独立建账户，你在本地产生一个公私钥对就是一个账户，那怎么防止碰撞呢？就是地址要足够长，分布要足够稀疏）    

**扩展 Binary tree：**
Binary tree（二叉树）是一种基础且重要的数据结构，它是由节点（nodes）构成的，具有以下特性：

1. 每个节点最多有两个子节点，通常被称为左子节点（left child）和右子节点（right child）。
2. 没有子节点的节点被称为叶子节点（leaf nodes）。
3. 每个非叶子节点可以有一个左子节点、一个右子节点，或者同时有左右子节点。
4. 每个节点通常包含一些数据和两个指向其子节点的链接（或者引用）。
5. 二叉树的一个特例是“二叉搜索树”（Binary Search Tree, BST），其中每个节点的值都大于其左子树中任何节点的值，并且都小于其右子树中任何节点的值，这使得数据的查询、插入和删除操作更为高效。

二叉树的应用非常广泛，包括但不限于：

- 实现高效的查找和排序算法（如二叉搜索树、AVL树、红黑树等）。
- 用于编码和压缩数据（如哈夫曼编码树）。
- 在图形界面的渲染、决策制作、数据库索引、机器学习等领域也有应用。

二叉树可以通过链表或数组等数据结构在计算机中表示和存储。  

**扩展 Sorted Merkle tree：**
Sorted Merkle tree是一种特殊类型的Merkle树，其中的叶节点存储的数据是经过排序的。Merkle树是一种二叉树结构，用于提供数据的完整性和一致性验证。在Merkle树中，每个叶节点包含数据块的哈希值，而非叶节点则包含其子节点哈希值的哈希。树的根节点，称为根哈希或Merkle根，代表了整个数据集的哈希摘要。

在Sorted Merkle tree中，叶节点中的数据在被哈希之前会按照某种规则进行排序。这种排序可以是基于数据的自然顺序，也可以是基于特定的排序规则。通过对数据进行排序，Sorted Merkle tree能够提供额外的安全性特性，并且在某些应用场景中可以提高效率，比如在证明某个数据元素是否存在于树中时，可以使用二分查找等方法来加速查找过程。

Sorted Merkle tree常见于一些特定的区块链实现和分布式系统中，用于确保数据的一致性和安全性，以及支持高效的数据验证和查询操作。

Sorted Merkle tree能证明什么？47分

**Merkle tree 和 binary tree （二叉树）有什么区别？**    
即区块链和链表有什么区别？  
把普通指针换成哈希指针 ，MPT 也一样，把普通指针换成哈希指针，把所有的账户组织成一个 PT ，用路径压缩，提高效率，然后把普通指针换成哈希指针，所以就可以计算出一个根哈希值，这个根哈希值也是写在 区块头（Block Header） 里；  
BTC 的 lock Header 里只有一个根哈希值，就是这个区块里包含的交易组成的 Merkle tree 根哈希值；  
ETH 有3个, 以太坊中也有一个交易组成的叫交易树。我们现在讲的叫状态树，账户状态最后组成的一个 Merkle tree 的根哈希值，这个根哈希值有啥用？  
第一是防止篡改，只要根哈希值不变，整个树的任何部分都没办法被篡改，![](Pasted%20image%2020240405171401.png)
第二，Merkle Proof 这个树能证明什么？  
能证明你有多少钱，证明你账户上的余额是多少， 怎么证明？  
就是你这个账户上所在的那个分支，整个分支自己向上作为 Merkle  proof 发给这个轻节点，轻节点就可以验证一下你有多少钱。    

还能证明某个账户是不存在的，
你创建一个账户，如果别人都不知道的话，那这个是没办法证明出来的，      
能不能证明这个MPT中某个键值是不存在的？( 假设你想要给一个地址转账之前，你想验证一下这个全节点有没有这个账户的信息，这个能证出来吗？)  
能，这个方法跟那个 Sorted Merkle tree 类似，如果存在的话，他是在什么样的分支，把这个分支作为 Merkle Proof 发过去，可以证明他是不存在的。   

以太坊中用的还不是原生版的MPT，用的是 Modified MPT，对 MPT  做一些不是很本质的修改。  下面就是 Modified MPT 的例子：  

![](Pasted%20image%2020240406170715.png)
这个例子呢，右上角有4个账户，
这个树中的节点分为3种，如果树的某个部位出现路径压缩，就会出现 extension node，这四个地址的前两位都是a7，所以它的根节点就是一个 extension node，
Shared nibble(s) 中的 nibble(s) 是16进制数的意思，一个 nibble 就是一个16进制数，从第三位开始就不同了，所以就跟着一个 brunch node ，以此类推，这就是一个状态树。  
另外注意：这个树的根节点取哈希之后得到一个跟哈希值要在这个 block header 里面。  
另外还有分奇数和偶数 nibble 。  
而且他用的是哈希指针，比如说7这个位置，它连的是一个 extension node，是说7这个位置里面存的值是下面这个节点的哈希值，如果是普通指针的话，那也就是说7这个位置存的值是下面这个节点的地址，这里是把地址换成了哈希值。  

每次发布一个新的区块时，这个状态树中的一些节点的值会发生变化，这些改变不是在原地改的，而是新建一些分支，原来的状态其实是保留下来的。    

下面这个例子中显示有两个区块：  

![](Pasted%20image%2020240406172924.png)
这是两个相邻的区块，这个 state root 就是状态树的跟哈希值，后面显示的是这棵树，右边是新的区块的状态树，虽然每个区块有一个状态树，但是这两棵树的大部分节点是共享的，像右边这棵树主要都是指向左边这棵树的节点，只有那些发生改变的节点，才需要新建一个分支，这个例子是一个合约账户发生了变化，因为他有code，还有存储，就是合约账户的存储也是用MPT的形式保存下来的。  

那么这个例子，这个账户呢，新的区块里这个交易次数 Nonce 是发生变化，这个balance余额也发生变化，这个代码是不变的，所以这个 codehash 指向原来的这个节点，原来树中的节点。存储是变了，但是存储这底下这个存储数，存储树中大部分节点也是没有改变，这个例子当中呢，只有这底下的一个节点，这个整数变量从29变成了45，所以新建的一个分支。  

所以呢，系统中每个全节点需要维护的不是一颗 MPT，而是每次出现一个新区块都要新建一个 MPT，只不过这些状态树中大部分的节点是共享的，只有少数发生变化的节点是需要新建分支的。

为什么要保留历史状态呢？为什么不在原地直接改了？
因为系统中有时候出现分叉，临时性的分叉是非常普遍的，以太坊中把出块时间降到10几秒之后，这种临时性的分叉是种常态，因为区块链往上传播的时间可能也需要10几秒，所以这是一种常态。 

![](Pasted%20image%2020240409132900.png)
假设有一个分叉，两个节点同时获得记账权，这两个分叉最后有一个会胜出，比如上面这个节点胜出了，那么下面这个分叉的节点要怎么办？回滚（roll back），就是把这个节点当前的状态，取消掉，退回到上一个区块的状态，然后沿着上面那条链往下推进。

就有的时候我们可能需要把当前状态，退回到没有处理到这个区块中交易的前一个状态。  

那怎么实现回滚呢？  
是要维护这些历史记录。  

![](Pasted%20image%2020240409133736.png)
不是为了证明以前我有多少钱，而是因为当前这个交易有可能要undo（"撤销"、"取消"或"复原"某个操作或者状态）。这个跟比特币还不太一样，如果是比特币的话，它交易类型比较简单，有的时候你可以通过这种反向操作推算出钱，比如说如果就是简单的转账交易。A转给B，10个比特币。那这个账户余额有什么影响？A的账户上少了10个比特币，B的账户呢，多了10个比特币，对吧？假设这个交易要回滚了，退回到前一个状态，那就把B这个账户减少10个比特币，把A的账户加回去10个比特币就行了，这个是简单的转账交易，你要回滚其实是比较容易，那ETH为什么就不行？  

因为ET中有智能合约，智能合约是图灵完备的，他的编程功能是很强大的，从理论上来说，它可以实现很复杂的功能，它跟比特币中那个简单的脚本还不太一样，所以以太坊中，如果你不保存以前的状态，智能合约执行完之后，你想再推算出前面是什么状态，这是不可能的。谁知道你的合约代码是怎么样的，你没有办法可以自动推算出前面的状态，所以要想支持回滚，必须得保存历史状态。

这个存储是什么？
MPT 基本上可以被看作是一种键值存储（key-value store），维护的是变量到这个变量取值的一个映射，ETH 这个结构是一个大的 MPT 包含很多小的 MPT ，每一个合约账户的存储都是一个小的 MPT 。    

下图是以太坊代码中的一些数据结构：  
![](Pasted%20image%2020240409135217.png)
这个是 Block header 块头，  
以太坊（ETH）的区块头主要包含以下内容：  
**Parent Hash（父区块哈希）**: 当前区块的父区块（即前一个区块）的哈希值。  
**Uncle Hash 或 Ommer Hash（叔区块哈希列表）**: 当前区块叔区块的哈希列表（叔区块是与父区块的父区块有相同祖父的区块，但不是父区块的一部分）。  
**Coinbase**：指代接收区块奖励的矿工的地址。  
在区块链术语中，特别是以太坊和比特币等PoW（工作量证明）协议中，coinbase是一个特殊的交易，也称为区块奖励交易。这是矿工成功挖到一个新区块时自动生成的交易，用于奖励矿工。这个交易中包含了新生成的加密货币和所有的交易费用。  
**Beneficiary（受益人）**: 也称为矿工地址，是挖出当前区块的矿工的以太坊地址。  
**State Root（状态根）**: 包含了以太坊状态树的根节点哈希值，记录了当前所有以太坊账户状态的根哈希。  
**Transactions Root（交易根）**: 包含了所有交易的Merkle Patricia树的根哈希值。  
**Receipts Root（收据根）**: 包含了所有交易收据的Merkle Patricia树的根哈希值。  
**Logs Bloom（日志Bloom）**: 跟收据树相关，提供一种高效的查询，符合某种条件的交易的执行结果，用于轻客户端快速搜索和检索日志的数据结构。  
**Difficulty（难度）**: 当前区块的难度值（挖矿的难度），表示了生成当前区块的计算难度。  
**Number（区块号）**: 当前区块在区块链中的序号。  
**Gas Limit（Gas 上限）**: 当前区块中所有交易消耗Gas 总量的上限。  
**Gas Used（Gas 用量）**: 当前区块中所有交易消耗的 Gas 总量。  
**Timestamp（时间戳）**: 区块产生的时间戳。  
**Extra Data（额外数据）**: 矿工可以在其中包含一些额外信息的字段。  
**Mix Hash（混合哈希）**: 与难度值一起用于证明工作量证明（PoW）的计算。  
**Nonce（随机数）**: 与混合哈希一起满足区块难度条件的值，证明了工作量证明的完成。  
### ETH中有三颗树  
状态树 交易树 收据树    
上表中对应三个根哈希  
Root  TxHash ReceiptHash

![](Pasted%20image%2020240409202503.png)

![](Pasted%20image%2020240409202528.png)

 **扩展 key-value pairs：**
数据以键值对（key-value pairs）的形式存储。每个键值对包括两部分：

1. **键（Key）**：通常是一串字符或数字，用于唯一标识存储在MPT中的数据。在区块链应用中，键可能代表账户地址、交易哈希或其他唯一标识符。
    
2. **值（Value）**：与键相关联的数据。值可以是任何类型的数据，比如账户的余额、智能合约的代码、或者是某个交易的详细信息。
    

MPT的存储结构设计使其能够高效地插入、查找和删除键值对，同时保持数据的完整性和安全性。每次添加、更新或删除键值对时，MPT的结构都可能发生变化，但它的设计确保了这些操作的效率和数据的可验证性。

### MPT的键值对存储过程：

- 当插入一个新的键值对时，MPT会根据键的内容通过一系列转换和编码过程，确定应该在树的哪个位置插入该键值对。
- 如果键的某个前缀与树中已有的路径匹配，则这个新键值对可能会共享树的一部分路径，直到分叉点。
- 在分叉点，树会根据键的剩余部分创建新的节点来存储值，或者在现有路径上插入新的节点以保存新的键值对。

MPT通过这种方式优化了存储空间，并保证了即使在存储大量数据时也能高效地进行数据检索和验证。在区块链上，这意味着即使数据量巨大，节点也能快速验证数据的完整性和状态的准确性。  

MPT）基本上可以被看作是一种键值存储（key-value store）。在MPT中，每个键（key）都对应一个值（value），并且这些键值对以一种特定的结构存储，这种结构支持高效的查找、插入和删除操作，并且还能验证数据的完整性。

在区块链技术，特别是以太坊中，MPT用于存储状态数据，其中每个账户地址（作为“键”）都映射到一个包含账户余额、合约代码和内部存储等信息的状态对象（作为“值”）。这种键值对的存储方式使得以太坊能够快速访问和更新账户状态，同时保持了数据的完整性和一致性。

MPT的设计通过树形结构优化了数据存储和检索的过程，每次数据的变动都会影响到树的结构，进而影响到树根的哈希值。这个根哈希值的变化可以用来验证整个数据结构的完整性，这是MPT作为键值存储在区块链应用中非常重要的特性。

**扩展 Uncle Hash：**
"Ommer Hash" 和 "Uncle Hash" 在以太坊的上下文中是同义词，用于描述叔块（uncle block）的哈希值列表。  

当多个矿工几乎同时找到一个新的区块时，只有一个区块能够成为主区块链上的有效区块，即被纳入区块链的正式历史记录中。其他几乎同时被挖出的区块被称为叔块（uncle blocks）或叔区块。这些叔块在概念上与主区块链是平行的，它们包含相同的高度信息，但因为只有一个区块可以成为主区块链上的有效区块，所以叔块不会被直接包含在主区块链上。

尽管叔块并不直接纳入主区块链，但它们对整个区块链的安全性和去中心化性质有着重要的贡献。首先，叔块证明了其他矿工在同一时间段内也在进行挖矿活动，这增加了区块链的分布式性。其次，叔块为矿工提供了额外的奖励，因为它们对整个区块链的安全性和完整性起到了积极的作用。最后，叔块还可以减轻区块链网络中的拥塞和竞争，因为它们允许其他矿工的工作也能获得一定程度的奖励，而不仅仅是挖出主区块链上的区块的矿工。  

**扩展 Parent Hash：**
"Parent Hash（父区块哈希）"是指当前区块的前一个区块（即父区块）的哈希值。在区块链中，每个区块都包含了对前一个区块的引用，这种引用是通过存储前一个区块的哈希值来实现的。

进一步解释的话，区块链是由一系列区块组成的分布式数据库，每个区块都包含了一定数量的交易数据以及对上一个区块的引用。区块链的设计使得每个区块都由其前一个区块链接而成，因此形成了一个连续的、不可篡改的链条。这种链式结构是通过将前一个区块的哈希值包含在当前区块中来实现的。

具体来说，每个区块的区块头包含了前一个区块的哈希值，这样就创建了一个链接，将所有区块连接在一起形成了区块链。通过存储前一个区块的哈希值，区块链就能够确保每个区块都能被正确地连接起来，从而构建起一个安全、不可篡改的分布式数据库。

Uncle Hash 和 Parent Hash 的哈希大小都是固定的，通常是 32 字节（256 位）。这是因为它们都是通过哈希函数生成的，因此长度固定。   
然而，Uncle Block 和 Parent Block 的大小是可以不同的。Uncle Block 指的是在同一高度被不同矿工几乎同时挖出的区块，但它们不会被包含在主区块链上。由于区块中包含的交易数量不同，以及可能存在的额外数据等因素，Uncle Block 的大小可能会比 Parent Block 大很多。  

在计算机科学和密码学领域，通常使用的单位是比特（bit）和字节（byte）。一个字节通常由8个比特组成。因此，32字节实际上包含了256个比特。

这里的计算方式是：32 byte * 8 bit = 256 bit。

因此，当我们说一个哈希值是32字节时，它实际上是由256位二进制数字组成的。这是为了简化表示，通常我们更倾向于使用字节而不是比特来描述数据的大小。  

**扩展 Beneficiary 与 Coinbase 的区别：**  
1. **Beneficiary**：在以太坊交易中，Beneficiary通常指的是接收交易中转账的地址。这可以是一个普通的账户地址（外部账户）或一个合约地址。在一个典型的交易中，发送方会指定一个接收方地址，这个接收方就是Beneficiary。
    
2. **Coinbase**：在区块链的语境中，Coinbase是一个特定的地址，用于接收新挖掘的区块产生的奖励，即区块奖励。这个地址是矿工在挖矿前设定的，用以收取他们因成功挖掘区块而获得的奖励（包括新发行的币和区块中所有交易的手续费）。
    

在以太坊中，一个区块的Coinbase地址通常是矿工或矿池的地址，而这个地址与交易中的Beneficiary地址是完全独立的。所以它们通常是两个不同的地址。一个用于接收挖矿奖励，另一个用于日常交易中的资金接收。  

**扩展 Bloom：**  
在以太坊（ETH）中，Bloom过滤器是一种数据结构，它用于提供高效的数据查询和存储方式，尤其是在智能合约的日志（Events）中查询。它帮助快速判断某个特定的事件、地址或者主题是否在某个区块的日志中存在，而不必检查区块中的每一个日志项。这种方式特别适用于那些处理大量数据的场景，因为它能显著减少需要处理的数据量。 

- 工作原理

Bloom过滤器通过使用多个哈希函数，将要查询的项目映射到一个较大的位数组上。当查询特定数据是否存在时，通过同样的哈希函数对数据进行处理，检查相应的位是否为1。如果所有的位都是1，那么该数据可能存在于集合中；如果任一位不为1，则数据绝对不在集合中。

- 使用场景

在以太坊中，每个区块的头部都包含一个Bloom日志，用于快速检索该区块是否包含与给定地址或事件相关的日志。这使得查询变得极为高效，尤其是在处理与智能合约交互相关的信息时。

总的来说，Bloom过滤器在以太坊中提供了一种空间和时间效率极高的方法，来处理和查询区块链上的日志数据。

**扩展 Gas Limit 和 Gas Used：**
- Gas Limit（Gas 上限）
- Gas Used
这两个跟燃料相关，只能合约需要消耗燃料费，有点类似 BTC 中的交易费 

**扩展：**
**mixdigest是什么，跟Mix Hash有什么联系或区别？**
**mixdigest跟nonce有什么联系？**
  
**MixDigest 和 Mix Hash 在区块链中的关系**

在区块链中，特别是在以太坊的挖矿过程（在转向权益证明之前），"MixDigest" 和 "Mix Hash" 是相关的概念，都在挖矿（工作量证明）过程中起着关键作用。具体来说，“Mix Hash”是以太坊区块头的一部分，用于证明已对该区块进行了足够的计算。而“MixDigest”则用于验证区块是否未被篡改，并且符合网络的当前状态。

**MixDigest 和 Nonce 的关系**

在区块链技术中，“Nonce”是矿工为成功挖掘区块而解决的一个值。它与“MixDigest”直接交互，因为改变nonce会改变区块的哈希结果。矿工的目标是调整nonce，直到整个区块头（包括MixDigest）的哈希值低于网络当前难度级别定义的目标值。这一过程确保了区块链中新添加的区块的安全性和可验证性，这些组件共同工作，确保区块安全、可验证，并以去中心化和无需信任的方式添加。  

**MPT和PT有什么区别？**

下图是区块的结构  
![](Pasted%20image%2020240413094236.png)
比较相关的就是前面三个域，header ，uncles ，transactions,那第一个 header 就是指向block header的指针，就我们上页刚刚看过那个 block heade 的指针，是指向叔父区块的 header 的指针，而且还是个数组，因为一个区块儿可以有多个叔父区块，transactions 就是这个区划中的交易的列表。  

![](Pasted%20image%2020240413094828.png)
这个 extblock 就这个区块真正在网上发布的时候，发布的就是这些信息，其实就是我们刚才那个PPT看到的前三项真正发布出去的。  


状态树保存的是key value pair（key， value），key 就是地址，  
我们讲到现在主要讲的是这个键值，这个地址的管理方式，那这个value呢，就账户的状态呢，它是怎么存储在状态树当中的？实际上它是要经过一个序列化的过程 RLP 用这个编码做序列化之后再存储。  

RLP 是什么意思？  
Recursive Length Prefix  
是一种做序列化的方法    
特点是简单，是极简主义，越简单越好。
大家听说过 protocal buffer(简称：protobuf ) 吗？  
这是个很有名得得做序列化的库，很常用的做序列化的库，就跟这些库相比，RLP的理念就是越简单越好，它只支持一种类型。  

rested array of bytes
就是字节数组，由一个字节组成的数组，可以嵌套。    
以太坊中所有的其他类型整数也好，比较复杂的哈希表也好，最后都要变成这个rested array of bytes。  
所以你要实现一个RLP比实现一个 protocal buffer 要容易的很多，因为难的东西他都不做，都推给应用层去做。

今天这个课的内容是比较多的，我们从以太坊中设计的理念开始讲，为什么要这样设计，一步一步讲到这。  

## 以太坊中的交易树和收据树  

每次发布一个区块的时候，这个区块里所包含的那些交易会组织成一棵交易树，也是一棵Merkle Tree，跟比特币中的情况是类似的。同时呢，以太坊还增加了一个收据树，每个交易执行完之后，会形成一个收据，记录这个交易的相关信息，就是交易树跟收据树上面的节点是一一对应的。增加这个收据树主要是考虑到以太坊的智能合约执行过程比较复杂，所以通过增加这个收据树的结构，有利于我们快速查询一些执行的结果。  

从数据结构上呢，交易数和收据数都是MPT，这个呢跟比特币有所区别，比特币中的交易树就是用普通的Merkle Tree，就去把你的所有交易就组织成一个普通的Merkle Tree，然后你MPT也是一种 Merkle Tree，这个叫 Merkle Patricia Trie，它也是一种Merkle Tree，但是跟比特币中用的不是完全一样，为什么有这个区别呢？我猜其实就是为了方便，以太坊中的三棵树都用同样的数据结构，这样代码比较统一，便于管理，不一定非要有什么更深层次的原因。  
当然了，用MPT的一个好处是它支持查找操作，就是你可以通过键值从顶向下沿着这个数进行查找，   
对于状态树来说，查找的键值就是这个账户的地址，  
对于交易树和收据树来说，查找的键值就是这个交易在发布的区块里面的序号，就他排第几。 这个交易的排列顺序是由发布区块的那个节点决定的。  

这三个树有一个比较重要的区别：  
交易树和收据树都是只把当前发布的这个区块的交易组织起来的，而状态树是把系统中所有账户的状态都要包含进去，不管这些账户跟当前区块的交易有没有什么关系。   

从这个数据结构来说呢，多个区块的状态树是共享节点。
每次新发布一个区块的时候，只有这个区块中的交易影响了，就改变了状态的那些节点需要新建一个分支。其他的节点都是沿用原来状态树上的节点就行。
相比之下，交易树和收据树，每个区块的交易树和收据树都是独立的，他们是不会共享节点，就一个区块跟另外一个区块发布的交易本身是独立的。  

交易和收据有什么用呢？ 
一个用途就是提供 Merkle proof，就像比特币当中呢，交易处可以用来证明某个交易被打包到某个区块里，就可以向轻节点提供这样的Merkle proof。  
收明树也是类似的，你要证明某个交易的执行结果，也可以在收据树里面提供一个Merkle proof。  

除此之外呢，以太坊还支持一些更加复杂的查询操作，比如说你想找到过去10天当中所有跟某个智能合约有关的交易，那这个应该怎么查呢？利用方法是把过去10天产生的所有区块都扫描一遍，看看其中有哪些交易是跟这个智能合约相关。但这种方法呢，它的复杂度就比较高，而且呢，你对于轻节点来说，实际上轻节点没有交易列表，它只有一个块头，所以他也没有办法通过扫描所有交易列表的方法来找到符合这种查询条件的交易。  
比如说找到过去10天当中符合某种类型的所有事件，比如说所有的众筹事件，或者是所有的发行新币的事件，那么这些呢，都是需要一个比较高效的方法才能支持。  
所以以太坊中引入了 bloom filter 这个数据结构。  

bloom filter这个数据结构可以支持比较高效的查找，某个元素是不是在一个比较大的集合里面，比如说你有一个集合里面有很多元素，那么现在你想知道某个指定的元素是不是在这个集合里，怎么办？大家能想到什么样的查询方法？  一个最笨的方法是什么？我把这个集合中的元素遍历一遍，看看有没有我想找的那个元素。  这个复杂度是线性的，是非常复杂，另外它有一个前提是什么？你得有足够的存储来保存整个集合的元素，那对于轻节点来说呢，他其实没有这个交易列表，他没有整个集合的元素信息，所以这种方法它是用不了的，那怎么办呢？  

bloom filter 用一个很巧妙的思想，给这个大的集合，包含很多元素的集合计算出一个很紧凑的摘要，
比如说一个128倍的向量，
假设有一个集合ABC，我们要给它计算出一个digest，底下是一个向量，
![](Pasted%20image%2020240413103923.png)  

这个向量初始的时候都是0，然后我有一个哈希函数H，它把每一个元素映射到向量中的某个位置。  
比如说A这个元素取哈希之后映射到这个位置，然后我就把这个位置元素呢，从0变成1。   
然后B呢，可能映射这个位置，那么这个地方也是变成1。  
C呢，比如C映射这个位置，也是变成1。
![](Pasted%20image%2020240413104247.png)就是把每一个元素都取哈希，找到向量中的对应位置，然后把它变成1，所有的元素都处理完了，得到这个向量，就是原来集合的一个摘要。  
这个摘要比原来的结合要小很多，就我们这个例子当中，比如说你就用一个128个  就可以，这个摘要有什么用呢？  
比如说我们有一个元素叫D。我们想知道D这个元素是不是在这个集合里，但这个集合本身我们不一定能够保存下来，应该怎么办？我们用这个哈希函数对D取哈希值，比如说取完之后发现映射到这个地方。映射到0的位置，说明什么？说明这个元素一定不在这个集合里。  
假设呢，取完哈希之后映射过来，映射到1这个位置说明什么？    
映射到1这个地方，有可能是它确实是集合中的元素，比如说D就等于A，所以我把它找到了。也有可能，他不在这个集合里，但是出现了哈希碰撞，恰好映射到了一个跟集合中某个元素一样的位置。
![](Pasted%20image%2020240413105108.png)
所以呢，用这个 bloom filter  ，我们要注意它有可能出现 false positive，但是不会出现 false negative, 就是有可能出现误报，但是不会出现漏报，在里面他一定说在里面，不在里面他也有可能说在里面，这是公的一个基本的工作原理。
bloom filter 有各种各样的变种，  
比如说像解决这个哈气碰撞，有的设计用的不是一个哈希函数，而是一组哈希函数，那么每一个哈希函数独立的把这个元素映射到这个向量中的某一个位置。用一组哈希函数的好处是，如果出现哈希碰撞，那么一般来说不会所有的哈希函数都同时出现。我们这里讲的是bloom filter 的一个high levle 的工作原理，后面我们会看一下以太坊的具体代码，看他的里面的不用具体是怎么设计。  

回到我们这个例子当中。如果从那个集合中删除一个元素，该怎么操作？  
没法操作，这个数据结构的一个局限性是不支持删除。比如说你把A的原删掉了，这个地方是1，你要不要改，你把它改成0的话，这个集合中有可能有另外一个元素也映射到这个位置，就哈气碰撞是有可能的。所以这种简单的bloom filter 是不支持删除操作。
如果你要支持操作的话，这个地方就不能用binary，就不能是0和1了，你把它改成是一个计数器，记录这个的位置，有多少个元素映射过来，而且这里还要考虑到这个计数器会不会over flow，那这样数据结构就复杂的多了，跟当初设计bloom filter 的初衷是相违背的，所以一般来说普通的是不支持操作的。 

那ETH中要这个blue有什么用呢？  
我们说每个交易执行完之后，会形成一个收据，这个收据里面就包含了一个 bloom filter ,记录这个交易的类型、地址等其他信息。发布的区块，在它的块头里也有一个总的bloom filter，这个总的 bloom filter 是这个区块里所有交易的 bloom filter 的一个并集。
比如说你要查找过去10天发生的跟这个智能合约相关的所有交易，
你怎么找呢？  
先查一下哪个区块的块头里的 bloom filter 有我要的这个交易类型。如果块头的 bloom filter没有的话，那么我们就知道这个区块不是我们想要的，如果块头的 bloom filter 有的话，我们再去查找这个区块里面包含的交易所对应的收据树里面的那些 bloom filter，就每个收据的bloom filter，看看哪个有，也可能都没有，因为他有可能是 false positive，如果是有的话呢，我们再找到相对应的交易，直接进行确认。   
这个好处是什么？
好处是通过这个 bloom filter 的结构，能够快速过滤掉大量无关的区块。  
就很多区块，你一看块头的 bloom filter 就知道，肯定不会有我们要的交易，然后剩下的一些少数的候选区块，我们再仔细查看 。  
比如说你是个轻节点，轻节点的话，只有块头信息，那么根据块头就已经能够过滤到很多区块，剩下的有可能是你想要的那些区块，你再去问全节点要一些进一步的信息。  


这个三棵树的根哈希值都是包括在块头里面的。  

**以太坊的运行过程可以把它看作是一个交易驱动的状态机。  
transacton-driven state machine  
这个状态机的状态是什么?**  
就是所有账户的状态，就状态数树包含的那些内容，那么交易是什么？就是每次发布的区块里包含那些交易，通过执行这些交易，会驱动系统从当前的状态转移到下一个状态。

**比特币你也可以认为是一个交易驱动的状态机
比特币中的状态是什么？**
UTXO,没有被花掉的那些输出，  
每次发布一个新的区块，会从UTXO里用掉一些输出，又会增加一些新的输出，所以发布的这个区块会驱动这个状态机，从当前的状态转移到下一个状态。  
所以UTXO可以认为是比特币状态机中的状态。

而且这两个状态机有一个共同的特点：  
就是状态转移都得是确定性的。  
对于一组给定的交易，一个区块中包含的交易，能够确定性的转移到下一个状态。
因为所有的全节点，所有的矿工都要执行同样的状态转移 ，所以状态转移必须得是确定性的。

**比如说有人在以太坊上发布一个交易，某个节点收到这个交易，这个交易说转账从A转到B，有没有可能，这个收款人的地址，这个节点以前从来没听说过，可能吗？**  
可能的，就是以太坊跟比特币一样，创建账户的时候是不需要通知其他人的，只有这个账户第一次收到钱的时候，其他的节点才会知道这个账户的存在。 这个时候要在这个状态树中新插入一个节点，因为这是一个新增加的账户。

**我们前面讲状态树和交易树、收据树的一个区别是，状态树要包含系统中所有账户的状态，无论这些账户是否参与了当前区块中的交易，
那么能不能把这个状态树的设计改一下？改成状态树，每个区块的状态树也只包含这个区块中的交易相关的那些账户的状态。这样就跟交易树和收据树一致了，而且可以大幅度的削减每个区块，所对应的状态树的大小，因为大部分的账户状态是不会变的，这样可以吗？**
如果这样子设计的话，就相当于比特币，比特币是基于交易的账户模型，如果这样设计的话，实际就相当于每个区块没有一套完整的状态树，只有当前这个区块中所包含的交易，涉及到的那些账户的状态，这么刺激的一个问题就是，你想查找某个账户的状态就不方便了，
比如说你有一个转账交易，
![](Pasted%20image%2020240413115934.png)



**扩展 bloom filter：**
 布隆过滤器（Bloom Filter）是一种数据结构，用于快速判断一个元素是否可能存在于一个集合中。它可以给出两种答案：「可能存在」或「一定不存在」。它的特点是高效地节省内存空间，并且查询速度非常快。但是，它也有一定的误判率，即有时会把不存在的元素误判为存在，但不会出现将存在的元素误判为不存在的情况。

与128倍向量的关系可能指的是布隆过滤器在实现时可能会用到向量（vector）数据结构，而128倍向量可能是一种特定的实现方式或者优化手段。在实际应用中，我们可以将布隆过滤器的位数组用128倍向量进行存储，以节省内存空间并提高性能。

简单来说，布隆过滤器可以用128倍向量等数据结构来实现，以实现高效的查询和节省内存的目的。  

Bloom filter 是一种数据结构，用于高效地检测一个元素是否在一个集合中。它的核心优点是空间效率极高，尤其适用于那些元素数量庞大且不需要存储额外数据的场合。Bloom filter 的主要缺点是它有一定的误判率，即它可能会错误地表示某个元素存在于集合中，虽然实际上它不在那个集合中。 

**扩展binary：**
1. **数制**：在数学和计算机科学中，"binary" 指的是二进制数制，这是一种使用两个符号（通常是 0 和 1）来表示数字的系统。二进制系统是计算机技术的基础，因为计算机硬件使用电信号的两种状态（开或关）来处理数据和操作。
    
2. **数据类型**：在计算机编程中，"binary" 也可以指代由 0 和 1 组成的任何数据形式，通常指的是二进制文件，这类文件直接以二进制格式存储数据，不同于文本文件，它们包含了可能不是文本数据的编码信息。
    
3. **操作**：在逻辑或数学中，"binary" 可以用来描述涉及两个组件或操作数的操作，如二元函数或二元运算。
    
4. **比较**：在更广义的用法中，"binary" 可以描述任何涉及两个部分或两个选项的事物，如“二元选择”或“二分法”。
    

在涉及数据结构或计算机程序的上下文中，提到"binary"时，通常关注的是如何以二进制形式处理或表示数据。例如，在之前关于 Bloom filter 的讨论中，"binary" 通常指的是 Bloom filter 使用的位数组，其中的每个位只能是 0 或 1，表示某个元素是否可能在集合中。