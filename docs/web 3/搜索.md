[The React Interview Questions You need to Know](https://www.youtube.com/watch?v=3BN-YHcJfOY)

five most frequent react interview
五个最常见的反应采访

questions and they actually cover up all
问题，他们实际上掩盖了所有

the fundamentals of react and if you
反应的基本原理，如果您

actually understand these five that
实际了解这五个

means you're basically understanding how
意味着您基本上了解

reacts works from Rend during to
Reacts在从期间开始起作用

basically SSR to Global State Management
基本上是全球国家管理的SSR

and pretty much everything you need to
几乎所有您需要的一切

know the first question or the first
知道第一个问题或第一个问题

most frequent reaction interview
最常见的反应采访

question is how to pass data from child
问题是如何通过孩子传递数据

to parent we all know that react has
对于父母，我们都知道React有

actually the parent child flow diagram
实际上是父母流程图

of like data flowing so like it flows
像流动一样流动

from the parents which is you know
从父母那里你知道

always on the top and it flows down to
总是在顶部，然后流向

the child but now how do we take it
孩子，但是现在我们如何接受

actually the data how let's say a child
实际上数据怎么说孩子

wants to communicate with the parents
想与父母交流

and actually send a piece of data from
并实际发送来自

the child to the parent how can we do
父母的孩子我们该怎么做

that so let's imagine we've got this
所以让我们想象我们已经知道了

simple react component which called the
简单的反应组件称为

parent component that has a child called
父母有一个孩子叫

child component and that inside of the
儿童组成部分和内部

CH we've got like an input so what we
ch我们有一个输入，所以我们

want is actually whatever we put inside
想要实际上是我们放在里面的东西

of the input we want to send that piece
我们想发送的输入

of data from the child right into the
来自孩子的数据直接

parent so how can we do that so simply
父母，我们该怎么做才能简单

just declare a state here on the top and
只需在此处声明一个状态，

you declare the state on the parent for
您在父母上声明状态

example in here you know just to be able
示例在这里你知道只是为了

to receive the data from the actual
从实际的数据接收数据

child so you delect data from child and
孩子，您将数据从孩子那里删除，

s data from Child you create a simple
来自孩子的数据您创建一个简单的

Handler that is like handled data from
处理程序就像处理的数据

child that's going to receive the actual
要收到实际的孩子

data received from the child and
从孩子那里收到的数据，

actually update the state with that
实际更新状态

piece of data and simply in here on the
一块数据，只是在这里

GSX you just pass in the send data to
GSX您只需将发送数据传递给

parents and you just bind it with your
父母，你只是把它绑在你的

handle data from Child call back which
处理来自儿童电话的数据

means you're just basically grabbing the
意味着您基本上是在抓住

data and actually just setting the data
数据，实际上只是设置数据

on your own local state so now on the
在您自己的当地状态下，现在

child in here we just simply have an
在这里的孩子，我们只是有一个

input on everything but also like
输入一切，但也喜欢

whenever we do on change that means
每当我们做变革时，这意味着

whenever every single keystroke that
每当每一个击键

happens to be on the input so every
恰好在输入上，所以每个

single key Tru in here we do actually
在这里我们确实这样做的单键tru

through props so we cool props because
通过道具，我们冷却道具，因为

this actually being passed through props
这实际上是通过道具

the send data to parents we callay
向父母发送数据

through props in here and we passing the
通过这里的道具，我们通过

value we want to send back to our parent
我们想寄回父母的价值

and of course the value is going to be
当然，价值将是

like whatever we type inside of the like
就像我们在类似的内部输入的任何内容

particularly the input in here and
特别是此处的输入

everything is going to flow up into the
一切都会流入

parent component here is going to be
父部分将是

stored locally into the D and everything
将本地存储到D和所有内容

is going to flow up into the parent
要流入父母

component here is going to be stored
组件将要存储

locally into the data from Child State
本地进入儿童状态的数据

and now of course we can use the data
现在，我们当然可以使用数据

from Child state in here to basically
从这里的儿童状态到基本上

render whatever we want and later on of
渲染我们想要的一切，以后

course we can go ahead and render the
当然，我们可以继续渲染

data from Child state in here to
来自儿童状态到这里的数据

actually you know showcase and display
实际上你知道展示柜和展示

the data received from the child
从孩子那里收到的数据

component so this is basically what our
组成部分，这基本上就是我们的

example looks like we've got a parent
示例看起来我们有父母

component here on the top right now for
现在在顶部的组件

example the child input in here is empty
示例儿童的输入是空的

so we've got nothing but if you type
所以我们什么都没有，但如果您输入

something on it like hello from the
上面的东西，例如Hello

other side or something you're going to
另一面或你要去的东西

have basically it's going to flow on
基本上它将流动

every single keystroke so like on every
每个击键都像每个击键

single keystroke you type in here it's
您在这里输入的单击键是

going to flow back into the parent and
要回到父母，

that's how you basically pass data from
这就是您从基本上传递数据的方式

child to parent the second question is
父母的孩子第二个问题是

how to render an elements outside of the
如何在外面渲染元素

component cope or the component tree for
组件COPE或组件树

example let's imagine we've got this
例如，让我们想象我们已经有了

real simple component here which called
真正的简单组件在这里称为

render elements outside tree and inside
渲染树外部和内部的元素

of that we've got a div and inside of
其中我们有一个DIV和内部

the div we got a paragraph and a button
DIV我们有一个段落和一个按钮

so that means wherever we're actually
所以这意味着我们实际上是在哪里

going to render this element those two
要渲染这两个元素

like the paragraph and the bner I
像段落和bner我

actually going to render inside of the
实际上要在内部渲染

tree depending on where we place that
树取决于我们放置的位置

particular component so for example for
特定组件，例如

our case in here we're actually placing
我们在这里的情况实际上是

the render elements site tree inside of
渲染元素网站树

the GS X up in here which means
GS X在这里意味着

basically inside of the root inside of
基本上是在根部内的内部

like the main element in here of course
就像这里的主要元素一样

for our up component if you go to the
如果您去

main. GSX the up component is going to
主要的。 GSX UP组件将

be directly rendered inside of the root
直接渲染在根部

and if you track back the root the root
如果您追踪根源

is basically you know a div inside of
基本上你知道内部的一个

the body in here so the body is actually
这里的身体，所以身体实际上是

you know the parent of all Dominoes then
你知道所有多米诺骨牌的父母

actually comes right after the root in
实际上是在根中

here and of course we render all of our
当然，我们在这里渲染了所有

react components and elements inside of
反应组件和元素

react and of course we render all of our
反应，当然我们会渲染所有

react elements and components inside of
反应元素和组件

this root container so now from this
这个根容器现在从此

element what we want is actually want to
元素我们想要的是真正想要的

render a particular element let's say we
渲染一个特定的元素，例如我们

want to render a paragraph but instead
想渲染一个段落，而是

of rendering it inside of the root in
将其渲染到根部

here and inside of the tree we want to
我们想在这里和内部

render it directly to the body from this
从此直接渲染到身体

component I mean you may probably
我的意思是你可能

thinking oh that's not really pass how
想着哦，那不是真的过

am I supposed to do that or why not just
我应该这样做还是为什么不只是

go ahead and have another component and
继续并拥有另一个组件，

just like put another Dom node in here
就像将另一个DOM节点放在这里一样

and actually say oh you can render it
实际上说哦，你可以渲染

over here but like for us actually
在这里，但实际上就像我们一样

reacts provides a really really nice API
Reacts提供了一个非常好的API

that is called portals that allows you
这就是允许您的门户

to do exactly that easiest way possible
做完全最简单的方法

so with portals we can actually go ahead
因此，使用门户网站，我们实际上可以继续

and import the create portal function or
并导入创建门户函数或

method from the react Dom that's
来自React Dom的方法

basically going to allow us to render a
基本上会让我们渲染

child component or a child react element
儿童组成部分或儿童反应元素

in here and actually the second argument
在这里，实际上是第二个论点

will specify where to render it
将指定在哪里渲染

particularly so here we're actually
特别是在这里我们实际上

grabbing the Dom node in here by doing
通过执行此处抓住DOM节点

document get Elements by ID and we do
文档通过ID获取元素，我们做

model to grab this model in here so that
在这里抓住此模型的模型，以便

means it's going to grab us this
意味着它将抓住我们

reference to this particular Domino that
参考这个特定的多米诺骨牌

has an ID of model in here and we're
在这里有一个模型ID，我们

just going to render this paragraph
只是要渲染本段

right inside of it so technically this
从技术上讲，它的内心如此

paragraph is not going to be placed in
段落不会放入

between the first paragraph and the
在第一段和

button but instead it's going to be
按钮，但是它将是

completely placed outside of the current
完全放置在电流外

treay so if we go ahead and look at it
torey，所以如果我们继续看看

there you go so we got the first
你去那里，所以我们得到了第一个

paragraph in here this actually the last
这实际上是最后一个

Buton in here and the one that actually
Buton在这里，实际上是

specified using a portal it's actually
使用门户指定实际上是

being rendered completely outside into
被完全渲染到外面

the Mortal container this child is
这个孩子的凡人容器

placed inside the document body in here
放置在此处的文档主体内

and if you try to look into it if you go
如果您尝试去看一下

inspect in here go to elements now if
在此处检查，现在转到元素

you look inside of the body in here
你在这里看着身体的内心

inside of the body we got the roots
在身体的内部，我们有根源

which has pretty much everything and if
几乎有一切，如果

you look at the model the model
您查看模型

basically has this so it has the
基本上有这个，所以它具有

paragraphs we're rendering using our
段落我们正在使用我们的

portal and that's simply how you render
门户，这仅仅是您渲染的方式

a component or element outside of the
组件或元素

react tree the third one is how to
反应树第三个是如何

implement code spting in your react op
在您的React OP中实施代码跨度

and why and by Cod sping here will also
为什么以及通过鳕鱼刺在这里也将

mean lazy loading if react components so
平均懒负荷如果反应组件如此

that basically the same the question in
基本上是相同的问题

here covers both of the topics so lazy
这里涵盖了这两个主题如此懒惰

loading is basically deferring loading
加载基本上是推迟加载

components code until it's rendered for
组件代码直到呈现为

the first time and that's basically use
第一次，这基本上是使用

when you have a lot of components in a
当您有很多组件

big projects or midsize projects and you
大型项目或中型项目，您

lazily load components on Demand only on
懒洋洋地加载组件仅按需

demand to basically make the main bundle
要求基本上制作主捆绑

of the application or the website
申请或网站

smaller and actually easier to be loaded
较小，实际上更容易加载

when you know the website is firstly
当您知道该网站首先是

visited by a person or something and
一个人或某物访问

load those functionalities those extra
加载这些功能

functionalities or extra components when
功能或额外组件时

they are needed on demand so L load in
需要按需加载

here is officially supported by react of
这是由

course and it has an API for that's
当然，它有一个API

called lazy loading it has a function
称为Lazy Loading它具有功能

that has to do that and suspense and
那必须做到这一点，并悬念

everything and it uses JavaScript
一切都使用JavaScript

promises behind the scenes to handle the
承诺在幕后处理

lazy loading components so for example
懒惰的加载组件，例如

in here we've got this simple component
在这里，我们有这个简单的组件

here called lazy load model and let's
这里称为懒负载模型，让我们

imagine this one has actually a button
想象这个实际上有一个按钮

where it allows you when you click on
单击时允许您允许您

that button it's called like open model
该按钮称为“打开模型”

so when you click on on it it opens a
因此，当您单击它时，它将打开

particular model or a dialogue for you
特定模型或对话给您

and let's say we want this dialogue to
假设我们希望这种对话

be only lazy loaded when the button is
按钮是时，只有懒惰

clicked so like when this component is
单击时，就像此组件是

rendered the model is not going to be
渲染模型不会

loaded whatsoever it's only going to be
加载只有

loaded when the button is clicked and
单击按钮时加载

the mot is about to be opened let's say
MOT即将打开，可以说

for example this Motel has a lot of code
例如，这家汽车旅馆有很多代码

that we don't want to actually initially
我们最初不想真正

load into our bundle to make our website
加载到我们的捆绑包中以制作我们的网站

or react application lightweight and
或对应用程序的反应轻巧，并且

smaller and easier to be loaded you know
较小，更容易被加载，你知道

over the network and everything and of
超越网络，一切

course our Mot here it's just a normal
当然，我们在这里是正常的

component if you go inside of components
组件如果您进入组件内部

mor. GSX in here just a normal component
莫GSX在这里只是普通组件

it uses GSX to render stuff with
它使用GSX与

tailwind and stuff like that so it's
尾风和类似的东西，所以

pretty easy pretty simple and the way to
非常简单的简单

Lazy load is actually using the lazy
懒负荷实际上正在使用懒惰

function that is actually going to be
实际上将是

imported from react so you do lazy you
从React进口，所以您会懒惰

actually return a call back on it so you
实际上回来了一个电话，所以你

do a call back in here and you do import
回到这里，您会导入

component model now you don't need this
组件模型现在您不需要这个

delay for demo because I'm actually just
演示延迟，因为我实际上只是

delaying this just to see the demo but
延迟这一点只是为了查看演示，但是

the simple what you need to do is
您需要做的简单是

actually use the import and you use the
实际使用导入，然后使用

import as a function not like the normal
导入的功能不像正常

import we used to do but import with a
导入我们曾经做过，但用

function in here that's going to
在这里发挥作用

actually return a promise for you and
实际回报您的诺言，

you give it the path of the component
您给它是组件的路径

that you want to Lazy load and this word
你想懒惰和这个词

turn a promise if you look into this is
如果您研究一下，请诺言

going to be a promise and it's going to
要成为一个诺言，它将

only be loaded when you actually call
仅在您实际打电话时加载

and render this moral component now the
现在渲染这个道德组成部分

way you use motal in here or the way to
您在此处使用Motal的方式或

render the lazy loaded moral or whether
渲染懒惰的道德或是否

component you actually Le load in is by
您实际上负载的组件是

just calling it and putting it inside of
只是称呼它并将其放入

suspense so you import suspense in here
悬念，所以您在这里进口悬念

for react suspense basically allows you
悬念基本上允许您

to display and render a fullback UI like
显示和渲染后卫UI

a loading UI while this model is lazily
该型号懒洋洋地加载UI

loaded over Network because of course
由于网络加载，因为当然

this is not going to be loaded initially
这最初不会加载

it's only going to be loaded on demand
它只会按需加载

that means the JavaScript code and the
这意味着JavaScript代码和

bundling is going to be only loaded when
捆绑只会在

this Motel is about to be rendered and
这家汽车旅馆即将渲染，

the model here is going to be rendered
这里的模型将被渲染

only when we click on the button and
仅当我们单击按钮时

when this show motor is going to turn to
当这个节目电动机将转向

true so that means this suspense
是真的，这意味着这种悬念

actually going to go ahead and display
实际上要继续显示

as full back youu on here here we're
在这里，您在这里很满意

displaying just like a small loading
显示像小额负载一样

text in here while code for the motor is
当电动机代码为时，此处的文字是

loading once it's loaded it's going to
加载一旦加载它将

just like the motor is going to
就像电动机要去

completely replace the loading here so
在这里完全更换加载

if you look at it real quickly on the
如果您在

example in here if you click on the open
如果您单击“打开”，请在此处进行示例

motor example we see loading here while
电机示例我们在这里看到加载

the code is loaded and once it's loaded
代码已加载，一旦加载

we're going to find and actually see
我们要找到并实际看到

we're going to have our motor being
我们要让我们的电动机

rendered for us by react and when we
由React和我们何时为我们渲染

Implement lazy loading that's what's
实施懒惰加载是什么

actually going to enforce code splitting
实际上要执行代码分裂

of our components so for in here because
在这里，我们的组件是因为

we are lazy loading the model so if we
我们正在懒洋洋地加载模型，所以如果我们

go and actually see our build directory
去实际看到我们的构建目录

because you're using V in here and
因为您在这里使用V

actually you know V is going to generate
实际上你知道V将生成

and build all the JavaScript and react
并构建所有JavaScript并做出反应

in here and going to just turn it into a
在这里，将其变成一个

JavaScript code in here for the browser
浏览器中的JavaScript代码

so we're going to find a couple of
所以我们要找到几个

Assets in here we're going to find the
资产在这里我们将找到

index which is the main file in here
索引是这里的主要文件

that has all the code for the whole
所有代码全部

website and all application and because
网站和所有应用程序，因为

we're lazy loading the motor in here it
我们在这里懒洋洋地加载电动机

created a separate Javascript file for
为

it which means a separate bundle and it
它意味着一个单独的捆绑包

didn't you know this is what you mean by
你不知道这就是你的意思

coday split in so you split the code of
密码分开，因此您将代码分开

the model into a completely separate
该模型分为一个完全独立的

file that could be lazy loaded on demand
可以按需加载的文件

and that's going to make your
那将使您的

application run faster and gets loaded
应用程序运行更快并加载

faster and if you want to double check
更快，如果您想仔细检查

if it's lazy loaded or not you can go to
如果是懒惰，您可以去

the network tab in here and actually
此处的网络选项卡和实际上

refresh you're going to find all the
刷新您将找到所有的

javascripts in here being loaded for you
这里为您加载的JavaScript

but if you actually go ahead and clear
但是，如果您实际上继续并清除

and try to click on open model you're
并尝试单击打开模型

going to find the model j GSX only gets
要找到模型J GSX只能获得

loaded when you click on the open model
单击打开模型时已加载

button which means it's being lazy
按钮意味着它很懒惰

loaded and have our react code split in
已加载并将我们的React代码分开

work as charm fourth question is what is
作为魅力的第四个问题是什么是

the best way to add a global store to
将全球商店添加到

react out for project and I think the
为项目做出反应，我认为

best answer for this kind of question is
这种问题的最佳答案是

it depends on exactly what library the
这完全取决于哪个库

team wants to use for of course managing
团队当然想使用

the global State because there are so
全球国家，因为有这样的

many libraries and actually depends on
许多图书馆，实际上取决于

exactly the circumstances and what the
确切的情况以及什么

team wants and what actually works best
团队想要，什么实际效果最好

for the projects and of course the two
对于项目，当然是两个

most used and frequent libres in here
这里最常用和频繁的库

and I'm going to talk talk about the
我要谈谈

first one here because that's pretty
第一个在这里，因为那很漂亮

much used everywhere which is Redux and
到处都是redux和

I know a lot of you actually already
我认识你们很多人

know Redux and probably like 90% of the
知道Redux，可能是90％

time Redux is going to be the answer for
时间Redux将成为答案

most of the questions like that so Redux
大多数类似的问题如此redux

is pretty good it's pretty accurate it's
很好，它非常准确

it's wild and it's Ed everywhere it's
它是狂野的，到处都是

easy to integrate and everything or the
易于整合，一切或

second one which is actually coming
第二个实际上即将来临

really really well like these last days
就像这些末日真的很好

it's called Zeus which is very integrate
它叫宙斯，非常集成

to work with reacts and react Hooks and
与反应和反应钩一起工作，

everything and it's super super simple
一切都超级简单

to use and set up in just couple of
仅在几对中使用并设置

seconds so we're going to start with
几秒钟，所以我们将从

Redux in here for Redux there's actually
Redux在这里用于Redux实际上有

a Redux toolkit which is another library
Redux工具包，这是另一个库

that uses Redux behind the scenes but
它在幕后使用Redux，但是

actually provides option sort of setup
实际提供了设置的选项

that I to easy setup Redux because Redux
我可以轻松设置redux，因为redux

is a little harder and actually has some
有点困难，实际上有一些

dependency to on everything but using
依赖一切，但使用

Redux toolkit is going to be super easy
Redux工具包将非常简单

straightforward for you to set up and
直接为您设置和

actually use Redux inside of your
实际使用您的内部redux

projects so for instance in here for our
例如，在这里为我们的项目

projects in here we have two
在这里我们有两个

implementations so Redux in here for
实现在这里如此重视

simply what you need to do is actually
只是您需要做的就是

create first a slice so of course after
首先创建一个切片

installing Redux toolkit and everything
安装Redux工具包和所有内容

you have to install Redux toolkit and
您必须安装redux工具包

you actually go ahead and create a slice
您实际上继续创建一个切片

it's sort of like a slice of your Global
有点像您的全球片

store so you imagine your Global store
存储，所以您想象您的全球商店

has many slices and each slice in here
这里有很多切片，每个切片

is just like an object that has a lot of
就像一个有很多的对象

properties and function or particular
属性和功能或特定的功能

methods so for example in here I've got
例如，例如在这里我有

theme slice which is has a name has an
主题切片的名称有一个

initial state with a mode light in here
最初的状态在此处具有模式灯

whether it could be dark or light theme
无论是黑暗的还是轻的主题

and it has some reducers in here now
现在这里有一些还原器

reducers are simply methods that
还原器只是一种方法

actually are going to be cool by the
实际上会很酷

react component actually trigger a state
反应组件实际触发状态

change in here which means going they
在这里改变，这意味着他们

change for example the mode in here from
例如，更改此处的模式

light to dark or vice versa so you
光到黑暗，反之亦然，所以你

simply create the St in here you create
只需在这里创建ST您创建

another file that's called store and you
另一个称为商店的文件，您

actually import that reducer of course
实际上是导入那个还原器的

you do export default theme slice
您确实导出默认主题切片

reducer you grab it in here to configure
还原器您在这里抓住它以配置

store from the Redux JS 2 Kit that's
来自Redux JS 2套件的存储

going to actually you create a store for
实际上您要为

and of course you can add in here as
当然，您可以在这里添加

many slices as you want and once you
随心所欲，一旦您需要

have got the store you go ahead and
已经让您继续前进的商店

actually import a provider from react
实际上从React导入提供商

Redux which of course you need to
redux当然您需要哪个

install as well as well and you do
也安装

provider you provide the store you just
提供者您提供的商店

created in here and you provide all your
在这里创建，您提供所有

elements that you want to use or have
您要使用或拥有的元素

access to that particular store like for
访问该特定商店（例如

example the theme Toggler in here and
示例此处的主题切换器

the theme Toggler is actually of course
主题Toggler实际上是

our component that wants to have access
我们想要访问的组件

to our Global store which can actually
到我们的全球商店实际上可以

go ahead and use this two which is use
继续使用这两个使用

selector to actually select a slice of
选择器实际选择一个切片

the state for example it's going to have
例如，国家将拥有

full access to the state you can access
您可以访问的状态完全访问

the mode from our theme slice or the
我们主题切片或

dispatch in here to actually to dispatch
在这里派遣实际派遣

an action of course those actions in
当然是这些行动的行动

here can be imported as well from the
这里也可以从

theme slides in here the actions you
主题幻灯片在这里您的动作

just created as well so you do dispatch
刚刚创建的

tole theme in here and whenever this
每当这里和此处的主题

change theme in here is going to be
在这里改变主题将是

called which is called exactly when the
何时呼叫，当

input is checked in here like a check
输入像检查一样在这里检查

boox when it's checked it's going to
BOOX检查时将

change the theme from light to dark or
将主题从光更改为黑暗或

vice versa and that's what you're going
反之亦然，这就是你要去的

to get in here for example dark mode in
要进入这里，例如黑暗模式

here if you click on this it's going to
在这里，如果您单击此信息

activate the dark mode in here if you
如果您在这里激活黑暗模式

click on it it's going to deactivate and
单击它将停用和

back and forth in here and all the data
在这里和所有数据中来回来回

in here the whole state is saved on a
在这里，整个状态都保存在

Global store and any component any time
全球商店和任何组件随时

can access that piece of state now if
如果现在可以访问该状态

you want to use Zeus that's basically
您想使用基本上是宙斯

the same thing but it's actually a lot
同一件事，但实际上很多

simpler so Zoo here you just install zo
更简单，所以动物园在这里您只需安装ZO

stand you import the create function in
站在您中导入创建功能

here you do create you're going to have
在这里，您会创建您将拥有

a set and get function and this just
设置并获得功能，这只是

basically you return an objects and
基本上，您返回一个对象，

inside of that object you put all your
在那个物体的内部，你把所有的东西都放在

properties in here which going to be of
这里的属性

course going to represent the state for
课程将代表国家

example the mode in here could be light
示例此处的模式可能很轻

or dark and you can of course put all
或黑暗，你当然可以把一切

your methods inside the methods actually
实际上您的方法实际上

going to toggle or be able to access and
要切换或能够访问和

actually change the state for example
例如，实际更改状态

this toggle thing is actually going to
这个切换的东西实际上要去

go with the set and it's going to set
使用该套装，它将设置

the mode depending on exactly what is
该模式取决于确切的是什么

the current one is kind of like inverse
当前有点像逆

it and the same thing in here for the
它和这里的同一件事

zeen theme Toggler the component here
zeen主题在此处旋转组件

that has access to this you just do use
可以访问这个，您只使用

up store which is our you know hook we
UP商店，这是我们的您知道我们的钩子

created using the create method from
使用创建方法创建的创建方法

Zain and we just do use up story We
Zain和我们只是用尽了故事

ground the state in here we ground the
在这里扎根状态，我们将

mode and we do toggle theme in here to
模式，我们确实在此处切换主题

actually access to the toggle function
实际访问切换功能

and whenever we call it that's actually
每当我们称其为实际上是

going to toggle the theme and actually
要切换主题，实际上

change that on the zoen store and of
在Zoen商店和

course for zoen you can basically create
Zoen课程您基本上可以创建

as many stores as you want all of them
尽可能多的商店

are very lightweight very independent
非常轻巧非常独立

and they work perfectly and of course as
它们的工作完美，当然是

I said Global State Management in react
我说过全球国家管理

is is a vast thing with many libraries
有很多图书馆是一件巨大的事情

and many options to choose from and to
以及许多选择和选择

do with depending on the main goal of
取决于主要目标

your project and your team and of course
您的项目和团队，当然还有

your preference as well Fifth and the
您的偏好也是第五和

last question in here let's say for
这里的最后一个问题是说

example we ask you to give me an example
例如，我们请您给我一个例子

of a basic react SSR implementation so
基本的React SSR实施

always in the react real in here
总是在这里真实的反应

whenever we talk about SSR the first
每当我们谈论第一个SSR时

thing that comes to our head is actually
实际上是我们脑海中的事情

basically the nextjs framework which is
基本上是NextJS框架

a huge framework used by millions of
数百万使用的巨大框架

developers out there that does SSR and
在那里做SSR和的开发人员

it does it perfectly with so many great
它与这么多伟大的完美作用

features so maybe you want to outline
功能，也许您想概述

that there's type of Frameworks that
有类型的框架

already does sosa like NEX GS or remix
已经做了SOSA，例如Nex GS或Remix

or something like that and you outline
或类似的东西，你概述了

this like very bake Frameworks and of
这就像非常烘烤的框架和

course you can give him a very
当然，你可以给他一个

simplified version of of an SSR react
SSR React的简化版本

application with like nodejs expressjs
使用nodejs expressjs应用

with react so for example you have a
用反应如此，例如你有一个

simple project in here that does show
这里的简单项目确实显示

how SSR works and I said before SSR is
SSR的工作方式，我在SSR之前说过

just like server side rendering so it
就像服务器端渲染一样

has to involve a server behind the
必须涉及服务器后面的服务器

scenes that actually compiles your react
实际上编译您的React的场景

code and send it back to the client or
代码并将其发送回客户或

the browser to render that particular
浏览器渲染该特定的

react code so in here to have SSR you
反应代码因此在这里让您有SSR

have to set up a simple project that
必须建立一个简单的项目

uses expressjs and react and you
使用Expressjs和React和您

basically install a couple of
基本上安装了几个

dependencies like Express reacts react
诸如Express React的依赖性反应

Dom and here I chose to use es build in
dom，在这里我选择使用ES构建

here to compile our project of course
在这里编译我们的项目

you can use whatever you want you can
您可以使用任何想要的东西

use weback Babble but I think es build
使用Weback Babble，但我认为ES建造

is really perfect for that kind of case
对于这种情况来说真的很完美

scenario cuz actually basically can
场景实际上基本上可以

compile everything very easy and has a
编译所有内容非常容易，并且有一个

super easy API to follow and work with
超级简单的API可以跟随并使用

so I would really recommend going with
所以我真的建议您去

that if you want to implement this in an
如果您想在

interview next in here you just simply
接下来，您只是简单地

have a react or a simple expressjs
有一个反应或简单的expressjs

application in here that you know serves
您知道服务的申请

static files from the disc in here and
来自此处的光盘的静态文件，

actually uses the outer in here to do up
实际上使用此处的外部来做

don't get to serve our react component
不要为我们的反应组成部分服务

and HTML file in here whenever the
和HTML文件在此处

server is hit so here we saying it on
服务器被击中，所以我们在这里说

the roots of the server you Roots you
您扎根的服务器的根源

run of the server we're going to go
服务器运行我们将要去

ahead and read the file which is the
前方并阅读文件

index.html which is right over here
就在这里的index.html

inside of the public and of course this
在公众内部，当然

is just a simple index. htmo in here
只是一个简单的索引。 HTMO在这里

that has basically nothing but it has
基本上什么都没有

this ID in here root which of course
此ID在这里词根当然是

we're going to render our component that
我们将渲染我们的组件

are inside of the SRC right inside of it
在SRC内部的内部

so we're going to use server in here I'm
所以我们将在这里使用服务器

going to read the data from the
要从

index.html in here going to grab the
index.html在这里抓住

data we make sure there's no error and
数据我们确保没有错误，并且

last B is going to render do like
最后B将渲染喜欢

response send and here we're going to
回复发送，我们要在这里

replace the root element in here with
用这里替换此处的根元素

the root element but this is actually
根元素，但实际上是

the important part in here you have to
您必须在这里重要的部分

focus on where you do react do server
专注于您的do do do服务器的位置

which is you imported from react dor
您是从React Dor导入的

for/ server and you call the render to
对于/服务器，您将渲染称为

string which is a method provided by the
字符串是由

react team in here to be able to render
React团队在这里能够渲染

your react components into a string that
您的反应组件成一个字符串

could be sent back from a server
可以从服务器发送回

response so that means render your
回应，这意味着渲染您的

string in here it takes a react
在这里的绳子需要一个反应

component like our application in here
像我们在此处的应用程序这样的组件

and of course our up. GSX in here has a
当然还有我们的起诉。 GSX在这里有一个

simple react component that uses states
使用状态的简单反应组件

that renders a simple GSX in here it
这在这里呈现一个简单的GSX

uses on click pretty much anything where
在点击几乎任何东西

you Bally do react normal stuff and you
你做反应正常的事情，你

just render that one and of course here
只是在这里渲染那个

is going to be converted into a string
将转换为字符串

and it's going to be sent back from the
它将从

server to the client so the browser can
服务器到客户端，以便浏览器可以

render our website and here of course
渲染我们的网站，当然在这里

you just do listing and P for example
您只需列表和p

3,000 or something to start the server
3,000或启动服务器的东西

now another crucial part here is
现在这里的另一个关键部分是

actually to make sure you build your
实际是为了确保您建立自己的

server and client in here using ES build
服务器和客户端在此处使用ES构建

otherwise they won't work and won't
否则他们不会工作，不会

compile so you have to just go ahead and
编译，因此您只需要继续

do build client in here like we have
像我们一样在这里建立客户

scripts in here I'm using ES build to
脚本在这里我正在使用es Build to

build the index GS in here and the
在此处构建索引GS和

server and actually bundle them out
服务器并实际将它们捆绑

inside of the build directory so later
在构建目录的内部，以后

on I can use the start script in here to
我可以在此处使用“开始”脚本

basically start our Express GS server so
基本上启动我们的Express GS服务器

simply just do y build server that's
只是做y构建服务器

going to build your server and yourn
要构建服务器和您的服务器

build client as well and last but not
也建立客户，最后但不是

least you just do yarn start to start a
至少您只需纱线开始启动

server it's going to be listed in on
服务器将在ON中列出

3000 now if you go to local 3000 you
现在3000如果您去本地3000

click on it you're going to get your
单击它，您将获得您的

react application in here that is server
React应用程序在这里是服务器

side rendered and of course it works
侧面渲染，当然可以

perfectly whenever for example you click
例如，只要您单击

on the button the state and the counter
在状态和柜台的按钮上

changes perfectly and as a proof to make
完美的变化，作为证明

sure that it's actually really server
确保它实际上是服务器

side redt it's not like a client side
雷德（Redt）不像客户端

application or something and to Showcase
应用程序或其他东西展示

to the interviewer that you basically
给您基本上的面试官

understand exactly what's happening
确切了解发生了什么

you're not just copy pasting code like
您不仅复制粘贴代码

chat GPC or something so you go to the
聊天GPC之类的东西，所以您去

network tab in here and actually head
网络标签在这里，实际上

over to the Local Host which is of
到本地主机

course where you know the main HTML gets
当然，您知道主HTML获得的地方

returned back so you go to Local Host in
返回，所以您回到本地主持人

here make sure you know this is the root
在这里确保您知道这是根源

of your website you go to preview this
在您的网站上，您要预览这个

actually the HTML that's returned back
其实返回的HTML

from the server and rendered on the
从服务器上渲染

browser you go to response and you look
浏览器您要进行回复，然后看

at the htmo in here that's exactly the
在这里的HTMO，正是

htmo you have so it has the root in here
htmo你有，所以它有根源

but if you see in here that's actually
但是，如果您在这里看到，那实际上是

was rendered by react so this is
是由React渲染的，所以

actually our react component our
实际上我们的反应组件我们

component particularly that was rendered
尤其是渲染的组成部分

right over here that means server side
就在这里意味着服务器端

rendered and of course this was sent
渲染，当然是发送的

back from the server so that works
从服务器返回以便有效

perfectly and later on of course if you
当然，如果你是完美的，以后

notice in here we've got a bundle.
请注意，在这里我们有一捆。

JavaScript in here that gets sent back
javaScript在这里发送回来

and this bundle. JavaScript is actually
和这个捆绑包。 JavaScript实际上是

what makes this particular button in
是什么使此特定按钮在

here Works where hydration Works
在这里工作的地方有效

particularly like you can click on the
特别喜欢您可以单击

button and have this JavaScript work
按钮并进行此JavaScript工作

this bundle JS is very crucial of course
当然，这个束JS非常重要

this bundle JS is actually what gets
这个捆绑js实际上是得到的

compiled using bundle or build client in
使用捆绑包或建立客户端编译

here es build and you build the index.js
在这里构建，您可以构建index.js

in here and if you look at the index.js
在这里，如果您查看index.js

it has and it uses a special function
它有并且使用特殊功能

and you also to make sure you actually
而且您也要确保您实际上

note that one is it uses the reactdom
请注意，它是使用反应的

hydrate and it takes the root node for
水合物，它为根节

react up in here or you know the main
在这里做出反应，否则您知道主要

component that was rendered before on
之前渲染的组件

the server you have to provide the one
您必须提供一台服务器

here as well and you provide the node
也在这里，您提供节点

where it was render it before and have
它以前是在哪里渲染的

that's actually inside of the root node
实际上是在根节点的内部

and that will all the way to hydrate and
这将一直保持水分和

actually activate the JavaScript with
实际上用

the rendered HTML from the server so the
从服务器渲染的HTML，因此

JavaScript can work and of course can
JavaScript可以工作，当然可以

make your application interactive by you
使您的应用程序由您互动

know of course you can click on the
知道当然可以单击

buttons in here you can change and you
您可以更改此处的按钮，您

can have everything working as expected
可以使一切都按预期工作

with JavaScript so that was the most
使用JavaScript，这是最重要的

frequent reacts interview questions in
经常反应采访问题

here so thank you guys for watching
在这里，谢谢你们看的

really hope you guys enjoyed let me know
真的希望你们喜欢让我知道

in the comments if you really like this
在评论中，如果您真的很喜欢

video I can do more frequent reacts or X
视频我可以做更多频繁的反应或x

technology sort of questions for your
技术的问题

interviews and stuff anyway guys see you
访谈和东西无论如何都看到你

hopefully in the next one
希望在下一个

----------------------

[The React Interview Questions You need to Know](https://www.youtube.com/watch?app=desktop&v=3BN-YHcJfOY&sttick=0)
![](Pasted%20image%2020250911100428.png)
如果我提供时间戳，你能帮我整理吗？
能否给我一些整理视频要点的建议？
你能教我如何高效整理视频内容吗？

以下是根据你提供的 PDF 内容整理的 React 面试问题笔记，按时间戳分段，结构清晰，便于复习和快速查找：

| 时间戳          | 问题/主题                 | 核心要点                                                                 | 解题思路                                       | 代码示例要点                                                                 |
|-----------------|--------------------------|--------------------------------------------------------------------------|------------------------------------------------|-----------------------------------------------------------------------------|
| 00:00–02:56     | 子组件向父组件传递数据         | 通过回调函数将子组件数据传回父组件                                                 | 父组件定义状态和回调，通过 props 传递给子组件，子组件触发回调并传值             | `const [data, setData] = useState()`<br>`<Child sendData={handleDataFromChild} />`<br>`onChange={e => props.sendData(e.target.value)}` |
| 02:57–05:29     | 使用 Portal 渲染到组件树外部    | **Portal** 允许将子组件渲染到 DOM 树中的其他位置                                      | 使用 `ReactDOM.createPortal` 指定目标 DOM 节点                          | `ReactDOM.createPortal(<p>Hello</p>, document.getElementById('modal'))`           |
| 05:30–10:05     | 代码分割与懒加载（Lazy + Suspense） | **Lazy loading** 延迟加载组件代码，减少初始包大小                                      | 使用 `React.lazy` 动态导入组件，`Suspense` 提供加载中的回退 UI              | `const Model = lazy(() => import('./Model'))`<br>`<Suspense fallback={<div>Loading...</div>}><Model /></Suspense>` |
| 10:06–15:00     | 全局状态管理（Redux vs Zustand） | **Redux**（常用）和 **Zustand**（轻量简单）是常见选择                                | Redux 需配置 store、slice、provider；Zustand 使用 `create` 创建 store，直接使用 hook | Redux: `createSlice`, `configureStore`, `Provider`<br>Zustand: `create((set) => ({ mode: 'light', toggle: () => set(...) }))` |
| 15:01–21:26     | 服务端渲染（SSR）基本实现       | **SSR** 在服务器端生成 HTML，发送到客户端                                            | 使用 Express + `ReactDOMServer.renderToString` 渲染组件为字符串并返回      | `ReactDOMServer.renderToString(<App />)`<br>客户端使用 `hydrateRoot` 进行水合           |
