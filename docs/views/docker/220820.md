---
title: docker - 9 | 对象存储优化
date: 2022-08-20
tags:
 - docker
categories: 
 - docker
---
 



## 总结




## 1. 对象存储优化
![](./220820/1.png)    
当公司内将一个静态资源部署云服务的前端项目持续跑了 N 年后，部署了上万次后，可能出现几种情况。
1. 时间过长：如构建后的资源全部上传到对象存储，然而有些资源内容并未发生变更，将会导致过多的上传时间。
2. 冗余资源：前端每改一行代码，便会生成一个新的资源，而旧资源将会在 OSS 不断堆积，占用额外体积。 从而导致更多的云服务费用。



## 2. 静态资源上传优化: 按需上传与并发控制
在前端构建过程中存在无处不在的缓存
1. 当源文件内容未发生更改时，将不会对 `Module` 重新使用 `Loader` 等进行重新编译。这是利用了 webpack5 的持久化缓存。
2. 当源文件内容未发生更改时，构建生成资源的 `hash` 将不会发生变更。此举有利于 HTTP 的 `Long Term Cache`（强缓存）。


### 2.1 对比 
通过对比，如果未改变则不向 OSS 进行上传操作。这一步将会提升静态资源上传时间，进而提升每一次前端部署的时间。      

对比依据：
- 带有 `hash` 的文件：不存在该文件名，则上传。
- 不带有 hash 的文件：对该 Object 设置一个自定义头部，例如X-OSS-META-MTIME 或者 X-OSS-META-HASH，有区别则上传。

通过阿里云或华为云的 `node SDK`，进行操作。
```javascript
// 伪代码
/* 判断文件 (Object)是否在 OSS 中存在 */
async function isExistObject (objectName) {
  try {
    await client.head(objectName)
    return true
  } catch (e) {
    return false
  }
}
```


### 2.2 按需上传、设置缓存策略
根据有无 `hash` 设置对应的缓存策略。      
```javascript
/**
 * 上传文件，设置对应缓存策略
 * @param {String} objectName  文件路径
 * @param {Boolean} withHash  该文件名是否携带 hash 值
 */
async function uploadFile (objectName, withHash = false) {
  const file = resolve('./build', objectName)
  // 如果路径名称不带有 hash 值，则直接判断在 OSS 中不存在该文件名，需要重新上传
  const exist = withHash ? await isExistObject(objectName) : false
  if (!exist) {
    const cacheControl = withHash ? 'max-age=31536000' : 'no-cache'
    // 为了加速传输速度，这里使用 stream
    await client.putStream(objectName, createReadStream(file), {
      headers: {
        'Cache-Control': cacheControl
      }
    })
    console.log(`Done: ${objectName}`)
  } else {
    // 如果该文件在 OSS 已存在，则跳过该文件 (Object)
    console.log(`Skip: ${objectName}`)
  }
}
```




### 2.3 并发控制
可以通过 [p-queue](https://github.com/sindresorhus/p-queue) 控制资源上传的并发数量
```javascript
import PQueue from 'p-queue'
import readdirp from 'readdirp'

const queue = new PQueue({ concurrency: 10 })

for await (const entry of readdirp('./build', { depth: 0, type: 'files' })) {
  queue.add(() => uploadFile(entry.path))
}
```




## 3. Rclone: 按需上传

[Rclone](https://github.com/rclone/rclone)，`rsync for cloud storage`，是使用 Go 语言编写的一款高性能云文件同步的命令行工具，可理解为云存储版本的 `rsync`，或者更高级的 `ossutil`。

它支持以下功能:
1. 按需复制，每次仅仅复制更改的文件
2. 断点续传
3. 压缩传输

> 选择阿里云 oss 作为云存储时，配置时其 type 为 s3，其 provider 为 Alibaba，详见文档

```bash
# 将资源上传到 OSS Bucket
# alioss: 通过 rclone 配置的云存储名称，此处为阿里云的 oss，个人取名为 alioss
# shanyue-cra: oss 中的 bucket 名称
$ rclone copy --exclude 'static/**' --header 'Cache-Control: no-cache' build alioss:/shanyue-cra --progress 

# 将带有 hash 资源上传到 OSS Bucket，并且配置长期缓存
$ rclone copy --header  'Cache-Control: max-age=31536000' build/static alioss:/shanyue-cra/static --progress
```


为了方便，将两条命令维护到 `npm scripts` 中
```json
{
  "scripts": {
    "oss:rclone": "rclone copy --exclude 'static/**' --header 'Cache-Control: no-cache' build alioss:/shanyue-cra --progress && rclone copy --header  'Cache-Control: max-age=31536000' build/static alioss:/shanyue-cra/static --progress",
  }
}
```



## 4. 删除 OSS 中冗余资源
在生产环境中，OSS 只需保留最后一次线上环境所依赖的资源。(多版本共存情况下除外)
此时可根据 OSS 中所有资源与最后一次构建生成的资源一一对比文件名，进行删除。
```javascript
// 列举出来最新被使用到的文件: 即当前目录
// 列举出来OSS上的所有文件，遍历判断该文件是否在当前目录，如果不在，则删除
async function main() {
  const files = await getCurrentFiles()
  const objects = await getAllObjects()
  for (const object of objects) {
    // 如果当前目录中不存在该文件，则该文件可以被删除
    if (!files.includes(object.name)) {
      await client.delete(object.name)
      console.log(`Delete: ${object.name}`)
    }
  }
}
```

命令维护到 `npm scripts` 
```json
{
  "scripts": {
    "oss:prune": "node scripts/deleteOSS.mjs"
  }
}
```

而对于清除任务可通过定时任务周期性删除 `OSS` 上的冗余资源，比如通过 `CRON` 配置每天凌晨两点进行删除。由于该脚本定时完成，所以无需考虑性能问题，故不适用 p-queue 进行并发控制        
而有一种特殊情况，可能不适合此种方法。生产环境发布了多个版本的前端，如 AB 测试，toB 面向不同大客户的差异化开发与部署，此时可针对不同版本对应不同的 output.path 来解决。        
> output.path 可通过环境变量注入 webpack 选项，而环境变量可通过以下命令置入。(或置入 .env)

```bash
export COMMIT_SHA=$(git rev-parse --short HEAD)

export COMMIT_REF_NAME=$(git branch --show-current)
export COMMIT_REF_NAME=$(git rev-parse --abbrev-ref HEAD)
```


## 疑问
- [ ] x



## 遗留
- [ ] x


## 提问
- [ ] 使用 rclone 上传文件至 oss/cos
- [ ] 使用 rclone 部署自己的博客
- [ ] 针对你们项目静态资源的存储及上传做了那些优化


个人github：[**https://github.com/zhengjiabo**](https://github.com/zhengjiabo) 