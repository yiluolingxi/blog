---
title: vue-next release 打包发布vue源码阅读
date: 2021-09-06
tags:
 - 源码阅读      
categories: 
 - frontEnd
---

## 疑问
1. 发布流程的步骤是？
2. 如何应用到我目前的项目
3. 放在公共组件库和具体项目有什么具体区别吗

   
## 1 引用模块

### 1.1 minimist 参数解析器  


```javascript
/**
 * process.argv
 * 第一个参数 process.execPath Node.js。进程的可执行文件的绝对路径名 
 * 第二个元素将是正在执行的 JavaScript 文件的路径
 * 其余元素将是任何其他命令行参数
 **/
var argv = require('minimist')(process.argv.slice(2)); // 提取参数
```

```javascript
/**
 * var argv = parseArgs(args, opts={})
 * 
 * 类似数字的参数都会以数字返回
 * --之后的参数都不会被解析，都会放在_中
 * _: 没有与之相关的选项存放点
 * */

// 例子
var argv = require('minimist')(process.argv.slice(2));

$ node example/parse.js -a beep -b boop
// { _: [], a: 'beep', b: 'boop' }

$ node example/parse.js -x 3 -y 4 -n5 -abc --beep=boop foo bar baz
/* {
  _: [ 'foo', 'bar', 'baz' ],
  x: 3,
  y: 4,
  n: 5,
  a: true,
  b: true,
  c: true,
  beep: 'boop' 
} */

```
    
更多可以参考 **minimist**[<sup id="$1">1</sup>](#1)

```javascript
const args = require('minimist')(process.argv.slice(2))

const preId =
  args.preid ||
  (semver.prerelease(currentVersion) && semver.prerelease(currentVersion)[0])
const isDryRun = args.dry
const skipTests = args.skipTests
const skipBuild = args.skipBuild

// 源码在这就解析参数, 并将一部分参数变量赋值
```
### 1.2 path 路径
path.resolve([...paths])    
从右到左，将路径或路径片段的序列解析为绝对路径    
如果没有传入 path 片段，则 path.resolve() 返回当前工作目录的绝对路径。

```javascript
path.resolve('/foo/bar', './baz');
// 返回: '/foo/bar/baz'  绝对路径,相对路径

path.resolve('/foo/bar', '/tmp/file/');
// 返回: '/tmp/file'  绝对路径,绝对路径 绝对路径覆盖

path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');
// 相对路径,相对路径,相对路径
// 如果当前工作目录是 /home/myself/node，
// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif'
```


### 1.3 fs 文件系统

```javascript

/**
 * __dirname 当前模块的目录名，绝对路径
 * 例：有文件/Users/mjr/example.js  运行 node example.js
 * console.log(__dirname); //  /Users/mjr
 **/

/**
 * fs.readdirSync(path[, options]) 读取目录的内容
 * options:
 *  encoding      默认值: 'utf8' 指定编码
 *  withFileTypes 默认值: false  设置为 true，则结果将包含 <fs.Dirent> 对象
 * 
 **/

const fs = require('fs')
const packages = fs
  .readdirSync(path.resolve(__dirname, '../packages'))
  .filter(p => !p.endsWith('.ts') && !p.startsWith('.'))
/* 
  假如当前模块在D:\\web\\items\\vue-next\\scripts，拼凑 ../packages
  readdirSync接到的参数为：D:\\web\\items\\vue-next\\packages
  读取了该路径下的目录，且过滤掉ts文件和.开头文件
  
  packages 存放了pacakges的文件名 
  ['compiler-core', 'compiler-dom', 'compiler-sfc', 'compiler-ssr', 'reactivity', 'ref-transform', 'runtime-core', 'runtime-dom', 'runtime-test', 'server-renderer', 'sfc-playground', 'shared', 'size-check', 'template-explorer', 'vue', 'vue-compat']
*/
```

更多可以参考 **fs**[<sup id="$2">2</sup>](#2)，**模块作用域**[<sup id="$3">3</sup>](#3)


### 1.4 chalk 更好看的终端文本

```javascript
const chalk = require('chalk')

const dryRun = (bin, args, opts = {}) =>
  console.log(chalk.blue(`[dryrun] ${bin} ${args.join(' ')}`), opts) // 蓝色字体

const step = msg => console.log(chalk.cyan(msg)) // 青色
```

更多可以参考 **chalk**[<sup id="$4">4</sup>](#4)


### 1.5 semver 语义化版本

```javascript
const semver = require('semver')
semver.valid('1.2.3') // '1.2.3' 返回解析后的版本，无则返回null
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true 空格和||等效  返回是否包含在表达式内
semver.gt('1.2.3', '9.8.7') // false 是否大于
semver.lt('1.2.3', '9.8.7') // true  是否小于

// The range 1.2.7 || >=1.2.9 <2.0.0 would match the versions 1.2.7, 1.2.9, and 1.4.6, but not the versions 1.2.8 or 2.0.0.

```

留空/星号/x：代表该处任意 [major, minor, patch]
```javascript
  1.2.3 - 2.3.4 := >=1.2.3 <=2.3.4
  * := >=0.0.0 (Any version satisfies)
  1.x := >=1.0.0 <2.0.0-0 (Matching major version)
  1.2.x := >=1.2.0 <1.3.0-0 (Matching major and minor versions)

  "" (empty string) := * := >=0.0.0
  1 := 1.x.x := >=1.0.0 <2.0.0-0
  1.2 := 1.2.x := >=1.2.0 <1.3.0-0
```

~ 从最右边patch开始，主要更改patch，无则更改minor，按以下顺序 [major, minor, patch]  (可理解为：保障最小更改)
1. patch有定义时，仅允许patch更改。 
2. minor有定义时，允许**patch**修改. 
3. major有定义时，允许**minor**修改. 
```javascript
  ~1.2.3 := >=1.2.3 <1.(2+1).0 := >=1.2.3 <1.3.0-0
  ~1.2 := >=1.2.0 <1.(2+1).0 := >=1.2.0 <1.3.0-0 (Same as 1.2.x)
  ~1 := >=1.0.0 <(1+1).0.0 := >=1.0.0 <2.0.0-0 (Same as 1.x)

  ~1.2.3-beta.2 := >=1.2.3-beta.2 <1.3.0-0 // 特殊：有预发布版本，1.2.3-beta.4允许，但1.2.4-beta.2不允许，因为major, minor, patch版本号不同。
```

^ 从最左边非0为标准，允许修改下一级，按以下顺序 [major, minor, patch] (可理解为：保障最大更改)
1. major有定义时，允许**minor**修改.。 
2. minor有定义时，允许**patch**修改. 
3. patch有定义时，仅允许预发布版本更改。 
```javascript
  ^1.2.3 := >=1.2.3 <2.0.0-0
  ^0.2.3 := >=0.2.3 <0.3.0-0
  ^0.0.3 := >=0.0.3 <0.0.4-0

  ~1.2.3-beta.2 := >=1.2.3-beta.2 <1.3.0-0 // 特殊：有预发布版本，1.2.3-beta.4允许，但1.2.4-beta.2不允许，因为major, minor, patch版本号不同。
```

inc 返回一个增加1的版本。根据参2类型决定是增加哪种类型。参2可选major, premajor, minor, preminor, patch, prepatch,  prerelease    

pre代表预发版本

```javascript
semver.inc('1.2.3', 'major'); // 2.0.0
// 预发布需要一个额外的标识符字符串参数，该参数将附加字符串的值作为预发布标识符.
semver.inc('1.2.3', 'major', 'beta'); // 2.0.0 结果一样，所以 非预发布就不要写参3了.
semver.inc('1.2.3', 'premajor', 'alpha'); // 2.0.0-alpha.0
semver.inc('1.2.3', 'premajor', 'beta'); // 2.0.0-beta.0

semver.inc('1.2.3', 'minor'); // 1.3.0
semver.inc('1.2.3', 'preminor', 'alpha'); // 1.3.0-alpha.0

semver.inc('1.2.3', 'patch'); // 1.2.4
semver.inc('1.2.3', 'prepatch', 'alpha'); // 1.2.4-alpha.0

semver.inc('1.2.3', 'prerelease', 'alpha'); // 1.2.4-alpha.0 
// 非预发版本，则跟prepatch调用一致。感觉调用prerelease还是保障他是预发版本吧
semver.inc('1.2.3-alpha.0', 'prerelease', 'alpha'); // 1.2.3-alpha.1  预发版本调用，预发版本+1
semver.inc('1.2.3-alpha.1', 'prerelease', 'beta'); // 1.2.3-beta.0  以新的预发版本标志从0开始了。 
```

prerelease 返回预发布组件的数组，如果不存在，则返回 null
```javascript
semver.prerelease('1.2.3-alpha.1') -> ['alpha', 1]
```

release.js源码
```javascript
const semver = require('semver')
const currentVersion = require('../package.json').version

/* code */

const preId =
  args.preid ||
  (semver.prerelease(currentVersion) && semver.prerelease(currentVersion)[0]) // 根据参数或package.json的版本号，取得预发布版本，非预发布则返回null

/* code */

// 版本增1
const inc = i => semver.inc(currentVersion, i, preId) // preId 预发布版本 

/* code */

if (!semver.valid(targetVersion)) { // 取版本号，不标准则抛异常
  throw new Error(`invalid target version: ${targetVersion}`)
}


```

更多可以参考 **semver**[<sup id="$5">5</sup>](#5)



### 1.6 enquirer 更好的交互CLI提示

单提示
```javascript
const { prompt } = require('enquirer');
 
const response = await prompt({
  type: 'input', // 用户输入
  name: 'username', // 变量名
  message: 'What is your username?' // 提示
});
 
console.log(response); // { username: 'jonschlinkert' }
```

多提示
```javascript
const response = await prompt([
  {
    type: 'input',
    name: 'name',
    message: 'What is your name?'
  },
  {
    type: 'input',
    name: 'username',
    message: 'What is your username?'
  }
]);
 
console.log(response); // { name: 'Edward Chan', username: 'edwardmchan' }
```
选择
```javascript
const { prompt } = require('enquirer');
 
const questions = [{
  type: 'select',
  name: 'color',
  message: 'Favorite color?',
  initial: 1,
  choices: ['red', 'green', 'blue']
}];
 
let answers = await prompt(questions);
console.log('Answer:', answers.color); // 根据选择 red、green、blue其一
```



release.js源码
```javascript

const versionIncrements = [
  'patch',
  'minor',
  'major',
  ...(preId ? ['prepatch', 'preminor', 'premajor', 'prerelease'] : []) // 预发布标志则多推入几个预发布选项
]

/* code  */

let targetVersion = args._[0]

if (!targetVersion) { // 未输入版本
  // no explicit version, offer suggestions
  const { release } = await prompt({ // 交互提示选择
    type: 'select',
    name: 'release', // 变量名
    message: 'Select release type',
    choices: versionIncrements.map(i => `${i} (${inc(i)})`).concat(['custom']) // 选项，release标志 (版本+1)
  })

  if (release === 'custom') { // 自定义
    targetVersion = ( // 交互提示输入
      await prompt({
        type: 'input',
        name: 'version',
        message: 'Input custom version',
        initial: currentVersion
      })
    ).version
  } else {
    targetVersion = release.match(/\((.*)\)/)[1] // 正则取出版本号
  }
}
```
更多可以参考 **enquirer**[<sup id="$6">6</sup>](#6)


### 1.7 execa 执行命令

execa(file, arguments, options?)
- file 执行文件
- arguments 参数
- options 可选项


```javascript
const execa = require('execa')

const run = (bin, args, opts = {}) =>
  execa(bin, args, { stdio: 'inherit', ...opts })
```
内容较多，需要时    
更多可以参考 **execa**[<sup id="$7">7</sup>](#7)



### 1.8 isDryRun 是否真正执行命令

根据上面了解到的内容，就很清晰知道，添加了--dry，会用打印替代执行命令（后续的发布和git操作都用到了runIfNotDry方法，在--dry下为打印），便于调试。

```javascript
const isDryRun = args.dry

if (!skipTests && !isDryRun) { // 有dry 或 skipTests 都会跳过
  // jest Facebook旗下的javascript测试框架
  await run(bin('jest'), ['--clearCache'])
  await run('yarn', ['test', '--bail'])
} else {
  console.log(`(skipped)`)
}

if (!skipBuild && !isDryRun) { // 有skipBuild 或 dry 都会跳过
  await run('yarn', ['build', '--release'])
  // test generated dts files
  step('\nVerifying type declarations...')
  await run('yarn', ['test-dts-only'])
} else {
  console.log(`(skipped)`)
}

const run = (bin, args, opts = {}) =>
  execa(bin, args, { stdio: 'inherit', ...opts })

const dryRun = (bin, args, opts = {}) =>
  console.log(chalk.blue(`[dryrun] ${bin} ${args.join(' ')}`), opts)


const runIfNotDry = isDryRun ? dryRun : run // 后续的发布和git操作用到此方法

```


### 1.9 skipTests 跳过测试

```javascript
const skipTests = args.skipTests

/* code */

if (!skipTests && !isDryRun) { // 有dry 或 skipTests 
  // jest Facebook旗下的javascript测试框架
  await run(bin('jest'), ['--clearCache'])
  await run('yarn', ['test', '--bail'])
} else {
  console.log(`(skipped)`)
}
```




### 2.0 skipBuild 跳过打包

```javascript
const skipBuild = args.skipBuild

/* code */

if (!skipBuild && !isDryRun) { // 有skipBuild 或 dry 都会跳过
  await run('yarn', ['build', '--release'])
  // test generated dts files
  step('\nVerifying type declarations...')
  await run('yarn', ['test-dts-only'])
} else {
  console.log(`(skipped)`)
}
```



### 2.1 skippedPackages 不发布的包

```javascript
const skippedPackages = []

for (const pkg of packages) { // 从packages文件夹中循环，执行发布方法
  await publishPackage(pkg, targetVersion, runIfNotDry)
}

async function publishPackage(pkgName, version, runIfNotDry) {
  if (skippedPackages.includes(pkgName)) { // 跳过不发布的包
    return
  }
  /* code */
}
```


### 2.2 getPkgRoot 获得指定包绝对路径
服务于更新包方法publishPackage，取得包目录，进而获得对应package.json文件
```javascript
const getPkgRoot = pkg => path.resolve(__dirname, '../packages/' + pkg)

// 更新版本
function updateVersions(version) {
  // 1. update root package.json  更新根目录的package.json
  updatePackage(path.resolve(__dirname, '..'), version)
  // 2. update all packages
  packages.forEach(p => updatePackage(getPkgRoot(p), version)) 
}

// 更新包
async function publishPackage(pkgName, version, runIfNotDry) {
  if (skippedPackages.includes(pkgName)) {
    return
  }
  const pkgRoot = getPkgRoot(pkgName)
  const pkgPath = path.resolve(pkgRoot, 'package.json') // 取得package.json文件
  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8')) // 读取文件后转对象
  if (pkg.private) { // 私有包不发布
    return
  

  /* code */
}
```




### 2.3 step 打印青色文本
```javascript
const step = msg => console.log(chalk.cyan(msg))

step('\nRunning tests...')

step('\nUpdating cross dependencies...')

step('\nBuilding all packages...')

step('\nVerifying type declarations...')

step('\nCommitting changes...')

step('\nPublishing packages...')

step('\nPushing to GitHub...')

step(`Publishing ${pkgName}...`)

```











## 疑问
以下是未解决或涉及内容过多，目前看不懂的。
- execa的传参，特别是 { stdio: 'inherit' } 等同于[process.stdin, process.stdout, process.stderr] or [0,1,2]，父子级别创建通道是什么意思。是node里哪个方面的知识点


## 参考资料
- <span id="1"></span>[1] [minimist：https://www.npmjs.com/package/minimist](https://www.npmjs.com/package/minimist) ===> [back](#$1)
- <span id="2"></span>[2] [fs：http://nodejs.cn/api/fs.html](http://nodejs.cn/api/fs.html) ===> [back](#$2)
- <span id="3"></span>[3] [模块作用域：http://nodejs.cn/api/modules.html](http://nodejs.cn/api/modules.html) ===> [back](#$3)
- <span id="4"></span>[4] [chalk：https://github.com/chalk/chalk](https://github.com/chalk/chalk) ===> [back](#$4)
- <span id="5"></span>[5] [semver：https://github.com/npm/node-semver](https://github.com/npm/node-semver) ===> [back](#$5)
- <span id="6"></span>[6] [enquirer：https://www.npmjs.com/package/enquirer#select-prompt](https://www.npmjs.com/package/enquirer#select-prompt) ===> [back](#$6)
- <span id="7"></span>[7] [execa：https://www.npmjs.com/package/execa](https://www.npmjs.com/package/execa) ===> [back](#$7)

个人github：[**https://github.com/zhengjiabo**](https://github.com/zhengjiabo) 