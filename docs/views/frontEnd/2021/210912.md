---
title: Generator 函数
date: 2021-09-12
tags:
 - ES6     
categories: 
 - frontEnd
---

## 1. 学前疑问
学习co库时，提及了co库是用于 Generator 函数的自动执行。便带着疑问来学习Generator，目前有以下疑问
1. Generator是什么
2. 其解决了什么问题 或者 其是什么场景下的最优解





## 2. 初步了解
通过翻阅 **阮一峰老师 Generator 函数的语法**[<sup id="$1">1</sup>](#1)    
可以大概理解它是个状态机，在函数内封装了多个状态，通过调用 **next()** 方法，会依次返回状态值。    
状态值通过 **yield** 字段来定义，每次调用next()方法便会从函数头部或上一次停下来的地方开始执行，遇到下个yield字段或return便停下返回，返回一个遍历器对象（Iterator Object）。    

所以可以这么理解，yeild为暂停帧，next为播放键，每次点击播放，都会在暂停帧处停下，并返回对应参数。

```javascript
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();

hw.next()
// { value: 'hello', done: false }

hw.next()
// { value: 'world', done: false }

hw.next()
// { value: 'ending', done: true }

hw.next()
// { value: undefined, done: true }
```




## 3. 应用场景
Generator 是实现状态机的最佳结构，有以下优点
1. 状态封装在内部，无需额外的外部变量存储。
2. 状态不会被非法篡改。

```javascript
// 非Generator
var ticking = true;
var clock = function() {
  if (ticking)
    console.log('Tick!');
  else
    console.log('Tock!');
  ticking = !ticking;
}
clock()


// Generator
function* clock() {
  while (true) {
    console.log('Tick!');
    yield;
    console.log('Tock!');
    yield;
  }
}
clock.next()
```




## 4. 学习目标
知道其大概作用，以及应用场景后，想要学习更详细的内容，好在日常工作中把它应用起来。
1. 理解其原理或详细内容
2. 运用起来，写一个Demo




## 5. 详细内容

### 5.1 基础写法
Generator 函数是一个普通函数，但有几个特征：  
1. function右边有个*号（因为是普通函数，最好还是function后紧跟着*，不要中间间隔空格，虽然间隔也能正常运行）。
2. 内部使用 **yeild** 作为暂停标志或定义状态。
3. Generator函数()为一个暂缓执行函数，并不会立马执行，需要调用next方法才会真正开始执行。

```javascript
function* gen(x, y) {
  /* code */
  yield;
  /* code */
  yield;
  /* code */
  return;
}

const generator = gen();
gen.next();
```




### 5.2 yeild 暂停标志
Generator 函数返回的遍历器对象（Iterator Object），只有调用next方法才会继续遍历到下个状态，下个状态的定义便是用yeild标志，也是个暂停标志。





### 5.3 next 遍历下个状态
#### 5.3.1 遍历逻辑
跳转到下一个状态，遵循以下逻辑。    
1. 遇到 **yeild** 时，暂停后续操作，并把紧跟在yeild后的表达式，作为遍历器对象的vulue值返回。
2. 下次调用时，按照之前的位置继续执行，直至遇到下个yeild。
3. 遇到 **return** 时，停止后续操作，并把紧跟在return后的表达式，作为遍历器对象的vulue值返回，且遍历器对象的done值为true。
4. 没有 return 语句时，知道函数运行结束，返回的遍历器对象的value值为 **undefined** ，且遍历器对象的done值为true。

从以上逻辑不难看出，还是跟普通函数一样，只能执行一次 **return**，但可以有多个 **yeild**。


#### 5.3.2 传参
next(params)方法可以带一个参数，该参数就会被当作 **上一个yield表达式** 的返回值。   
其意义在于，可以在不同阶段下，传递不同的值，去调整函数的行为
```javascript
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}  
// NaN原因就是没传值 y = 2 * undefined  此时y/3就是NaN了

a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
// Started

b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```
从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。V8上直接忽略第一次使用next方法时的参数。    
但如果要让第一次使用时，便可以传参，以下可以实现
1. 需要包裹多一层，返回一个函数
2. 该函数内进行实例化，且调用第一次next
3. 将该实例返回    

只是将第一次调用封装了，所以这种实现方法，声明即执行了
```javascript
function wrapper(generatorFunction) {
  return function (...args) {
    let generatorObject = generatorFunction(...args);
    generatorObject.next();
    return generatorObject;
  };
}

const wrapped = wrapper(function* () {
  console.log('started')
  console.log(`First input: ${yield}`);
  console.log(`Second input: ${yield}`);
  return 'DONE';
});

const generator = wrapped()
// started

generator.next('hello!')
// First input: hello!
generator.next('hello!')
// Second input: hello!
```



### 5.4 常见报错
#### 5.4.1 普通函数中使用yield（需要在Generator函数中调用）
```javascript
(function (){
  yield 1;
})()
```


#### 5.4.2 普通函数使用yield另一种形式（可以使用for循环替代）
```javascript
var gen = function* () {
  [1, 2, 3].forEach(function (item) {
    yield item;
  });
};
var generator = gen();
generator.next();
// 报错


// 使用for循环替代
var gen = function* () {
  for(item of [1,2,3]) {
    yield item;
  }
};
var generator = gen();
generator.next();
```


#### 5.4.3 其它表达式中（需要加括号）
```javascript
function* demo() {
  console.log('Hello' + yield); // SyntaxError
  console.log('Hello' + yield 123); // SyntaxError

  console.log('Hello' + (yield)); // OK
  console.log('Hello' + (yield 123)); // OK
}

// 作为参数传参时无需括号，当然要保持习惯也可以加
function* demo() {
  foo(yield 'a', yield 'b'); // OK
  let input = yield; // OK
}


// 但我自己试了下，在声明foo后，执行以下代码，yield 'a'，在原传参位为undefined。不知道此种写法有什么用
function foo (a, b) {
  console.log('here', a, b);
}
var generator = demo();
generator.next(); // {value: 'a', done: false}
generator.next(); // {value: 'b', done: false}
generator.next(); 
// here undefined undefined
// {value: undefined, done: false}

```




### 5.5 Symbol.iterator
#### 5.5.1 对象添加 Iterator 接口
可以给任意一个对象的 **Symbol.iterator** 属性，赋值一个 **遍历器生成函数**， 从而使得该对象具有 Iterator 接口。   
Generator 函数就是遍历器生成函数。


```javascript
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]  可以用...有Iterator 接口的体现
```
for...of循环，扩展运算符（...）、解构赋值和Array.from都可以调用，它们都是遍历器接口。

#### 5.5.2 Generator生成的遍历器对象
Generator 函数执行后，返回一个遍历器对象。  
该遍历器对象本身也具有Symbol.iterator属性，执行后返回自身。

```javascript
function* gen(){
  // some code
}

var g = gen();

g[Symbol.iterator]() === g // true
```


### 5.6 for...of 循环无需next
可以自动遍历Generator生成的Iterator对象，且无需执行next

```javascript
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

var generator = foo()
for (let v of generator) {
  console.log(v);
}
// 1 2 3 4 5
```
特殊点：return的值，不包含在for...of中，所以6没打印出来


## 6. 

```javascript

```





## 课后疑问
1. 协程是什么，阮一峰老师 Generator 函数的语法 为什么提到携程
2. function* demo() {
  foo(yield 'a', yield 'b'); // OK
  let input = yield; // OK
}    
foo函数得到的参数为undefined，此种写法有什么场景吗？为何阮一峰老师举了这个例子。






## 参考资料
- <span id="1"></span>[1] [阮一峰老师 Generator 函数的语法：https://es6.ruanyifeng.com/#docs/generator](https://es6.ruanyifeng.com/#docs/generator) ===> [back](#$1)







个人github：[**https://github.com/zhengjiabo**](https://github.com/zhengjiabo) 