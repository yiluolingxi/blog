import time
import os
import json
import threading
import logging
import re
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import (TimeoutException, NoSuchElementException, 
                                      WebDriverException, StaleElementReferenceException)
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import pyautogui  # 用于模拟键盘和鼠标操作
import pygetwindow as gw  # 用于窗口管理

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class RelingoExporter:
    def __init__(self, root):
        self.root = root
        self.root.title("Relingo字幕导出工具")
        self.root.geometry("800x600")
        self.setup_ui()
        self.processing = False
        self.current_index = 0  # 记录当前处理的序号
        self.output_directory = ""  # 保存输出目录
        self.urls = []  # 存储URL列表
        
    def setup_ui(self):
        """初始化用户界面"""
        # 主框架
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 配置网格权重
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1极狐, weight=1)
        main_frame.rowconfigure(2, weight=1)
        
        # 标题
        title_label = ttk.Label(main_frame, text="Relingo字幕导出工具", font=("Arial", 16))
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 10))
        
        # URL输入
        url_label = ttk.Label(m极狐ain_frame, text="输入URL列表（每行一个URL）:")
        url_label.grid(row=1, column=0, sticky=tk.W, pady=(0, 5))
        
        self.url_text = scrolledtext.ScrolledText(main_frame, width=70, height=10)
        self.url_text.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        
        # 保存路径
        path_label = ttk.Label(main_frame, text="保存路径:")
        path_label.grid(row=3, column=0, sticky=tk.W, pady=(0, 5))
        
        path_frame = ttk.Frame(main_frame)
        path_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        path_frame.columnconfigure(0, weight=1)
        
        # 修改默认路径为 E:\interview
        self.path_var = tk.StringVar(value=r"E:\interview")
        path_entry = ttk.Entry(path_frame, textvariable=self.path_var, width=50)
        path_entry.grid(row=0, column=0, sticky=(tk.W, tk.E))
        
        browse_btn = ttk.Button(path_frame, text="浏览", command=self.browse_folder)
        browse_btn.grid(row=0, column=1, padx=(5, 0))
        
        # 状态显示
        self.status_var = tk.StringVar(value="就绪")
        status_label = ttk.Label(main_frame, textvariable=self.status_var)
        status_label.grid(row=5, column=0, columnspan=2, sticky=tk.W, pady=(0, 10))
        
        # 进度极狐条
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E极狐), pady=(0, 10))
        
        # 按钮
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=7, column=0, columnspan=2, pady=(0, 10))
        
        self.start_btn = ttk.Button(button_frame, text="开始处理", command=self.start_processing)
        self.start_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        exit_btn = ttk.Button(button_frame, text="退出", command=self.root.quit)
        exit_btn.pack(side=tk.LEFT)
        
        # 日志
        log_label = ttk.Label(main_frame, text="处理日志:")
        log_label.grid(row=8, column=0, sticky=tk.W, pady=(0, 5))
        
        self.log_text = scrolledtext.ScrolledText(main_frame, width=70, height=15)
        self.log_text.grid(row=9, column=0, columnspan极狐=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        self.log_text.config(state=tk.DISABLED)
    
    def browse_folder(self):
        """选择保存文件夹"""
        folder = filedialog.askdirectory(initialdir=self.path_var.get())
        if folder:
            self.path_var.set(folder)
    
    def log_message(self, message):
        """线程安全的日志记录"""
        def update_log():
            self.log_text.config(state=tk.NORMAL)
            timestamp = datetime.now().strftime("%H:%M:%S")
            self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
            self.log_text.see(tk.END)
            self.log_text.config(state=tk.DISABLED)
        self.root.after(0, update极狐_log)
        logger.info(message)
    
    def update_status(self, message):
        """更新状态信息"""
        def update_status_text():
            self.status_var.set(message)
        self.root.after(0, update_status_text)
    
    def start_processing(self):
        """开始处理URLs"""
        if self.processing:
            return
            
        urls = self.url_text.get("1.0", tk.END).splitlines()
        output_directory = self.path_var.get()
        
        # 验证输入
        if not urls or not urls[0].strip():
            messagebox.showerror("错误", "请输入至少一个URL")
            return
        
        if not output_directory:
            messagebox.showerror("错误", "请选择保存路径")
            return
        
        # 过滤空行
        urls = [url.strip() for url in urls if url.strip()]
        self.urls = urls  # 存储URL列表
        
        # 更新UI状态
        self.processing = True
        self.start_btn.config(state=tk.DISABLED)
        self.progress.start()
        
        # 在新线程中处理
        thread = threading.Thread(target=self.process_urls, args=(urls, output_directory))
        thread.daemon = True
        thread.start()
    
    def process_urls(self, urls, output_directory):
        """处理所有URLs的主函数"""
        try:
            os.makedirs(output_directory, exist_ok=True)
            self.output_directory = output_directory
            
            # 配置浏览器选项
            chrome_options = Options()
            chrome_options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
            chrome_options.page_load_strategy = 'eager'
            
            # 初始化浏览器
            driver = webdriver.Chrome(options=chrome_options)
            try:
	            driver.maximize_window()
			except Exception as e:
			    logger.info(f"窗口最大化失败，可能已是最大化状态: {e}")
			    pass  # 忽略错误，继续执行
			driver.set_page_load_timeout(30)

            # 处理每个URL
            for index, url in enumerate(urls, start=1):
                success = self.process_single_url(driver, url, index, output_directory)
                if not success:
                    self.log_message(f"警告: URL {url} 处理失败，继续下一个")
            
            # 完成所有处理
            driver.quit()
            self.log_message("所有任务已完成")
            self.root.after(0, lambda: messagebox.showinfo("完成", "所有URL处理完成!"))
            
        except Exception as e:
            self.log_message(f"处理过程中发生错误: {str(e)}")
            logger.error(f"Process error: {e}", exc_info=True)
        finally:
            self.root.after(0, self.processing_finished)
    
    def process_single_url(self, driver, url, index, output_directory, max_retries=3):
        """处理单个URL，包含重试机制"""
        self.current_index = index  # 记录当前序号
        for attempt in range(1, max_retries + 1):
            try:
                self.update_status(f"处理 {index}/{len(self.urls)} (尝试 {attempt}/{max_retries}): {url[:50]}...")
                self.log_message(f"开始处理第 {index} 个URL (尝试 {attempt}): {url}")
                
                # 导航到URL
                driver.get(url)
                self.log_message("页面加载完成")
                
                # 等待并刷新页面
                time.sleep(10)
                driver.refresh()
                self.log_message("已等待10秒并刷新页面")
                
                # 等待Relingo加载
                time.sleep(15)
                self.log_message("已等待15秒供Relingo加载字幕")
                
                # 检测Relingo容器
                if not self.detect_relingo_container(driver):
                    raise Exception("未检测到Relingo字幕容器")
                
                # 执行导出操作
                if self.execute_export_operation(driver, index, output_directory):
                    self.log_message(f"URL {url} 处理成功")
                    return True
                    
            except Exception as e:
                self.log_message(f"尝试 {attempt} 失败: {str(e)}")
                if attempt < max_retries:
                    self.log_message(f"{max_retries - attempt} 次重试剩余")
                    time.sleep(5)  # 重试前等待
                else:
                    self.log_message(f"已达到最大重试次数，放弃此URL")
        
        return False
    
    def detect_relingo_container(self, driver, timeout=25):
        """检测Relingo字幕容器"""
        try:
            container = WebDriverWait(driver, timeout).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, 'div.reling极狐o-subtitle-container'))
            )
            self.log_message("检测到Relingo字幕容器")
            
            # 等待内容加载
            WebDriverWait(driver, 15).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, 'div.rl-subtitle-content, .rl-subtitle-item'))
            )
            self.log_message("字幕内容已加载")
            return True
            
        except TimeoutException:
            self.log_message("等待Relingo容器超时")
            return False
        except Exception as e:
            self.log_message(f"检测容器时发生错误: {e}")
            return False
    
    def execute_export_operation(self, driver, index, output_directory):
        """执行导出操作序列"""
        try:
            # 1. 点击CC图标
            if not self.click_cc_icon(driver):
                return False
            
            # 2. 选择导出选项
            if not self.select_export_option(driver):
                return False
            
            # 3. 处理模态框
            if not self.handle_export_modal(driver):
                return False
            
            # 4. 等待新标签页并执行打印操作
            if not self.handle_print_operation(driver, index, output_directory):
                return False
            
            return True
            
        except Exception as e:
            self.log_message极狐(f"导出操作失败: {str(e)}")
            return False
    
    def click_cc_icon(self, driver):
        """点击CC图标"""
        try:
            # 多种选择器策略
            selectors = [
                (By.CSS_SELECTOR, 'svg.remixicon.rl-icon-cc'),
                (By.XPATH, '//*[name()="svg" and contains(@class, "rl-icon-cc")]'),
                (By.CSS_SELECTOR, '[class*="rl-icon-cc"]')
            ]
            
            for by, selector in selectors:
                try:
                    icon = WebDriverWait(driver, 10).until(
                        EC.element_to_be_clickable((by, selector))
                    )
                    icon.click()
                    self.log_message("已点击CC图标")
                    
                    # 等待菜单展开
                    time.sleep(3)
                    return True
                    
                except (TimeoutException, NoSuchElementException):
                    continue
            
            self.log_message("所有选择器都无法定位CC图标")
            return False
            
        except Exception as e:
            self.log_message(f"点击CC图标时发生错误: {str(e)}")
            return False
    
    def select_export_option(self, driver):
        """选择导出字幕选项"""
        try:
            export_selectors = [
                (By.XPATH, '//div[contains(text(), "导出字幕")]'),
                (By.CSS_SELECTOR, 'div.rl-dp-item'),
                (By.XPATH, '//div[contains(@class, "rl-d极狐p-item") and contains(text(), "导出")]')
            ]
            
            for by, selector in export_selectors:
                try:
                    option = WebDriverWait(driver, 10).until(
                        EC.element_to_be_clickable((by, selector))
                    )
                    option.click()
                    self.log_message("已点击导出字幕选项")
                    time.sleep(3)  # 等待模态框弹出
                    return True
                    
                except (TimeoutException, NoSuchElementException):
                    continue
            
            self.log_message("无法找到导出选项")
            return False
            
        except Exception as e:
            self.log_message(f"选择导出选项时发生错误: {str(e)}")
            return False
    
    def handle_export_modal(self, driver):
        """处理导出模态框"""
        try:
            # 等待模态框出现
            modal = WebDriverWait(driver, 10).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, 'div.export-caption-modal, div[class*="modal"]'))
            )
            self.log_message("导出模态框已出现")
            
            # 尝试选择格式（如果有）
            format_selectors = [
                (By.XPATH, '//div[contains(text(), "SRT")]'),
                (By.XPATH, '//div[contains(text(), "TXT")]'),
                (By.XPATH, '//div[contains(text(), "JSON")]')
            ]
            
            for by, selector in format_selectors:
                try:
                    format_option = WebDriverWait(modal, 5).until(
                        EC.element_to_be_clickable((by, selector))
                    )
                    format_option.click()
                    self.log_message("已选择导出格式")
                    time.sleep(1)
                    break
                except:
                    continue
            
            # 点击导出按钮
            export_buttons = [
                (By.CSS_SELECTOR, 'button.line-button.primary'),
                (By.XPATH, '//button[contains(text(), "导出")]'),
                (By.CSS_SELECTOR, 'button[class*="export"]')
            ]
            
            for by, selector in export_buttons:
                try:
                    export_btn = WebDriverWait(modal, 10).until(
                        EC.element_to_be_clickable((by, selector))
                    )
                    export_btn.click()
                    self.log_message("已点击导出按钮")
                    time.sleep(5)  # 等待导出操作
                    return True
                    
                except (TimeoutException, NoSuchElementException):
                    continue
            
            self.log_message("无法找到导出按钮")
            return False
            
        except Exception极狐 as e:
            self.log_message(f"处理模态框时发生错误: {str(e)}")
           极狐 return False
    
    def handle_print_operation(self, driver, index, output_directory):
        """处理打印操作流程"""
        try:
            # 等待新标签页出现
            WebDriverWait(driver, 30).until(lambda d: len(d.window_handles) > 1)
            handles = driver.window_handles
            original_window = driver.current_window_handle
            
            # 切换到新标签页
            driver.switch_to.window(handles[1])
            self.log_message("已切换到新标签页")
            
            # 等待页面完全加载
            WebDriverWait(driver, 30).until(
                lambda d: d.execute_script('return document.readyState') == 'complete'
            )
            
            time.sleep(3)  # 额外等待确保页面稳定
            
            # 获取页面标题用于文件名
            page_title = driver.title
            # 清理标题中的特殊字符
            for char in ['|', ':', '/', '\\', '<', '>', '"', '?', '*', '.']:
                page_title = page_title.replace(char, '')
            # 移除YouTube后缀
            page_title = page_title.replace(' - YouTube', '')
            # 移除多余空格
            page_title = page_title.strip()
            page_title = re.sub(r'\s+', ' ', page_title)  # 将多个空格替换为单个空格
            # 限制长度
            if len(page_title) > 100:
                page_title = page_title[:100]
            
            # 模拟Ctrl+P打印操作
            self.log_message("执行Ctrl+P打印操作")
            driver.find_element(By.TAG_NAME, 'body').send_keys(Keys.CONTROL + 'p')
            time.sleep(5)  # 等待打印对话框出现
            
            # 等待打印对话框完全加载
            time.sleep(3)
            
            # 确保选择"导出为WPS PDF"作为打印机
            self.log_message("确保选择'导出为WPS PDF'打印机")
            time.sleep(2)
            
            # 点击打印按钮
            self.log_message("点击打印按钮")
            try:
                # 使用pyautogui定位并点击打印按钮
                # 首先尝试按Enter键（打印按钮通常是默认焦点）
                pyautogui.press('enter')
                time.sleep(3)
            except Exception as e:
                self.log_message(f"键盘模拟失败: {e}")
                return False
            
            # 等待WPS PDF导出完成
            if not self.wait_for_wps_export():
                return False
            
            # 处理另存为对话框
            if not self.handle_save_dialog(index, page_title):
                return False
            
            # 关闭标签页并返回主窗口
            driver.close()
            driver.switch_to.window(original_window)
            self.log_message("已关闭新标签页并返回主窗口")
            
            return True
            
        except Exception as e:
            self.log_message(f"打印操作处理失败: {str(e)}")
            # 尝试恢复原始窗口
            try:
                handles = driver.window_handles
                if handles:
                    driver.switch_to.window(handles[0])
            except:
                pass
            return False

    def wait_for_wps_export(self, timeout=60):
        """等待WPS PDF导出完成"""
        self.log_message("等待WPS PDF导出完成...")
        start_time = time.time()
        max_wait = timeout
        
        # 等待导出进度提示出现
        time.sleep(5)
        
        while time.time() - start_time < max_wait:
            try:
                # 检查是否有"正在导出第X页为WPS PDF..."的提示
                # 这里我们主要依赖时间等待，因为GUI检测比较复杂
                time.sleep(2)
                
                # 尝试检测导出完成（通过检查是否有另存为对话框）
                # 简单的时间等待策略 - 根据图片，导出可能需要一些时间
                if time.time() - start_time > 20:  # 增加等待时间
                    self.log_message("WPS PDF导出完成")
                    return True
                    
            except Exception as e:
                self.log_message(f"等待导出时出错: {e}")
                continue
        
        self.log_message("等待WPS导出超时")
        return False

    def handle_save_dialog(self, index, page_title):
        """处理另存为对话框"""
        try:
            # 设置默认保存路径
            save_path = r"E:\interview"
            if not os.path.exists(save_path):
                os.makedirs(save_path)
            
            # 构建文件名：序号 + 原标题
            filename = f"{index} {page_title}.pdf"
            # 确保文件名以.pdf结尾
            if not filename.endswith('.pdf'):
                filename += '.pdf'
            
            full_path = os.path.join(save_path, filename)
            
            self.log_message(f"准备保存文件: {filename}")
            self.log_message(f"完整文件路径: {full_path}")
            
            # 等待另存为对话框出现
            time.sleep(5)
            
            # 导航到指定路径
            try:
                # 先按Alt+D焦点到地址栏
                pyautogui.hotkey('alt', 'd')
                time.sleep(1)
                
                # 清除路径框中的内容
                pyautogui.hotkey('ctrl', 'a')
                time.sleep(0.5)
                pyautogui.press('delete')
                time.sleep(0.5)
                
                # 输入目标路径
                pyautogui.write(save_path)
                time.sleep(1)
                pyautogui.press('enter')
                time.sleep(2)
            except Exception as e:
                self.log_message(f"导航到路径时出错: {e}")
            
            # 输入文件名
            try:
                # 按Alt+N焦点到文件名输入框
                pyautogui.hotkey('alt', 'n')
                time.sleep(1)
                
                # 清除原有内容
                pyautogui.hotkey('ctrl', 'a')
                time.sleep(0.5)
                pyautogui.press('delete')
                time.sleep(0.5)
                
                # 输入新的文件名
                pyautogui.write(filename)
                time.sleep(1)
            except Exception as e:
                self.log_message(f"输入文件名时出错: {e}")
            
            # 按回车保存
            pyautogui.press('enter')
            time.sleep(5)  # 增加等待时间
            
            # 验证文件是否真的保存成功
            if os.path.exists(full_path):
                self.log_message(f"文件已保存: {full_path}")
                return True
            else:
                self.log_message(f"文件保存失败，未找到文件: {full_path}")
                # 检查是否保存到了其他位置（如桌面）
                desktop_path = os.path.join(os.path.expanduser("~"), "Desktop")
                for file in os.listdir(desktop_path):
                    if file.startswith(f"{index} ") and (file.endswith(".pdf") or ".pdf" in file):
                        actual_path = os.path.join(desktop_path, file)
                        self.log_message(f"文件可能保存到了桌面: {actual_path}")
                        return True
                # 检查文档目录
                docs_path = os.path.join(os.path.expanduser("~"), "Documents")
                for file in os.listdir(docs_path):
                    if file.startswith(f"{index} ") and (file.endswith(".pdf") or ".pdf" in file):
                        actual_path = os.path.join(docs_path, file)
                        self.log_message(f"文件可能保存到了文档目录: {actual_path}")
                        return True
                return False
            
        except Exception as e:
            self.log_message(f"处理保存对话框时出错: {str(e)}")
            return False

    def processing_finished(self):
        """处理完成后的清理工作"""
        self.progress.stop()
        self.start_btn.config(state=tk.NORMAL)
        self.status_var.set("处理完成")
        self.processing = False

# 主程序入口
def main():
    root = tk.Tk()
    app = RelingoExporter(root)
    root.mainloop()

if __name__ == "__main__":
    main()