
| Timestamp 时间戳   | Problem/Topic 问题/主题                                    | Key Points 核心要点                                                                    | Solution Approach 解题思路                                                                                      | Code Example Points 代码示例要点                                                                                                                 | Technical Explanation 技术讲解                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| --------------- | ------------------------------------------------------ | ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **00:00–02:56** | Critical CSS  <br>关键 CSS                               | CSS needed to render above-the-fold content  <br>用于渲染首屏内容的 CSS                     | Extract critical CSS and defer non-critical CSS  <br>提取关键 CSS 并延迟加载非关键 CSS                                  | Use Webpack plugin with headless browser  <br>使用 Webpack 插件和无头浏览器  <br>CSS coverage tool  <br>CSS 覆盖率工具                                    | **Critical CSS is the name we give to the CSS Styles needed to display the elements that appear above the fold.** So basically, imagine you land on a page and you see certain elements without scrolling. The critical CSS is all the CSS we need in order to make those elements positioned and styled.  <br>**关键 CSS 是指我们为显示首屏（无需滚动即可见）元素所需的 CSS 样式起的名字。** 基本上，想象你打开一个页面，不滚动就能看到的某些元素。关键 CSS 就是为了让这些元素正确定位和样式化所需要的所有 CSS。  <br>  <br>**In order to extract it, you can use certain module bundle plugins.** Like a Webpack plugin. It will basically render the application with a headless browser in the background for a specific width. Then it would use browser mechanisms like the CSS coverage to extract the CSS rules that you need to render at that specific width.  <br>**为了提取它，你可以使用某些模块打包插件。** 例如 Webpack 插件。它基本上会在后台使用无头浏览器来渲染应用程序，并针对特定的屏幕宽度。然后，它会使用像 CSS 覆盖率这样的浏览器机制来提取在该特定宽度下渲染所需的 CSS 规则。  <br>  <br>**Once you extracted critical CSS you can use it to improve performance by deferring all the CSS except the critical CSS.** Because CSS is a render-blocking resource. Browsers try to collect all the CSS and render it before moving on with the HTML. If we have a lot of CSS, that can take a long time. So if we are able to separate and only load the critical CSS first, we can drastically improve the initial rendering performance.  <br>**一旦提取出关键 CSS，你就可以通过延迟加载所有非关键 CSS 来提升性能。** 因为 CSS 是渲染阻塞资源。浏览器会尝试收集所有 CSS 并在继续处理 HTML 之前先渲染它。如果我们有很多 CSS，这会花费很长时间。所以，如果我们能分离并优先只加载关键 CSS，就能大幅提高初始渲染性能。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| **02:56–04:28** | ARIA Attributes  <br>ARIA 属性                           | Provide accessibility info for non-semantic elements  <br>为非语义元素提供可访问性信息           | Use ARIA when semantic HTML isn’t feasible  <br>在无法使用语义 HTML 时使用 ARIA                                       | `role`, `aria-label`, etc.  <br>`role`、`aria-label` 等属性                                                                                    | **Most of the times we just want to stick to semantic HTML, that's the easiest and best way to make something accessible.** But there are some edge cases where we just cannot use semantic HTML because of design constraints or because we're building a specific widget.  <br>**大多数时候我们应该坚持使用语义化的 HTML，这是实现可访问性最简单和最好的方法。** 但是在某些边缘情况下，由于设计限制或正在构建特定的小部件，我们无法使用语义化 HTML。  <br>  <br>**In that case, you can use ARIA attributes to specify semantic accessibility roles for non-semantic HTML elements like div or span.** I would definitely use them if you have accessibility constraints and you cannot use semantic HTML.  <br>**在这种情况下，你可以使用 ARIA 属性来为非语义的 HTML 元素（如 div 或 span）指定语义化的可访问性角色。** 如果你有可访问性要求但又不能使用语义化 HTML，我肯定会使用它们。  <br>  <br>**Semantic tags like footer, header, or image are tags that have meaning and the accessibility tools understand them.** ARIA helps bridge the gap when you can't use those.  <br>**诸如 footer、header 或 image 之类的语义化标签是有含义的，辅助技术工具能够理解它们。** 当你无法使用这些标签时，ARIA 有助于弥合差距。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| **04:28–06:03** | `defer` & `async` Attributes  <br>`defer` 和 `async` 属性 | Control script loading behavior  <br>控制脚本加载行为                                      | Use `defer` for non-critical scripts, `async` for independent scripts  <br>对非关键脚本使用 `defer`，对独立脚本使用 `async` | `<script defer>`, `<script async>`  <br>`<script defer>`、`<script async>`                                                                  | **We use `defer` and `async` to control when a certain script tag will be loaded and interpreted.**  <br>**我们使用 `defer` 和 `async` 来控制特定脚本标签的加载和执行时机。**  <br>  <br>**`defer` will basically download the script in the background as we render the HTML (so we can parallelize), but it will interpret the script just before the DOMContentLoaded event, when the HTML parsing is finished.** So it executes in order, after the HTML is parsed.  <br>**`defer` 会在我们渲染 HTML 时在后台下载脚本（因此可以并行化），但它会在 HTML 解析完成时，恰好在 DOMContentLoaded 事件之前才执行脚本。** 因此它会按顺序在 HTML 解析后执行。  <br>  <br>**`async` downloads the script and interprets it as soon as possible.** It doesn't really care about when the HTML is rendered; it can finish before or after. It's pretty parallel.  <br>**`async` 会下载脚本并尽快执行它。** 它不太关心 HTML 何时渲染完成；它可能在 HTML 之前或之后完成。它的下载和执行是并行的。  <br>  <br>**As I recall, ES6 modules are deferred by default in most web browsers.**  <br>**据我所知，在大多数浏览器中，ES6 模块默认是 deferred 的。**  <br>  <br>**The main reason to use these attributes is to avoid scripts blocking the critical rendering path and have much better web performance, better initial loading.** We take all our non-critical JavaScript that we don't really need in the initial load and we push it down (defer or async it) so it doesn't block the rendering of the page.  <br>**使用这些属性的主要原因是避免脚本阻塞关键渲染路径，从而获得更好的 Web 性能，更好的初始加载。** 我们将所有在初始加载中并不真正需要的非关键 JavaScript 推迟（使用 defer 或 async），这样它们就不会阻塞页面的渲染。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| **06:03–07:18** | Dynamic Import  <br>动态导入                               | Import modules dynamically at runtime  <br>在运行时动态导入模块                              | Use dynamic imports for lazy loading or conditional loading  <br>使用动态导入实现懒加载或条件加载                           | `import('./module')`  <br>`import('./模块')`                                                                                                 | **Dynamic Imports work more like the CommonJS imports, like a function. You can think of it as a function and it will just import or fetch the module over the network.**  <br>**动态导入的工作方式更像 CommonJS 的导入，像一个函数。你可以把它看作一个函数，它会通过网络导入或获取模块。**  <br>  <br>**Whereas normal Imports are static Imports so they get interpreted at build time.** The biggest difference is that with static imports you can apply tree shaking, you can infer TypeScript types, so you have all the advantages of static analysis.  <br>**而普通的导入是静态导入，它们在构建时就被解析。** 最大的区别是，使用静态导入，你可以进行 Tree Shaking，可以推断 TypeScript 类型，因此你拥有静态分析的所有优势。  <br>  <br>**Whereas with Dynamic Imports you do not have all those advantages. But because they are like a function, you can use them in code.** You can for example use them inside if statements or switch statements.  <br>**而对于动态导入，你没有所有这些优势。但是因为它们像函数一样，你可以在代码中使用它们。** 例如，你可以在 if 语句或 switch 语句中使用它们。  <br>  <br>**So they allow you to lazy load components.** You can also load certain modules depending on a user action. So you could, for example, only load Lodash when the user does something. You can add a dynamic import that imports Lodash when the on-click event happens. So you don't need to load Lodash in the initial load which makes that initial load much faster, and it only loads that code on demand.  <br>**因此它们允许你懒加载组件。** 你也可以根据用户操作来加载特定模块。例如，你可以只在用户做某事时才加载 Lodash。你可以在点击事件发生时添加一个动态导入来导入 Lodash。这样你就不需要在初始加载中加载 Lodash，这使得初始加载更快，并且只在需要时加载那段代码。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **07:18–08:59** | CLS (Cumulative Layout Shift)  <br>累积布局偏移              | Measure of visual stability during page load  <br>页面加载期间视觉稳定性的度量                   | Identify shifting elements and stabilize them  <br>识别移动元素并使其稳定                                              | Set `width`/`height` on images, optimize fonts  <br>为图片设置 `width`/`height`，优化字体  <br>Use `font-display: swap`  <br>使用 `font-display: swap` | **CLS stands for Cumulative Layout Shift. It's one of the Core Web Vitals.** It's basically the layout shift that happens as we load the page.  <br>**CLS 代表累积布局偏移。它是核心 Web 指标之一。** 它基本上是在页面加载过程中发生的布局偏移。  <br>  <br>**Normally what would happen is we render our HTML and then maybe some Styles arrive too late, maybe some fonts or images arrive too late.** And if we haven't optimized our page well, the user will perceive that as a shift. It happens sometimes: you go to a slow page, all of a sudden an image is loaded at the top and it pushes everything to the bottom, and maybe you clicked on something but you end up clicking on something else. That would be the cumulative layout shift.  <br>**通常的情况是，我们渲染了 HTML，然后可能一些样式加载得太晚，或者一些字体或图片加载得太晚。** 如果我们没有很好地优化我们的页面，用户就会感觉到这种偏移。有时会发生这种情况：你访问一个慢速页面，突然一张图片在顶部加载完成，并把所有内容推到底部，也许你点击了某个东西，但最终却点到了别的东西。那就是累积布局偏移。  <br>  <br>**How to fix it? The first thing I would do is probably use some debugging tool to see which element has a lot of CLS.** The new Google Chrome Performance Insights does a very good job at it and they pinpoint exactly the div that's moving.  <br>**如何修复它？我要做的第一件事可能是使用一些调试工具来查看哪个元素的 CLS 很高。** 新的 Google Chrome Performance Insights 在这方面做得非常好，它们能精确定位到正在移动的 div。  <br>  <br>**There can be many different causes: it can be the font, it can be CSS loading slower... so you have different solutions.** For example, if an image is the main cause, I would add some fixed width and height attributes to this image. Then the browser would know ahead of time how big this image will be, so it would render stuff around it and you won't have CLS. If the issue is with fonts, for example, I would try to optimize the font loading, and you can also specify what would be the height of the fonts coming in versus the web browser defaults. So again, depending on the cause you'd have solutions. If it's CSS, implement critical CSS and only load the CSS we need.  <br>**可能有很多不同的原因：可能是字体，可能是 CSS 加载较慢……因此你有不同的解决方案。** 例如，如果图片是主要原因，我会给这张图片添加一些固定的宽度和高度属性。这样浏览器就会提前知道这张图片有多大，因此它会在其周围渲染内容，你就不会遇到 CLS 问题。如果问题是字体，例如，我会尝试优化字体加载，并且你还可以指定即将加载的字体的高度与浏览器默认高度的关系。所以，再次强调，根据原因你有相应的解决方案。如果是 CSS 的问题，实现关键 CSS 并只加载我们需要的 CSS。 |
| **08:59–END**   | Essential vs. Derived State  <br>基本状态与派生状态             | Essential state is independent; derived state is computed  <br>基本状态是独立的；派生状态是计算而来的 | Store only essential state, compute derived values  <br>仅存储基本状态，计算派生值                                       | Derived state: total price, item count  <br>派生状态：总价、商品数量  <br>Essential state: cart items, user input  <br>基本状态：购物车商品、用户输入                 | **As the name says, the derived state is usually state we can calculate based on other state. And essential state is state that changes independently and we cannot really calculate or deduct the value from other state variables.**  <br>**顾名思义，派生状态通常是我们可以根据其他状态计算出来的状态。而基本状态是独立变化的状态，我们无法真正从其他状态变量计算或推导出它的值。**  <br>  <br>**Essential state is either coming from user interactions or data fetching over the network.**  <br>**基本状态要么来自用户交互，要么来自网络数据获取。**  <br>  <br>**Just to give you an example: if you have a checkout page, I would say essential state is the items in the cart. Whereas the derived state is anything we need to compute based on those items, like the total price, the net price, the price with tax, how many items you have in the cart. All that would be the derived state.** It doesn't really change independently and we can derive or compute the value based on the existing essential state.  <br>**给你举个例子：如果你有一个结账页面，我会说基本状态是购物车中的商品。而派生状态是我们需要根据这些商品计算的任何东西，比如总价、净价、含税价、购物车中有多少件商品。所有这些都将是派生状态。** 它并不独立变化，我们可以根据现有的基本状态推导或计算其值。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |