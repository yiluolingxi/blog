| Timestamp 时间戳   | Problem/Topic 问题/主题                               | Key Points 核心要点                                                                                                | Solution Approach 解题思路                                                                                                                                                                  | Code Example Points 代码示例要点                                                                                                                             | Technical Explanation 技术讲解                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| :-------------- | :------------------------------------------------ | :------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **00:00–01:54** | Generic Functions<br>泛型函数                         | Write type-flexible code using type arguments<br>使用类型参数编写类型灵活的代码                                               | Define a function with type parameters (e.g., `<T>`) to be used for parameters and return types<br>使用类型参数（如 `<T>`）定义函数，用于参数和返回类型                                                        | `function myFunc<T>(arg: T): T { return arg; }`<br>`const result = myFunc<number>(123);`                                                               | **Generic functions provide a way to write code that is type flexible without using `any`. You can provide not only normal arguments but also type arguments.**<br>**泛型函数提供了一种编写类型灵活代码的方法，而无需使用 `any`。你不仅可以提供普通参数，还可以提供类型参数。**<br>**We have a function that can accept a bunch of types (e.g., T, U, K) that we can use inside the function. This means the function can work with different types. It allows whoever is using the function to provide that type as a type argument when calling it. You only know the type of the argument or the return when you use the function.**<br>**我们有一个函数可以接受许多类型（例如 T, U, K），我们可以在函数内部使用这些类型。这意味着该函数可以与不同的类型一起工作。它允许使用该函数的人在调用时将该类型作为类型参数提供。只有当你使用该函数时，你才知道参数或返回值的类型。**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **01:54–04:29** | `as const` Assertion<br>`as const` 断言             | Create deeply read-only (immutable) object structures<br>创建深度只读（不可变）的对象结构                                      | Use the `as const` suffix on an object literal to make all its properties (including nested) read-only<br>在对象字面量上使用 `as const` 后缀，使其所有属性（包括嵌套属性）变为只读                                    | `const config = { host: 'db.example.com', port: 3306 } as const;`<br>`config.host = 'new'; // Error!`                                                  | **`as const` is a relatively new feature. It allows us to write objects that are sealed in a way that you cannot modify any part of the object.**<br>**`as const` 是一个相对较新的功能。它允许我们以一种无法修改对象任何部分的方式编写密封对象。**<br>**Traditionally in JavaScript, even if you use `const` for an object, someone could modify a property on it (e.g., `config.host = 'new'`). You could use `Object.freeze` in JavaScript, but it only works at the first level and it's a runtime check. With `as const`, every nested property will also be immutable, and it's enforced at compile time by TypeScript. It will give you a type error if you try to modify anything. `Object.freeze` is evaluated at runtime, whereas `as const` is evaluated at build/compile time and will break the build (won't compile) if you try to modify the object.**<br>**传统上在 JavaScript 中，即使你对对象使用 `const`，某人也可以修改其上的属性（例如 `config.host = 'new'`）。你可以在 JavaScript 中使用 `Object.freeze`，但它只在第一层有效，并且是运行时检查。使用 `as const`，每个嵌套属性也将是不可变的，并且由 TypeScript 在编译时强制执行。如果你尝试修改任何内容，它将给出类型错误。`Object.freeze` 在运行时评估，而 `as const` 在构建/编译时评估，如果你尝试修改对象，它将中断构建（无法编译）。**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **04:29–06:04** | `private` Access Modifier<br>`private` 访问修饰符      | Restrict access to class members to within the class itself<br>限制对类成员的访问，仅限于类本身内部                              | Use the `private` keyword before a property or method declaration in a class<br>在类的属性或方法声明前使用 `private` 关键字                                                                             | `class Service { private config: string; constructor(c: string) { this.config = c; } }`<br>`const s = new Service('test'); s.config; // Error!`        | **The `private` access modifier means you won't be able to access the member from outside the class. If someone creates an instance of the class, they cannot access the private member (e.g., `new Service().config` won't work). TypeScript will tell us it's private and only accessible within that class.**<br>**`private` 访问修饰符意味着你无法从类外部访问该成员。如果有人创建了该类的实例，他们无法访问私有成员（例如 `new Service().config` 将不起作用）。TypeScript 会告诉我们它是私有的，只能在该类内部访问。**<br>**It's a very good way to apply the SOLID principle of interface segregation and really just exposing from a class the things that whoever is using that class needs, and nothing more. TypeScript is looking more and more like Java in this regard.**<br>**这是应用 SOLID 接口隔离原则的一个非常好的方法，并且只从类中暴露使用该类的人需要的东西，而不是更多。在这方面，TypeScript 看起来越来越像 Java。**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| **06:04–08:30** | Decorators<br>装饰器                                 | Add reusable functionality to classes or functions using a wrapping pattern<br>使用包装模式向类或函数添加可重用功能              | Create a decorator function that takes a target (class, method, etc.) and returns a modified version or adds metadata<br>创建一个装饰器函数，该函数接受一个目标（类、方法等）并返回修改后的版本或添加元数据                      | `@Injectable() class MyService { ... }`<br>`function Injectable(target: any) { // Add logic here }`                                                    | **Decorators are a way to basically reuse code following the decorator pattern, which means we just wrap a certain function or class with some code to add some shared functionality.**<br>**装饰器基本上是一种遵循装饰器模式来重用代码的方法，这意味着我们用一些代码包装某个函数或类，以添加一些共享功能。**<br>**A decorator is a function that can actually decorate a class (e.g., `@Injectable`). This is a very common use case in frameworks like Next.js or Angular. The `@Injectable` decorator is actually a function that takes the class before it is instantiated and it can modify the constructor or apply some changes. We can then reuse this decorator and apply it to as many classes as we want. You can decorate classes and you can also decorate functions. It's like a higher-order function to add extra functionality to another function. The cool thing is that you don't have class inheritance, so you avoid ending up with a very long prototypal chain and violating the Liskov substitution principle. It's a bit more going in the direction of composition over inheritance.**<br>**装饰器是一个实际上可以装饰类的函数（例如 `@Injectable`）。这是在 Next.js 或 Angular 等框架中非常常见的用例。`@Injectable` 装饰器实际上是一个函数，它在类被实例化之前接收该类，并且可以修改构造函数或应用一些更改。然后我们可以重用这个装饰器并将其应用到任意多的类上。你可以装饰类，也可以装饰函数。它就像一个高阶函数，为另一个函数添加额外的功能。很酷的是你没有类继承，因此可以避免最终出现非常长的原型链和违反里氏替换原则。它更像是朝着组合优于继承的方向发展。**                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| **08:30–10:29** | `type` vs `interface`<br>`type` 与 `interface` 的区别 | Understand the differences and use cases for defining shapes<br>了解定义形状的区别和用例                                   | Use `interface` for object shapes that need extension or declaration merging. Use `type` for unions, tuples, or complex types.<br>对需要扩展或声明合并的对象形状使用 `interface`。对联合类型、元组或复杂类型使用 `type`。 | `interface User { name: string; }`<br>`interface User { age: number; }` // Merges<br>`type ID = string \| number;`<br>`type Point = [number, number];` | **You could interchange both for the most part. The only difference is at build time: interfaces are merged, which means you can have the same interface declared in many parts of the code and it will get kind of merged at build time. Whereas types have to be unique; if you have another type with the same name you'll get a TypeScript error.**<br>**在大多数情况下，你可以互换使用两者。唯一的区别是在构建时：接口会被合并，这意味着你可以在代码的许多部分声明相同的接口，它会在构建时被合并。而类型必须是唯一的；如果你有另一个同名类型，你会得到一个 TypeScript 错误。**<br>**What does that mean for a developer? It means if you're building a library where you might want people to extend certain interfaces, it's much better to provide it as an interface. For example, imagine I'm building Express.js and someone needs to extend the request object. It's much better if the request type is an interface because then they can actually extend that with whatever field they want to add, and TypeScript will figure it out – it will take my interface and their interface and merge them together. Whereas with types, that's not the case. To answer when to use one or the other: I would use types to define your domain entities, domain types, things that are not going to change, things that are the core of your app. And I would use interfaces for things that I expect to be extended, like the request object in a web framework, or things that are provided by a library that you want your users to be able to customize or add fields to.**<br>**这对开发人员意味着什么？这意味着如果你正在构建一个库，并且可能希望人们扩展某些接口，那么将其作为接口提供会更好。例如，假设我正在构建 Express.js，有人需要扩展请求对象。如果请求类型是一个接口，那就好得多，因为他们实际上可以用他们想要添加的任何字段来扩展它，TypeScript 会解决这个问题——它会获取我的接口和他们的接口并将它们合并在一起。而对于类型，情况并非如此。回答何时使用哪一个：我会使用类型来定义你的领域实体、领域类型、不会改变的东西、应用程序核心的东西。我会将接口用于我期望被扩展的东西，比如 Web 框架中的请求对象，或者由库提供的你希望用户能够自定义或添加字段的东西。** |
| **10:29–11:08** | Type Guards<br>类型守卫                               | Narrow down the type of a variable within a conditional block<br>在条件块内缩小变量的类型                                  | Create a function that returns a type predicate (`arg is Type`) to check and narrow types at runtime<br>创建一个返回类型谓词（`arg is Type`）的函数，以在运行时检查和缩小类型                                       | `function isFruit(obj: any): obj is Fruit { return obj.type === 'fruit'; }`<br>`if (isFruit(myObj)) { myObj.eat(); // Type is narrowed to Fruit }`     | **A type guard is basically a function to guess certain types. You just want to filter out other types. You use it whenever you get a list of a type that's a union type, but you want to do something specific with an object that you can only do with one subtype of that union. You need to figure out, you know, "is this a pineapple rather than a fruit?" – you want to narrow the type of that object. Then you use one of those type guard functions.**<br>**类型守卫基本上是一个用来猜测特定类型的函数。你只想过滤掉其他类型。每当你得到一个联合类型的类型列表，但你想对一个对象做一些特定的事情，而这件事你只能使用该联合的一个子类型来完成时，你就会使用它。你需要弄清楚，“这是一个菠萝而不是水果吗？”——你想缩小该对象的类型。然后你使用其中一个类型守卫函数。**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| **11:08–END**   | Structural vs Nominal Typing<br>结构类型 vs 名义类型      | TypeScript uses structural typing (duck typing) based on shape, not name<br>TypeScript 使用基于形状的结构类型（鸭子类型），而不是名称 | Rely on the shape (properties and methods) of objects for type compatibility, not their explicit type name or declaration<br>依赖对象的形状（属性和方法）进行类型兼容性检查，而不是它们显式的类型名称或声明                    | `class Service { config: string; }`<br>`const obj = { config: 'test' };`<br>`const s: Service = obj; // OK in TS (Structural)`                         | **TypeScript basically implements structural typing, which means if two objects have the same properties, then they are the same thing for TypeScript. But if you go to languages like Java or C#, they implement mostly nominal typing. That means for something to be of a certain type it has to really match the same signature and be instances of the same class; it doesn't matter if they have the same properties if they were not instantiated by a class with the same name, it won't work. So the cool thing in TypeScript is that it gives you certain flexibility because you can always combine objects or interchange them if they satisfy the same properties. As always with JavaScript, we have more freedom than with strictly typed languages like the ones mentioned.**<br>**TypeScript 基本上实现了结构类型，这意味着如果两个对象具有相同的属性，那么对 TypeScript 来说它们就是同一个东西。但如果你使用像 Java 或 C# 这样的语言，它们主要实现名义类型。这意味着某物要属于某种类型，它必须真正匹配相同的签名并且是同一类的实例；如果它们不是由具有相同名称的类实例化的，那么它们是否具有相同的属性并不重要，它不会工作。所以 TypeScript 很酷的一点是它给了你一定的灵活性，因为如果对象满足相同的属性，你总是可以组合对象或互换它们。与往常一样，与上述严格类型语言相比，我们在 JavaScript 中拥有更多的自由。**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |

