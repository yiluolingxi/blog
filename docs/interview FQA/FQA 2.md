| Timestamp 时间戳   | Problem/Topic 问题/主题                                                                                   | Key Points 核心要点                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Solution Approach 解题思路                                                                                                                                                                                                                                                                             | Code Example Points 代码示例要点                                                                                                                                                                                                                             | Technical Explanation 技术讲解                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| :-------------- | :---------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **00:00–02:56** | Browser Storage: Cookies, LocalStorage, SessionStorage<br>浏览器存储：Cookies, LocalStorage, SessionStorage | Cookies: ~4KB, server+client accessible, sent with requests, great for auth tokens.<br>Cookies: ~4KB，服务器和客户端均可访问，随请求发送，非常适合认证令牌。<br>LocalStorage: Higher limit (~5-10MB), persists indefinitely, client-side only, good for app state.<br>LocalStorage: 更高限制 (~5-10MB)，持久存储，仅客户端，适用于应用状态。<br>SessionStorage: Similar to LocalStorage but cleared on tab/browser close, good for temporary data like form inputs.<br>SessionStorage: 类似 LocalStorage，但在标签页/浏览器关闭时清除，适用于表单输入等临时数据。                                                                                                      | Understand the use case: persistent auth (Cookies), persistent app state (LocalStorage), temporary session data (SessionStorage).<br>理解用例：持久认证（Cookies）、持久应用状态（LocalStorage）、临时会话数据（SessionStorage）。                                                                                               | `document.cookie`, `localStorage.setItem()`, `sessionStorage.setItem()`                                                                                                                                                                                | Okay, so basically cookies have a limit in terms of storage, it's around 4 kilobytes. They are server and client side, so server and client that means whenever you make an HTTP request you'll send the cookies through. That's why they are great for authentication, especially if they are HTTPS protected. They're great for storing things like the token or anything you want to share, kind of share state between server and client that you want to synchronize seamlessly because they get sent over by the browser.<br>好的，所以基本上cookies在存储方面有限制，大约4KB。它们是服务器和客户端共用的，这意味着每当您发出HTTP请求时，cookies都会被发送过去。这就是为什么它们非常适合认证，特别是如果是HTTPS保护的。它们非常适合存储令牌或任何您想在服务器和客户端之间共享的状态，因为浏览器会发送它们，从而实现无缝同步。<br>Local storage limit is much higher, I do not recall how much but it's much much higher. It's persisted indefinitely, so persisted forever versus cookies that have an expiration date. It's great for storing application state if you want to persist any of your state whenever, let's say you have some user state that they close the window but you want them to still have it, like the setting of the theme if you have a dark theme or light theme.<br>本地存储的限制要高得多，我不记得具体多少，但高很多很多。它是持久存储的，永久保存，而cookies有过期日期。它非常适合存储应用程序状态，如果您想持久化任何状态，例如用户关闭窗口后您仍希望保留的用户状态，比如深色或浅色主题的设置。<br>Session storage is a bit more peculiar because this one does get deleted when they close the tab or the browser window. So it's not used that much, but you could use session storage for things like whenever you want to store the form inputs, you don't want to lose them on page refresh, and the users start typing it out and if they refresh you do not want them to lose that. So you can store this in session storage, it gets automatically deleted when the users close the tab so you don't need to care about cleanup.<br>会话存储有点特殊，因为当用户关闭标签页或浏览器窗口时它会被删除。所以它用得不多，但你可以用它来存储诸如表单输入之类的东西，你不希望在页面刷新时丢失它们。用户开始输入，如果他们刷新页面，你不想让他们丢失输入内容。所以你可以把它存储在会话存储中，当用户关闭标签页时它会自动删除，你不需要关心清理问题。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **02:57–06:04** | Frontend Performance Optimizations (Build Level)<br>前端性能优化（构建层面）                                      | 1. Polyfill for browser compatibility.<br>1. 使用 Polyfill 实现浏览器兼容。<br>2. Apply compression (e.g., Gzip) to reduce payload size.<br>2. 应用压缩（如 Gzip）以减少负载大小。<br>3. Minify/Uglify code to remove whitespace, shorten variables.<br>3. 压缩/丑化代码以移除空白、缩短变量名。<br>4. Generate Source Maps for debugging in production.<br>4. 生成 Source Map 用于生产环境调试。<br>5. Implement Code Splitting & Lazy Loading.<br>5. 实现代码分割与懒加载。                                                                                                                                                                          | Use a module bundler (Webpack, Vite) to handle polyfilling, compression, minification, source maps, and code splitting automatically or with configuration.<br>使用模块打包器（Webpack, Vite）通过配置或自动处理 polyfill、压缩、丑化、Source Map 和代码分割。                                                                    | Webpack config for `babel-loader`, `TerserPlugin`, `SplitChunksPlugin`; Vite does much OOTB.<br>Webpack 配置 `babel-loader`, `TerserPlugin`, `SplitChunksPlugin`；Vite 开箱即用大部分功能。                                                                         | So, is it a modern frontend application? Could you give me more detail? Yeah, let's suppose a React application, client-side rendered. Let's use Webpack as a standard module bundler. So we probably need to bundle this in a bundler and probably the first thing you want to do is to polyfill the code. Number one, I will definitely polyfill because you probably want some modern features of JavaScript and not all the browsers support this and we don't want to worry about it. So I'll bundle our code and number one polyfill it, which will increase the size of our bundle but it's necessary.<br>那么，这是一个现代前端应用吗？能给我更多细节吗？是的，假设是一个客户端渲染的 React 应用。让我们用 Webpack 作为标准的模块打包器。所以我们可能需要用打包器打包代码，可能你要做的第一件事就是代码填充(Polyfill)。第一，我肯定会做填充，因为你可能想要一些 JavaScript 的现代特性，但并非所有浏览器都支持，我们不想为此担心。所以我会打包我们的代码，第一是填充，这会增加包的大小，但这是必要的。<br>Number two, we bundle it together so we're going to have this big bundle. The number two thing you want to do is to apply compression so we don't want to ship a Javascript file, we want to ship a Gzip file... and then with content negotiation indicate the browser 'hey this is a Gzip file' and then they'll take it, decompress it... so here we decrease probably 70% the payload over the network. So we increase loading time.<br>第二，我们把它打包在一起，所以会有一个大包。你想做的第二件事是应用压缩，我们不想发送 JavaScript 文件，我们想发送 Gzip 文件...然后通过内容协商告诉浏览器‘嘿，这是一个 Gzip 文件’，然后浏览器会接收并解压它...这样我们大概减少了网络上 70% 的有效载荷。所以我们提高了加载时间。<br>And there's a couple more optimizations... uglify the code, minification... they take code we written and remove new line characters and they replace variables... replacing them with very small variable names... it's basically transforming it into code you cannot read but it's likely smaller than the initial file... but because we do all this we also will need to emit some Source Maps... extra files that will map the source code to the code we actually distribute... so whenever we have a bug in production you'd be able to know in your source code where the exception happened.<br>还有更多的优化...代码丑化(Uglify)，压缩(Minification)...它们处理我们写的代码，移除换行符，替换变量...用非常短的变量名替换它们...基本上是把代码转换成你无法阅读的形式，但可能比原始文件小...但因为做了这些，我们还需要生成 Source Map...这些额外的文件将源代码映射到我们实际分发的代码...这样当生产环境出现 bug 时，你就能在源代码中知道异常发生在哪一行。<br>Number three, I would definitely look into code splitting just to make sure we only ship the JavaScript necessary for the initial load and we can lazy load or defer the JavaScript that's not strictly needed for the initial load.<br>第三，我肯定会考虑代码分割(Code Splitting)，以确保我们只发送初始加载所必需的 JavaScript，而可以懒加载或推迟加载那些初始加载并非严格需要的 JavaScript。                                                                                                                                                                                                                                                                                                                                        |
| **06:05–09:33** | Optimizing Large Images for Web Performance<br>优化大型图片的Web性能                                           | 1. Serve correctly sized images (don't serve 3000px for 800px display).<br>1. 提供正确尺寸的图片（不要为 800px 显示提供 3000px 的图片）。<br>2. Compress images (remove metadata, optimize color space).<br>2. 压缩图片（移除元数据，优化色彩空间）。<br>3. Use modern formats (WebP).<br>3. 使用现代格式（WebP）。<br>4. Use a CDN for caching and automatic optimizations (thumbnails, srcset).<br>4. 使用 CDN 进行缓存和自动优化（缩略图，srcset）。<br>5. Lazy load images not in the initial viewport.<br>5. 对不在初始视口内的图片进行懒加载。<br>6. Specify `width` & `height` to avoid CLS (Cumulative Layout Shift).<br>6. 指定 `width` 和 `height` 以避免累积布局偏移 (CLS)。 | Use image CDNs (e.g., Cloudflare, CloudFront) which often provide automatic optimization, format conversion, and srcset generation. Manually optimize images during build or use lazy loading libraries.<br>使用图片 CDN（如 Cloudflare, CloudFront），它们通常提供自动优化、格式转换和 srcset 生成。在构建时手动优化图片或使用懒加载库。       | `<img src="image.webp" width="800" height="600" loading="lazy" srcset="image-320w.webp 320w, image-640w.webp 640w" sizes="(max-width: 600px) 100vw, 50vw">`<br>Using modern CDN APIs for on-the-fly image transformation.<br>使用现代 CDN API 进行实时图片转换。    | The question is you are building a frontend application with very big images, maybe it's an eCommerce store, very high definition pictures. How would you optimize this for max performance? Images are always tough especially because designers don't necessarily want to compromise and they just want these big images. Normally a header and the footer and that takes a lot of work to actually load well.<br>问题是，你正在构建一个包含非常大图片的前端应用，可能是一个电子商务商店，非常高清晰度的图片。你如何为此做最大性能优化？图片总是很棘手，特别是因为设计师不一定愿意妥协，他们就想要这些大图片。通常是页眉和页脚，需要大量工作才能良好加载。<br>Size matters. You really want to ship the minimum size that you can. So you don't want to ship a 3,000 pixels image and render it as an 800 pixels element. So here you want to ship the minimum. Now the minimum means of course you want some sort of clarity, you don't want to show pixelated stuff, it's just going to be very low quality. Once you have the size (dimensions) you want to look into compression... tools can remove metadata from the image or you can modify the color space to include less colors, the image looks a bit less vibrant but it contains less data so it's smaller.<br>尺寸很重要。你确实想发送尽可能最小的尺寸。所以你不想发送一张 3000 像素的图片却把它渲染成 800 像素的元素。所以这里你想发送最小值。当然，最小值意味着你需要一定的清晰度，你不想显示像素化的东西，那会质量很低。一旦你确定了尺寸，你就要研究压缩...工具可以移除图片的元数据，或者你可以修改色彩空间来包含更少的颜色，图片看起来可能没那么鲜艳，但它包含的数据更少，所以更小。<br>And then of course I would always use the WebP format whenever we ship to the web, it's the most recommended for web performance. PNG is okay but WebP is the best. You want to put all the images in a CDN so you have the right caching policies on them. And then you can also look into lazy loading images if they don't need to be visible on the initial load, you can either lazy load or load on scroll. You got to be careful with lazy loading because those things might affect SEO but in general they're okay. And because you do lazy load, you need to specify width and height to avoid cumulative layout shift (CLS).<br>当然，只要发布到网上，我总是会使用 WebP 格式，这是对 Web 性能最推荐的格式。PNG 还可以，但 WebP 是最好的。你想把所有图片放在 CDN 上，这样就有正确的缓存策略。然后，如果图片不需要在初始加载时可见，你也可以考虑懒加载图片，你可以懒加载或在滚动时加载。对懒加载要小心，因为它可能会影响 SEO，但通常没问题。因为你做了懒加载，你需要指定宽度和高度以避免累积布局偏移 (CLS)。<br>And of course you can use the `srcset` attribute to ship different images depending on the viewport, on the device. So basically you can ship a different image on mobile and then load a different image on desktop. It's pretty much the same image but you can create smaller thumbnails of that image automatically. Usually CDNs offer that out of the box; modern CDNs would create the thumbnails for you and then give you a snippet that already includes srcsets so your image is as small as possible in the different devices.<br>当然，你可以使用 `srcset` 属性来根据视口、设备发送不同的图片。所以基本上，你可以在移动设备上发送一个不同的图片，然后在桌面上加载另一个图片。这几乎是同一张图片，但你可以自动创建该图片的较小缩略图。通常 CDN 会开箱即用地提供这个功能；现代 CDN 会为你创建缩略图，然后给你一个已经包含 srcset 的代码片段，这样你的图片在不同设备上就能尽可能小。 |
| **09:34–12:19** | Managing Code Quality at Scale<br>大规模代码质量管理                                                           | 1. Linters (ESLint) & Formatters (Prettier) for code style and catching issues.<br>1. 使用 Linters (ESLint) 和 Formatters (Prettier) 保证代码风格和发现问题。<br>2. TypeScript for type safety.<br>2. 使用 TypeScript 保证类型安全。<br>3. Unit Tests and E2E Tests.<br>3. 单元测试和端到端 (E2E) 测试。<br>4. Dependency vulnerability scanning.<br>4. 依赖项漏洞扫描。<br>5. Accessibility (a11y) scanning.<br>5. 可访问性 (a11y) 扫描。<br>6. Performance monitoring (Lighthouse, Sentry) for Core Web Vitals.<br>6. 性能监控（Lighthouse, Sentry）以跟踪核心 Web 指标 (Core Web Vitals)。                                                         | Integrate tools into the CI/CD pipeline: Linting/Type checking on PRs, automated tests, security scans, and performance monitoring in production.<br>将工具集成到 CI/CD 流水线中：在 Pull Request 上进行代码检查和类型检查，自动化测试，安全扫描，以及生产环境性能监控。                                                                          | `eslint .`, `prettier --check .`, `npm audit`, `jest`, `cypress run`, lighthouse CI, Sentry SDK.<br>ESLint、Prettier、npm 审计、Jest、Cypress、Lighthouse CI、Sentry SDK 等命令或工具。                                                                               | How would you manage code quality in a large scale front-end application? What tools and practices would you use? For code quality I would probably start with a linter (like ESLint)... so you want to basically catch small issues, make sure everybody codes the same style. You're going to have Prettier, ESLint setup. If you're using TypeScript, have the TS lint setup. It just takes off a lot of the work and communication because everybody guides code in the same style.<br>你如何管理大规模前端应用的代码质量？你会使用什么工具和实践？对于代码质量，我可能从一个 linter（如 ESLint）开始...所以你基本上是想捕捉小问题，确保每个人的代码风格一致。你会配置 Prettier、ESLint。如果你用 TypeScript，就配置 TSLint。这省去了很多工作和沟通，因为每个人都以相同的风格编写代码。<br>After that you do want to have a layer of unit test and ideally some e2e test for sure. And finally I would have something like a dependency scan. Ideally you also have in your linter something to scan for a11y, which stands for accessibility, so we taking care of code quality and style, we have accessibility covered, we have testing, we have a dependency scan to tell us how our dependencies (node modules) can be very vulnerable to different attacks.<br>之后，你肯定需要一层单元测试，理想情况下还有一些端到端测试。最后，我会使用依赖项扫描之类的东西。理想情况下，你的 linter 中还包含一些扫描 a11y（即可访问性）的功能。这样我们就照顾到了代码质量和风格，覆盖了可访问性，有了测试，有了依赖项扫描来告诉我们我们的依赖（node modules）如何容易受到不同攻击。<br>And finally maybe you want to also add something like Lighthouse or Sentry to your pipeline and they will tell you how your Core Web Vitals change, basically how your web performance changes over time. So if by any chance we make any mistake with a big image like we mentioned before or we add fonts, we immediately see the effect of that on our web performance and we can fix it early on.<br>最后，也许你还想在流水线中加入 Lighthouse 或 Sentry 之类的东西，它们会告诉你你的核心 Web 指标 (Core Web Vitals) 如何变化，基本上就是你的 Web 性能随时间的变化情况。这样，如果我们像之前提到的那样在处理大图片时犯了错误，或者添加了字体，我们就能立即看到这对我们 Web 性能的影响，并及早修复它。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| **12:20–14:42** | XSS Attacks & Prevention<br>XSS 攻击与防范                                                                 | XSS (Cross-Site Scripting): Attacker injects malicious scripts into web pages viewed by others.<br>XSS (跨站脚本攻击): 攻击者将恶意脚本注入到其他人查看的网页中。<br>Prevention: 1. Sanitize user input (validate, escape). 2. Avoid directly rendering unsanitized HTML/JS from users/backend.<br>防范: 1. 对用户输入进行消毒（验证、转义）。 2. 避免直接渲染来自用户/后端的未消毒的 HTML/JS。                                                                                                                                                                                                                                                       | Use trusted libraries to sanitize input (e.g., DOMPurify). Avoid using `dangerouslySetInnerHTML` in React or equivalent in other frameworks. Implement Content Security Policy (CSP) headers.<br>使用受信任的库来消毒输入（例如 DOMPurify）。避免在 React 中使用 `dangerouslySetInnerHTML` 或其他框架中的等效功能。实施内容安全策略 (CSP) 头部。 | `import DOMPurify from 'dompurify'; const cleanHTML = DOMPurify.sanitize(userInput);`<br>React: Avoid `dangerouslySetInnerHTML={{ __html: userContent }}` unless sanitized.<br>使用 DOMPurify 库消毒HTML；在 React 中避免直接使用 `dangerouslySetInnerHTML` 插入未消毒内容。 | What is an XSS attack and how can you make sure your frontend application is not vulnerable? XSS stands for Cross-Site Scripting. So basically, as I recall, in XSS the attacker somehow persists some sort of JavaScript code into our database. And then our users, because they fetch things from our database, they can run that. A good example would be Facebook... someone was writing comments on famous posts as JavaScript and whenever you load that post, you render that comment, you'd actually run that JavaScript on your machine.<br>什么是 XSS 攻击？你如何确保你的前端应用不易受此类攻击？XSS 代表跨站脚本攻击。基本上，据我所知，在 XSS 中，攻击者以某种方式将某种 JavaScript 代码持久化到我们的数据库中。然后我们的用户，因为他们从我们的数据库获取内容，他们就可以运行它。一个很好的例子是 Facebook...有人用 JavaScript 在著名帖子上写评论，当你加载那个帖子时，你渲染那条评论，实际上就在你的机器上运行了那个 JavaScript。<br>What does this mean? It means basically I could actually have sent over the network in that JavaScript a `fetch` with a POST and send your password and credentials over the network to myself, for example. So that's basically the attack itself.<br>这意味着什么？这基本上意味着我实际上可以在那个 JavaScript 中通过网络发送一个带有 POST 的 `fetch` 请求，例如，把你的密码和凭证发送给我自己。所以这基本上就是攻击本身。<br>If you want to prevent this in the front end, number one thing you want to do is sanitize input. So sanitize input means the attacker ideally cannot persist JavaScript code into our database as comments or text input. We are able to somehow detect that and remove it, and we don't want to add JavaScript to our database. But even if they manage to do that somehow, we could actually make sure we never render HTML or JS from the user, or that we receive over the network. It's a bad practice. So one of the things if you ever use React, you probably know of the `dangerouslySetInnerHTML` and you want to avoid this at all cost because this means you're giving code that you're not aware what it does to the browser to render on your user's browser. So I would avoid this as much as you can. Basically two things: sanitize the input and avoid just directly rendering JS or HTML that you receive from the back end into the front end.<br>如果你想在前端防止这种情况，第一件要做的事就是对输入进行消毒(Sanitize)。消毒输入意味着攻击者理想情况下无法将 JavaScript 代码作为评论或文本输入持久化到我们的数据库中。我们能够以某种方式检测并移除它，并且我们不想向数据库中添加 JavaScript。但即使他们设法以某种方式做到了，我们实际上也可以确保我们从不渲染来自用户的 HTML 或 JS，或者我们从网络接收到的内容。这是一种不好的做法。所以，如果你用过 React，你可能知道 `dangerouslySetInnerHTML`，你要不惜一切代价避免使用它，因为这意味着你正在将你不知道其功能的代码交给浏览器，在用户的浏览器上渲染。所以我我会尽可能避免它。基本上是两件事：对输入进行消毒，并避免直接渲染你从后端接收到的 JS 或 HTML 到前端。                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **14:43–16:29** | How CDNs Work & Their Benefits<br>CDN 的工作原理与优势                                                        | CDN (Content Delivery Network): A distributed network of servers that delivers content based on user's geographic location for lower latency.<br>CDN (内容分发网络): 一个分布式服务器网络，根据用户的地理位置交付内容以降低延迟。<br>Advantages: Faster load times, reduced origin server load, DDoS mitigation, often includes extra features (image optimization).<br>优势: 更快的加载时间，减轻源服务器负载，缓解 DDoS 攻击，通常包含额外功能（如图片优化）。<br>Disadvantages: Cost, additional complexity, potential caching issues.<br>劣势: 成本，额外的复杂性，潜在的缓存问题。                                                                                               | Use a CDN provider (e.g., AWS CloudFront, Cloudflare) by pointing your domain's DNS to the CDN and configuring the origin server.<br>通过将你的域名 DNS 指向 CDN 并配置源服务器，来使用 CDN 提供商（如 AWS CloudFront, Cloudflare）。                                                                                         | DNS CNAME record pointing to `your-distribution.cloudfront.net`. Configuration in CDN provider's console to set origin.<br>DNS CNAME 记录指向 CDN 分发域名；在 CDN 提供商控制台中配置源站。                                                                                  | Can you explain quickly how a CDN works? What are some advantages/disadvantages? I love CDN, by the way, one of the best tools in the front end. Basically what it does is... it's a Content Delivery Network. So there's a network of servers that will replicate our website. And whenever somebody's accessing it from a geographical location, rather than getting the assets from our server (the HTML, JavaScript, and CSS), they would get them from an edge location of the CDN.<br>你能快速解释一下 CDN 是如何工作的吗？有什么优点/缺点？顺便说一句，我喜欢 CDN，它是前端最好的工具之一。基本上它的作用是...它是一个内容分发网络。所以有一个服务器网络会复制我们的网站。当有人从某个地理位置访问它时，他们不是从我们的服务器（HTML、JavaScript 和 CSS）获取资源，而是从 CDN 的边缘站点获取它们。<br>Imagine our website. I create a CDN distribution (let's put it in yellow) and I spread it over the globe. If I have a user over here, the user gets the asset from the closer location to them. The way this is done is with a DNS table that routes the user based on latency. So they would get the asset from the location that's closer to them basically. They're amazing, really easy to set up, and I would say it's a must-have for pretty much any client application, any frontend application.<br>想象一下我们的网站。我创建一个 CDN 分发（用黄色表示），并将其分布到全球。如果我在这里有一个用户，用户就从离他们更近的位置获取资源。实现这一点的方式是通过一个基于延迟路由用户的 DNS 表。所以基本上他们会从离他们更近的位置获取资源。它们太棒了，真的很容易设置，我想说对于几乎任何客户端应用、任何前端应用都是必须的。<br>The most common provider? I would probably use AWS CloudFront if you're on AWS. I use this one a lot in the past. But you can also use Cloudflare, they are very established, very well, Cloudflare totally recommended. Azure CDN too, they can all do the job. But those two (AWS, Cloudflare) I found very easy to set up.<br>最常用的提供商？如果你在用 AWS，我可能会用 AWS CloudFront。我过去经常用它。但你也可以使用 Cloudflare，它们非常成熟，非常好，完全推荐 Cloudflare。Azure CDN 也可以，它们都能完成工作。但我发现这两个（AWS, Cloudflare）非常容易设置。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **16:30–19:46** | Micro Frontends: Concept & When to Use<br>微前端：概念与使用时机                                                 | Micro Frontends: An architectural style where a frontend app is decomposed into smaller, semi-independent "micro apps" working together.<br>微前端：一种架构风格，将前端应用分解为更小的、半独立的、“微应用”并协同工作。<br>When to use: For very large teams (>30 FE engineers) where a monolith causes deployment bottlenecks, team coordination issues, and slow development.<br>使用时机：适用于非常大的团队（> 30 名前端工程师），单体架构导致部署瓶颈、团队协作问题和开发速度缓慢。<br>Trade-off: Adds significant complexity (shared state, tooling, integration). Not recommended for smaller teams/apps.<br>权衡：增加了显著的复杂性（共享状态、工具、集成）。不推荐用于较小团队/应用。                | Use frameworks/federation tools (e.g., Module Federation in Webpack, Single-SPA) to compose micro frontends. A shell application often handles auth and integration.<br>使用框架/联合工具（如 Webpack 中的 Module Federation, Single-SPA）来组合微前端。一个外壳应用通常处理认证和集成。                                               | Webpack Module Federation: `new ModuleFederationPlugin({ name: "shell", remotes: { mf1: "mf1@http://..." }})`<br>Using `single-spa` framework to orchestrate multiple micro-apps.<br>使用 Webpack Module Federation 插件配置；使用 `single-spa` 框架编排多个微应用。      | What are micro frontends and when would you use this kind of frontend architecture? Typically we'd have a frontend monolith. Imagine we have different components: a header, the body, maybe a checkout. This works pretty fine when we have a smaller team. But as we add more and more people to the team, it will be harder to contribute on the single frontend monolith. As you get past maybe 30 frontend engineers, it makes sense to split those individual pieces into independent applications. So this one has its own domain, this one has its own domain, and there is a shell (the main one) that puts them all together, responsible for authentication, shared state.<br>什么是微前端？你什么时候会使用这种前端架构？通常我们有一个前端单体。想象我们有不同的组件：页眉、主体、也许还有一个结账部分。当我们团队规模较小时，这工作得很好。但随着我们向团队增加越来越多的人，在单一前端单体上协作将变得更加困难。当你超过大约 30 个前端工程师时，将这些独立的部分拆分成独立的应用程序是有意义的。所以这个有自己的域，那个有自己的域，然后有一个外壳应用（主要的那个）把它们全部整合在一起，负责认证、共享状态。<br>Because you have this, you can actually deploy, for example, this one independently and have a team working only on this one. It allows you to really separate development teams and you can make development faster. But you do pay a price of complexity in the front end because they add a lot of complexity to your setup, and you need very complex tooling. When does it make sense? Micro frontends are mostly good when you want to split your organization, split people into teams that want to work separately. You always pay the price when we distribute systems (hard to share state, etc.). So I wouldn't pay that price until you have a very good reason. The only good reason is that you have so many people working on the front end and you start having issues with the deployment pipeline (e.g., it takes very long to deploy, teams block each other). It's more about "we need to make the organization faster". You do need a certain scale. Most companies probably have done this too early and realized it's a lot of complexity. If you are building smaller websites or smaller applications, I wouldn't even bother about it.<br>正因为如此，你实际上可以独立部署，例如，这个部分，并让一个团队只专注于这个部分。它让你能够真正分离开发团队，并可以加快开发速度。但你确实在前端付出了复杂性的代价，因为它们给你的设置增加了很多复杂性，并且你需要非常复杂的工具。什么时候有意义？微前端主要在你想要拆分组织，将人员分成希望独立工作的团队时很有用。当我们分布系统时，你总是要付出代价（难以共享状态等）。所以除非有非常充分的理由，否则我不会付出那个代价。唯一充分的理由是你有非常多人从事前端工作，并且开始出现部署流水线问题（例如，部署时间很长，团队互相阻塞）。这更多是关于“我们需要让组织更快”。你确实需要一定的规模。大多数公司可能过早地做了这件事，并意识到复杂性很高。如果你正在构建较小的网站或应用程序，我甚至不会考虑它。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |