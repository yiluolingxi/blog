| Timestamp 时间戳   | Problem/Topic 问题/主题                                     | Key Points 核心要点                                                                                      | Solution Approach 解题思路                                                                                              | Code Example Points 代码示例要点                                                              | Technical Explanation 技术讲解                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| --------------- | ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **00:00–01:03** | Difference between `em` and `rem`  <br>`em` 和 `rem` 的区别 | Both are relative units; `em` relative to parent, `rem` to root  <br>都是相对单位；`em` 相对于父元素，`rem` 相对于根元素 | Use `em` for scalable component layouts, `rem` for consistent global scaling  <br>使用 `em` 实现可伸缩组件布局，`rem` 实现一致的全局缩放 | `font-size: 1.2em;`  <br>`font-size: 1.2rem;`                                           | **They are both relative sizing elements, meaning you can use them to give relative size and it'll be responsive.**  <br>**它们都是相对尺寸单位，意味着你可以用它们来设置相对大小，并且会是响应式的。**  <br>  <br>**`em` is referring to the font size of the parent element.**  <br>**`em` 指的是父元素的字体大小。**  <br>  <br>**`rem` is pretty much the same thing, but the 'r' stands for 'root' and it's binded to the HTML element.** So it means the font size of the HTML tag in the document, not of the immediate parent.  <br>**`rem` 非常相似，但 'r' 代表 'root'（根），它绑定到 HTML 元素。** 所以它指的是文档中 HTML 标签的字体大小，而不是直接父元素的字体大小。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **01:03–04:17** | CSS Box Model  <br>CSS 盒子模型                             | Describes content, padding, border, margin  <br>描述内容、内边距、边框、外边距                                      | Understand how each layer affects layout  <br>理解每一层如何影响布局                                                           | `box-sizing: border-box;`  <br>`width: 300px; padding: 10px; border: 1px; margin: 5px;` | **The Box model is basically the way that in CSS we manage how content is being displayed. Pretty much every element has a content box.**  <br>**盒子模型基本上是 CSS 中我们管理内容显示方式的方法。几乎每个元素都有一个内容框。**  <br>  <br>**We have the content inside, and it can have a width either implicitly calculated by the browser based on the content or explicitly set by us.** The Box model dictates how the padding and margin will behave.  <br>**我们在里面有内容，它可以有一个由浏览器根据内容隐式计算出的宽度，或者由我们显式设置的宽度。** 盒子模型规定了内边距（padding）和外边距（margin）的行为方式。  <br>  <br>**The margin doesn't account for content; it's just kind of outside. And the inside, we have the content and then the padding.** In the case of background images, they do occupy the space of padding if there is any.  <br>**外边距（margin）不计入内容；它就在外部。而在内部，我们有内容，然后是内边距（padding）。** 对于背景图像，如果有内边距，它们确实会占据内边距的空间。  <br>  <br>**Now let's think about box shadow: it will just appear over here where the margin is, depending on how much shadow we add.**  <br>**现在想想盒子阴影：它会出现在外边距所在的这里，具体位置取决于我们添加了多少阴影。**  <br>  <br>**The number one mistake frontend developers make when doing CSS interviews is that they get distracted by shiny objects like animations, Transitions, and transforms, instead of focusing on core fundamentals like the Box model, specificity, selectors, inheritance, and cascading.** In fact, if you master those Basics you will be able to answer 99% of CSS questions correctly. The most important CSS question you will ever get is "can you explain the CSS Box model?".  <br>**前端开发人员在 CSS 面试中犯的头号错误是，他们被动画、过渡和变换等闪亮的东西分心，而不是专注于核心基础知识，如盒子模型、特异性、选择器、继承和层叠。** 事实上，如果你掌握了这些基础知识，你就能正确回答 99% 的 CSS 问题。你会被问到的最重要的 CSS 问题是“你能解释一下 CSS 盒子模型吗？”。 |
| **04:17–06:03** | CSS Specificity  <br>CSS 特异性                            | Determines which style is applied when conflicts occur  <br>决定冲突时应用哪个样式                              | Calculate specificity using ID > class > tag  <br>使用 ID > class > tag 计算特异性                                         | `#nav-bar` (higher) vs `.nav-item` (lower)  <br>`#nav-bar`（更高） vs `.nav-item`（更低）       | **CSS specificity is basically needed because we can have different styles applied to the same element and we need to figure out which ones to actually apply when we render that element.**  <br>**基本上需要 CSS 特异性是因为我们可以对同一个元素应用不同的样式，并且我们需要弄清楚在渲染该元素时实际应用哪些样式。**  <br>  <br>**What the browser does is, based on how the style rule was applied (whether it was an ID, a class, or just a simple tag), figure out the importance of that rule by calculating the specificity and basically apply the rule with the highest specificity.**  <br>**浏览器所做的是，根据样式规则的应用方式（是 ID、类还是简单的标签），通过计算特异性来确定该规则的重要性，并基本上应用具有最高特异性的规则。**  <br>  <br>**The highest specificity you can have is when you add `!important` next to a tag, and then it will always be applied.** That's how the browser basically figures out if you have multiple rules applied to the same element, which one to apply, which one to render.  <br>**你能拥有的最高特异性是在标签旁边添加 `!important`，然后它将始终被应用。** 这就是浏览器基本上弄清楚如果你对同一个元素应用了多个规则，该应用哪一个，该渲染哪一个的方式。  <br>  <br>**In the example, the ID (`#nav-bar`) has higher specificity than the class (`.nav-item`), so the color would be blue.** IDs have precedence; they have a higher specificity than classes.  <br>**在示例中，ID (`#nav-bar`) 比类 (`.nav-item`) 具有更高的特异性，因此颜色将是蓝色的。** ID 具有优先权；它们比类具有更高的特异性。                                                                                                                                                                                                                                                                                                                                                                                                 |
| **06:03–09:01** | Avoiding Global CSS Conflicts  <br>避免全局 CSS 冲突          | Global CSS can cause unintended style overrides  <br>全局 CSS 可能导致意外的样式覆盖                              | Use scoped CSS (e.g., CSS-in-JS, BEM) or unique class names  <br>使用作用域 CSS（如 CSS-in-JS、BEM）或唯一类名                    | BEM: `.block__element--modifier`  <br>CSS-in-JS: `styled-components`                    | **One of the implications in a real-life codebase is that you might end up, if you're not careful about your selectors, modifying the styles on elements that you didn't want to, by applying very generic rules.** You end up changing the styles of a global element by mistake.  <br>**在现实代码库中的一个影响是，如果你不小心选择器，通过应用非常通用的规则，你最终可能会修改你本不想修改的元素的样式。** 你最终会错误地更改全局元素的样式。  <br>  <br>**One of the things I used in the past to avoid this is using the BEM methodology, where you start writing very specific nested rules there a specific convention with the BEM.**  <br>**我过去用来避免这种情况的方法之一是使用 BEM 方法，你可以用 BEM 的特定约定开始编写非常具体的嵌套规则。**  <br>  <br>**Or you can use CSS-in-JS, which will basically generate a unique class name (like a hash class name) and that makes sure that there are no specificity issues or conflicts when you render your components in a framework like React.** This is implemented by styled-components. They generate a unique class so you don't have any Global naming issues.  <br>**或者你可以使用 CSS-in-JS，它基本上会生成一个唯一的类名（像哈希类名），这确保了当你在像 React 这样的框架中渲染组件时，没有特异性问题或冲突。** 这是由 styled-components 实现的。它们生成一个唯一的类，因此你没有任何全局命名问题。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **09:01–10:12** | Critical CSS (Revisited)  <br>关键 CSS（复习）                | CSS needed for above-the-fold content  <br>首屏内容所需的 CSS                                               | Extract and inline critical CSS, defer the rest  <br>提取并内联关键 CSS，延迟加载其余部分                                           | Use Webpack plugins or headless browsers  <br>使用 Webpack 插件或无头浏览器                       | **Critical CSS is CSS that we can extract because it's the only CSS needed to render the above-the-fold portion of a page.** So whenever we render an application, we're talking about what the user sees in the viewport without scrolling, the first thing they see.  <br>**关键 CSS 是我们可以提取的 CSS，因为它是渲染页面首屏（above-the-fold）部分唯一需要的 CSS。** 所以每当我们渲染应用程序时，我们谈论的是用户在视口中无需滚动就能看到的内容，他们首先看到的东西。  <br>  <br>**We can actually extract those rules that render that and ship them differently as critical CSS.** It's called critical because it's the CSS you need to render in the critical rendering path to have no cumulative layout shift (CLS).  <br>**我们实际上可以提取那些渲染首屏的规则，并作为关键 CSS 以不同的方式交付。** 它之所以称为“关键”，是因为它是你在关键渲染路径中需要渲染的 CSS，以避免累积布局偏移 (CLS)。  <br>  <br>**That would allow us to basically render as little CSS as possible in our first render and make the page faster. And then we can load the rest of the CSS after that initial render.**  <br>**这将使我们基本上在首次渲染时尽可能少地渲染 CSS，并使页面更快。然后我们可以在初始渲染之后加载其余的 CSS。**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **10:12–END**   | Managing CSS at Scale  <br>大规模管理 CSS                    | Challenges with global namespace and team collaboration  <br>全局命名空间和团队协作的挑战                          | Use design systems, CDN caching, and extract common CSS  <br>使用设计系统、CDN 缓存和提取公共 CSS                                 | Extract design system CSS separately for longer caching  <br>分离设计系统 CSS 以实现更长缓存         | **In bigger applications, with several teams working on the same frontend application, we end up having troubles with one team deploying code and destroying the view of another team without even them noticing.** Because again, CSS is this global name space and you can easily pollute it by adding very generic selectors.  <br>**在大型应用程序中，当多个团队在同一个前端应用程序上工作时，我们最终会遇到一个团队部署代码并破坏另一个团队的视图的问题，甚至他们自己都没有注意到。** 因为 CSS 是一个全局命名空间，你很容易通过添加非常通用的选择器来污染它。  <br>  <br>**One solution is CSS-in-JS, but a problem with it is that it can be very difficult to cache our Styles because CSS-in-JS would be injected in the JavaScript.** So we had to change the configuration to extract the Styles in a different stylesheet and then bundle that to still have the CDN caching on it. Otherwise, CSS will be shipped with our JavaScript bundle and that would be less performant.  <br>**一个解决方案是 CSS-in-JS，但它的一个问题是很难缓存我们的样式，因为 CSS-in-JS 会被注入到 JavaScript 中。** 所以我们必须更改配置，将样式提取到不同的样式表中，然后进行捆绑，以便仍然可以在上面使用 CDN 缓存。否则，CSS 将和我们的 JavaScript 包一起发送，那样性能会较差。  <br>  <br>**The practice you could do is to extract, for example, the CSS that your design system uses and ship that differently from the specific styles that will change a lot.** What that would allow you to do is to have a much longer caching policy on your design system CSS. So unless you change the design system, the users don't have to download this huge CSS file from the design system; they only need to download maybe the small style that comes from your components.  <br>**你可以做的实践是，例如，提取你的设计系统使用的 CSS，并将其与变化频繁的特定样式分开交付。** 这样做可以让你对设计系统 CSS 制定更长的缓存策略。因此，除非你更改设计系统，否则用户不必从设计系统下载这个巨大的 CSS 文件；他们可能只需要下载来自你的组件的小样式文件。       |